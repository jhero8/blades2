<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black">
    <meta name="apple-mobile-web-app-title" content="Bladder Diary">
    <title>Bladder Diary</title>
    <style>
        /* Basic reset */
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
        }
        
        body {
            background: linear-gradient(to bottom right, #f0f8ff, #f7f7f7);
            color:  #2d3748;
            line-height: 1.8;
            padding: 16px;
            max-width: 500px;
            margin: 0 auto;
            overflow-x: hidden; /* Prevent horizontal scrolling */
        }
        
        /* Header styles */
        header {
            text-align: center;
            margin-bottom: 16px;
        }
        
        .app-logo {
            width: 64px;
            height: 64px;
            border-radius: 50%;
            background: linear-gradient(135deg, #4f9cf9, #a651e6, #f9c74f);
            margin: 0 auto 12px;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .app-logo-inner {
            width: 56px;
            height: 56px;
            border-radius: 50%;
            background: white;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .app-logo-core {
            width: 48px;
            height: 48px;
            border-radius: 50%;
            background: linear-gradient(135deg, #4f9cf9, #a651e6, #f9c74f);
            opacity: 0.8;
        }
        
        h1 {
            font-size: 24px;
            color: #333;
            margin-bottom: 4px;
        }
        
        .subtitle {
            font-size: 14px;
            color: #666;
        }
        
        /* Privacy notice */
        .privacy-notice {
            text-align: center;
            font-size: 12px;
            color: #718096;
            background-color: rgba(237, 242, 247, 0.7);
            border-radius: 8px;
            padding: 8px 12px;
            margin-bottom: 16px;
            line-height: 1.4;
        }
        
        .privacy-notice svg {
            width: 14px;
            height: 14px;
            vertical-align: middle;
            margin-right: 4px;
        }
        .btn:hover, .card:hover {
    box-shadow: 0 8px 16px rgba(0,0,0,0.1);
}
        /* Button styles */
        .btn {
            display: block;
            width: 100%;
            padding: 12px;
            border-radius: 8px;
            border: none;
            font-weight: 500;
            cursor: pointer;
            text-align: center;
            margin-bottom: 16px;
            font-size: 16px;
            box-shadow: 0 4px 8px rgba(0,0,0,0.05);
    transition: box-shadow 0.2s ease;
        }
        
        .btn-primary {
            background-color: #5a67d8;
            color: white;
        }
        
        .btn-primary:hover {
            background-color: #4c51bf;
        }
        
        .btn-success {
            background-color: #48bb78;
            color: white;
        }
        
        .btn-success:hover {
            background-color: #38a169;
        }
        
        .btn-danger {
            background-color: #e53e3e;
            color: white;
            padding: 8px 12px;
            border-radius: 4px;
            font-size: 14px;
            display: inline-block;
            width: auto;
            margin-bottom: 0;
        }
        
        .btn-secondary {
            background-color: #4299e1;
            color: white;
            /*padding: 8px 16px;*/
            font-size: 14px;
            margin: 8px 0;
            display: inline-block;
        }
        
        /* Timer button styles */
        .timer-btn {
            background-color: #4299e1;
            color: white;
            padding: 8px 12px;
            border-radius: 4px;
            border: none;
            font-size: 14px;
            cursor: pointer;
            display: inline-flex;
            align-items: center;
            margin-left: 8px;
        }
        
        .timer-btn.active {
            background-color: #e53e3e;
            animation: pulseBorder 1s infinite;
        }
        @keyframes pulseBorder {
    0%, 100% { box-shadow: 0 0 0 2px #e53e3e; }
    50% { box-shadow: 0 0 0 6px rgba(229,62,62,0.5); }
}
        
        .timer-btn svg {
            margin-right: 4px;
            width: 14px;
            height: 14px;
        }
        
        /* Timer indicator */
        .timer-indicator {
            display: inline-block;
            margin-left: 8px;
            font-size: 14px;
            font-weight: 500;
            color: #e53e3e;
        }
        
        /* Timer field container */
        .timer-field-container {
            display: flex;
            align-items: center;
        }
        
        /* Form styles */
        .form {
            background-color: white;
            padding: 16px;
            border-radius: 8px;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
            margin-bottom: 24px;
        }
        
        .form.hidden {
            display: none;
        }
        
        .form-group {
            margin-bottom: 16px;
        }
        
        .form-group.grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 12px;
        }
        
        .form-label {
            display: block;
            font-size: 14px;
            font-weight: 500;
            margin-bottom: 4px;
            color: #4a5568;
        }
        
        .form-control {
            display: block;
            width: 100%;
            padding: 8px;
            border: 1px solid #e2e8f0;
            border-radius: 4px;
            font-size: 16px;
            box-shadow: 0 4px 8px rgba(0,0,0,0.05);
    transition: box-shadow 0.2s ease;
        }
        
        .form-control:focus {
            border-color: #a0aec0;
            outline: none;
        }
        
        .form-check {
            display: flex;
            align-items: center;
        }
        
        .form-check-input {
            margin-right: 8px;
        }
        
        .section-header {
            font-size: 16px;
            font-weight: 500;
            color: #4a5568;
            margin-bottom: 8px;
            padding-top: 8px;
            border-top: 1px solid #e2e8f0;
        }
        
        /* Entries list */
        .card {
            background-color: white;
            border-radius: 8px;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
            overflow: hidden;
            margin-bottom: 16px;
            box-shadow: 0 4px 8px rgba(0,0,0,0.05);
    transition: box-shadow 0.2s ease;
        }
        
        .card-header {
            background-color: #f8fafc;
            padding: 12px 16px;
            border-bottom: 1px solid #e2e8f0;
        }
        
        .card-title {
            font-size: 18px;
            font-weight: 500;
            color: #4a5568;
        }
        
        .card-body {
            padding: 16px;
        }
        @keyframes fadeInUp {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
}
.entry-item {
    padding: 12px 16px; /* Reduced from 16px all around */
    border-bottom: 1px solid #e2e8f0;
    animation: fadeInUp 0.3s ease;
    transition: background-color 0.2s;
    margin-top: 1px;
    margin-bottom: 1px; /* Reduced from 4px */
    border-radius: 4px;
}

.entry-item:hover {
    background-color: #f7fafc;
}

.entry-time {
    font-weight: 600;
    line-height: 1.5;
    padding-left: 0; /* Remove any left padding */
    margin-left: 0; /* Remove any left margin */
    color: #2d3748;
    font-size: 15px; /* Increased from default */
    display: flex;
    align-items: center;
}

.urgency-0 {
    color: #48bb78; /* Green */
}
.urgency-1 {
    color: #4299e1; /* Blue */
}
.urgency-2 {
    color: #ecc94b; /* Yellow */
}
.urgency-3 {
    color: #f56565; /* Red */
}

.stream-strong {
    color: #48bb78; /* Green */
    font-weight: 600;
}
.stream-intermittent {
    color: #ecc94b; /* Yellow */
    font-weight: 600;
}
.stream-weak {
    color: #f56565; /* Red */
    font-weight: 600;
}
        
        .entry-header {
            display: flex;
            justify-content: space-between;
            margin-bottom: 6px;
            align-items: center;
        }
        
        .entry-date {
    display: flex;
    align-items: center;
}
        
.entry-details {
    display: grid;
    grid-template-columns: auto 1fr;
    gap: 4px 12px; /* Horizontal gap between label and value */
    font-size: 14px;
    line-height: 1.5;
    margin-top: 4px;
}
        
.entry-label {
    font-weight: 600;
    color: #718096;
}

.entry-label, .entry-details div {
    display: flex;
    align-items: center;
}
        
        .no-entries {
            text-align: center;
            color: #a0aec0;
            padding: 24px;
        }
        
        /* Message styles */
        .message {
            padding: 12px;
            border-radius: 4px;
            margin-bottom: 16px;
        }
        
        .message-danger {
            background-color: #fed7d7;
            border: 1px solid #feb2b2;
            color: #c53030;
        }
        
        .message-success {
            background-color: #c6f6d5;
            border: 1px solid #9ae6b4;
            color: #2f855a;
        }
        
        .hidden {
            display: none;
        }
        
        /* Export section */
        .export-section {
            margin-top: 24px;
            margin-bottom: 32px;
        }
        
        .export-textarea {
            width: 100%;
            height: 200px;
            padding: 8px;
            border: 1px solid #e2e8f0;
            border-radius: 4px;
            font-family: monospace;
            margin-bottom: 8px;
            display: none;
        }
        
        .helper-text {
            font-size: 12px;
            color: #718096;
            margin-top: 8px;
        }
        
        /* Storage warning */
        .storage-warning {
            background-color: #feebc8;
            border: 1px solid #f6ad55;
            color: #c05621;
            border-radius: 4px;
            padding: 8px 12px;
            margin-bottom: 16px;
            font-size: 14px;
            display: none;
        }
        
        /* Pull to refresh styles */
        .pull-to-refresh {
            height: 0;
            overflow: hidden;
            text-align: center;
            transition: height 0.3s;
            position: relative;
            margin-bottom: 8px;
        }
        
        .pull-to-refresh-icon {
            display: inline-block;
            margin-top: 10px;
            transition: transform 0.3s;
        }
        
        .pull-to-refresh.visible {
            height: 60px;
        }
        
        .pull-to-refresh.refreshing .pull-to-refresh-icon {
            animation: spin 1s linear infinite;
        }
        
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        
        /* Pulse animation for active timer */
        @keyframes pulse {
            0% { opacity: 1; }
            50% { opacity: 0.5; }
            100% { opacity: 1; }
        }
        
        .pulse {
            animation: pulse 1s infinite;
        }
        
        /* Dashboard section */
        .dashboard-section {
            margin-top: 24px;
            margin-bottom: 24px;
        }
        
        .dashboard {
            margin-top: 16px;
        }
        
        .dashboard.hidden {
            display: none;
        }
        
        /* Chart containers */
        .chart-container {
            overflow-x: auto;
            margin-bottom: 32px;
            background-color: #fcfcfc;
            border-radius: 6px;
            padding: 12px;
            border: 1px solid #f0f0f0;
        }
        
        .chart-title {
            font-size: 16px;
            font-weight: 500;
            color: #4a5568;
            margin-bottom: 12px;
            text-align: center;
        }
        
        .chart {
            height: 220px;
            width: 100%;
            position: relative;
        }

        /* Specific height for the stream chart container */
#streamChart {
    height: 350px;
}
        
        /* IMPROVED: Bar chart styling */
        .bar-chart {
            display: flex;
            align-items: flex-end;
            height: 150px;
            padding-bottom: 24px;
            position: relative;
            background: linear-gradient(135deg, #68d391, #4299e1);
        }
        
        .bar-container {
            flex: 1;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 0 4px;
            position: relative;
        }
        
        .bar {
            width: 80%;
            max-width: 32px;
            background: linear-gradient(to top, #4f9cf9, #a651e6);
            border-radius: 4px 4px 0 0;
            transition: height 0.3s;
            min-height: 2px;
        }
        
        .bar-label {
            font-size: 10px;
            color: #718096;
            margin-top: 6px;
            text-align: center;
            position: absolute;
            bottom: -24px;
            white-space: nowrap;
            transform: rotate(-45deg);
            transform-origin: top left;
            left: 50%;
        }
        
        .bar-value {
            font-size: 10px;
            color: #4a5568;
            position: absolute;
            top: -16px;
            left: 50%;
            transform: translateX(-50%);
            white-space: nowrap;
        }
        
        /* IMPROVED: Pie chart styling */
        .pie-chart {
            display: flex;
            align-items: center;
            justify-content: center;
            height: 150px;
            padding: 10px;
        }
        
        .pie-container {
            position: relative;
            width: 120px;
            height: 120px;
        }
        
        .pie-slice {
            position: absolute;
            width: 100%;
            height: 100%;
            border-radius: 50%;
            clip-path: polygon(50% 50%, 100% 0, 100% 100%);
            transform-origin: center;
        }
        
        .pie-legend {
            margin-left: 24px;
            display: flex;
            flex-direction: column;
        }
        
        .legend-item {
            display: flex;
            align-items: center;
            margin-bottom: 8px;
        }
        
        .legend-color {
            width: 12px;
            height: 12px;
            margin-right: 8px;
            border-radius: 2px;
        }
        
        .legend-label {
            font-size: 12px;
            color: #4a5568;
        }
        
        /* IMPROVED: Comparison chart styling */
        .comparison-chart {
            display: flex;
            height: 150px;
            align-items: flex-end;
            position: relative;
            padding-bottom: 32px;
        }
        
        .comparison-bar-group {
            flex: 1;
            display: flex;
            justify-content: center;
            gap: 4px;
            position: relative;
        }
        
        .comparison-bar {
            width: 20px;
            border-radius: 4px 4px 0 0;
            transition: height 0.3s;
            min-height: 2px;
            background: linear-gradient(135deg, #68d391, #4299e1);
        }
        
        .comparison-bar.primary {
            background-color: #4f9cf9;
        }
        
        .comparison-bar.secondary {
            background-color: #a651e6;
        }
        
        .comparison-label {
            position: absolute;
            bottom: -24px;
            font-size: 10px;
            color: #718096;
            transform: rotate(-45deg);
            transform-origin: top left;
            white-space: nowrap;
            left: 50%;
        }
        
        .comparison-bar-value {
            position: absolute;
            top: -16px;
            font-size: 10px;
            color: #4a5568;
            text-align: center;
            white-space: nowrap;
            left: 50%;
            transform: translateX(-50%);
        }
        
        .comparison-legend {
            display: flex;
            justify-content: center;
            margin-top: 16px;
        }
        
        .comparison-legend-item {
            display: flex;
            align-items: center;
            margin: 0 8px;
        }
        
        .comparison-legend-color {
            width: 12px;
            height: 12px;
            margin-right: 6px;
            border-radius: 2px;
        }
        
        /* Stats cards */
        .stats-container {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 12px;
            margin-bottom: 24px;
        }
        
        .stat-card {
            background-color: white;
            border-radius: 6px;
            padding: 12px;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.05);
            text-align: center;
        }
        
        .stat-value {
            font-size: 24px;
            font-weight: 600;
            color: #4f9cf9;
        }
        
        .stat-label {
            font-size: 12px;
            color: #718096;
            margin-top: 4px;
        }
        
        /* Empty state styling */
        .empty-chart {
            height: 150px;
            display: flex;
            align-items: center;
            justify-content: center;
            flex-direction: column;
            color: #a0aec0;
        }
        
        .empty-chart svg {
            width: 24px;
            height: 24px;
            margin-bottom: 8px;
            stroke: #cbd5e0;
        }
        
        .empty-chart-text {
            font-size: 14px;
        }

        /* IMPROVED: Canvas-based charts */
        .canvas-container {
            height: 100%;
            width: 100%;
            position: relative;
        }

        .helper-text {
    font-size: 12px;
    color: #718096;
    margin-top: 8px;
    display: none; /* Hidden by default */
}
.load-more-button {
    text-align: center;
    padding: 8px 0;
    color: #718096;
    font-size: 14px;
    cursor: pointer;
    background-color: #f8fafc;
    border-radius: 4px;
    margin-top: 8px;
}

.load-more-button:hover {
    background-color: #edf2f7;
}

.entry-actions {
    display: flex;
    gap: 12px;
    align-items: center;
    margin-left: auto; /* Push to right edge */
    height: 32px; /* Fixed height to match entry time row */
    overflow: hidden; /* Hide overflowing content when collapsed */
    transition: width 0.3s ease; /* Smooth width transition */
    width: 28px; /* Start with just enough width for the toggle button */
}

.entry-actions.expanded {
    width: 108px; /* Increased from 84px to properly fit all three buttons (28px each) plus gaps (12px each) */
}

.action-toggle {
    cursor: pointer;
    width: 28px;
    height: 28px;
    display: flex;
    align-items: center;
    justify-content: center;
    border-radius: 50%;
    transition: all 0.2s, transform 0.3s;
    background-color: #f7fafc;
    color: #718096;
    flex-shrink: 0; /* Don't allow this button to shrink */
}

.action-toggle:hover {
    background-color: #edf2f7;
}

.action-toggle.expanded {
    transform: rotate(180deg);
}

.edit-icon, .delete-icon {
    cursor: pointer;
    width: 28px; /* Increased from 20px */
    height: 28px; /* Increased from 20px */
    display: flex;
    align-items: center;
    justify-content: center;
    border-radius: 50%; /* Make circular */
    transition: all 0.2s, opacity 0.3s, transform 0.3s;
    opacity: 0;
    transform: translateX(10px);
    flex-shrink: 0; /* Don't allow these buttons to shrink */
}

.entry-actions.expanded .edit-icon,
.entry-actions.expanded .delete-icon {
    opacity: 1;
    transform: translateX(0);
}

.edit-icon {
    color: #718096;
    background-color: #edf2f7;
}

.edit-icon:hover {
    background-color: #e2e8f0;
    transform: scale(1.1);
}

.delete-icon {
    color: #e53e3e;
    background-color: #fff5f5;
}

.delete-icon:hover {
    background-color: #fed7d7;
    transform: scale(1.1);
}

.fab {
    position: fixed;
    bottom: 20px;
    right: 20px;
    width: 56px;
    height: 56px;
    background-color: #5a67d8;
    color: white;
    border-radius: 50%;
    box-shadow: 0 3px 6px rgba(0,0,0,0.16);
    font-size: 24px;
    border: none;
    cursor: pointer;
    z-index: 99999;
    transition: transform 0.3s;
}
.fab:hover {
    transform: scale(1.1);
}

/* Date separator styling */
.date-separator {
    margin-top: 16px;
    margin-bottom: 8px;
    font-size: 16px; /* Increased from 14px */
    font-weight: 600;
    color: #4a5568;
    border-bottom: 1px solid #e2e8f0;
    padding-bottom: 8px;
    background-color: #f7fafc; /* Light background to make date stand out */
    padding: 6px 10px;
    border-radius: 8px 8px 0 0;
    display: flex;
    align-items: center;
}

/* Set specific distance from date to first entry */
.date-separator + .entry-item {
    margin-top: 8px;
}


.date-separator::before {
    /*content: "📅"; /* Calendar emoji adds visual indicator */
    margin-right: 8px;
    font-size: 16px;
}

/* Icon styling */
.entry-icon {
    display: none;
}

/* Entry animation */
@keyframes entryAdded {
    0% { background-color: rgba(72,187,120,0.2); }
    100% { background-color: white; }
}

@keyframes entryDeleted {
    0% { background-color: rgba(229,62,62,0.2); opacity: 1; }
    100% { opacity: 0; transform: translateX(-50px); }
}

.entry-added {
    animation: entryAdded 1s ease;
}

.entry-deleted {
    animation: entryDeleted 0.5s ease forwards;
}

/* Motivational section styles */
.motivational-section {
    margin-bottom: 16px;
    background: linear-gradient(135deg, #f6f8fa, #edf2f7);
    border-left: 4px solid #5a67d8;
    overflow: hidden;
}

.motivational-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 12px 16px;
    border-bottom: 1px solid rgba(203, 213, 224, 0.5);
}

.motivational-title {
    font-size: 16px;
    font-weight: 600;
    margin: 0;
    color: #4a5568;
}

.insight-refresh-btn {
    background: none;
    border: none;
    cursor: pointer;
    color: #718096;
    display: flex;
    align-items: center;
    justify-content: center;
    width: 28px;
    height: 28px;
    border-radius: 50%;
    transition: all 0.2s;
}

.insight-refresh-btn:hover {
    background-color: rgba(203, 213, 224, 0.4);
    color: #4a5568;
}

.insight-refresh-btn svg {
    transition: transform 0.5s ease;
}

.insight-refresh-btn:active svg {
    transform: rotate(360deg);
}

.motivational-content {
    padding: 16px;
    font-size: 15px;
    line-height: 1.6;
    color: #2d3748;
    position: relative;
    min-height: 80px;
}

.motivational-content p {
    margin: 0;
}

.motivational-footer {
    padding: 8px 16px;
    border-top: 1px solid rgba(203, 213, 224, 0.5);
}

.toggle-ai-settings {
    background: none;
    border: none;
    color: #718096;
    font-size: 13px;
    cursor: pointer;
    padding: 4px 0;
}

.toggle-ai-settings:hover {
    color: #4a5568;
    text-decoration: underline;
}

.ai-settings-panel {
    padding-top: 12px;
    transition: all 0.3s;
}

.ai-settings-panel.hidden {
    max-height: 0;
    padding: 0;
    overflow: hidden;
    opacity: 0;
}

.ai-settings-helper {
    display: block;
    font-size: 12px;
    color: #718096;
    margin-top: 4px;
}

.insight-loading {
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    position: absolute;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    background: rgba(255, 255, 255, 0.8);
    z-index: 10;
}

.insight-loading p {
    margin-top: 8px;
    color: #4a5568;
}

.insight-loading-spinner {
    width: 30px;
    height: 30px;
    border: 3px solid #e2e8f0;
    border-top-color: #5a67d8;
    border-radius: 50%;
    animation: spin 1s linear infinite;
}

@keyframes fadeIn {
    from { opacity: 0; }
    to { opacity: 1; }
}

.insight-highlight {
    font-weight: 600;
    color: #5a67d8;
}

.insight-warning {
    font-weight: 600;
    color: #e53e3e;
}

.insight-success {
    font-weight: 600;
    color: #38a169;
}

/* Magical insight transition styles */
@keyframes subtlePulse {
    0% { opacity: 1; }
    50% { opacity: 0.7; }
    100% { opacity: 1; }
}

@keyframes gentleFadeIn {
    0% { opacity: 0; transform: translateY(5px); }
    100% { opacity: 1; transform: translateY(0); }
}

@keyframes subtleGlow {
    0% { box-shadow: 0 0 0 rgba(90, 103, 216, 0); }
    50% { box-shadow: 0 0 10px rgba(90, 103, 216, 0.2); }
    100% { box-shadow: 0 0 0 rgba(90, 103, 216, 0); }
}

.insight-refreshing {
    animation: subtlePulse 1.5s infinite ease-in-out;
}

.insight-glow {
    animation: subtleGlow 2s ease-in-out;
}

.insight-appear {
    animation: gentleFadeIn 0.8s ease-out forwards;
}

/* Magical gradient background for new insights */
.insight-new {
    background: linear-gradient(to right, rgba(247, 250, 252, 0.5), rgba(237, 242, 247, 0.8), rgba(247, 250, 252, 0.5));
    background-size: 200% 100%;
    animation: gradientShift 3s ease forwards;
}

@keyframes gradientShift {
    0% { background-position: 100% 0; }
    100% { background-position: 0 0; }
}
/* Streaming text and improved UI styles */
@keyframes subtlePulse {
    0% { opacity: 1; }
    50% { opacity: 0.7; }
    100% { opacity: 1; }
}

@keyframes gentleFadeIn {
    0% { opacity: 0; transform: translateY(5px); }
    100% { opacity: 1; transform: translateY(0); }
}

@keyframes subtleGlow {
    0% { box-shadow: 0 0 0 rgba(90, 103, 216, 0); }
    50% { box-shadow: 0 0 10px rgba(90, 103, 216, 0.2); }
    100% { box-shadow: 0 0 0 rgba(90, 103, 216, 0); }
}

@keyframes cursorBlink {
    0%, 100% { opacity: 1; }
    50% { opacity: 0; }
}

.streaming-cursor {
    display: inline-block;
    width: 2px;
    height: 16px;
    background-color: #5a67d8;
    vertical-align: middle;
    margin-left: 1px;
    animation: cursorBlink 0.8s infinite;
}

.insight-refreshing {
    animation: subtlePulse 1.5s infinite ease-in-out;
}

.insight-glow {
    animation: subtleGlow 2s ease-in-out;
}

.insight-appear {
    animation: gentleFadeIn 0.8s ease-out forwards;
}

/* AI controls dropdown styling */
.ai-controls {
    position: relative;
    display: inline-block;
}

.ai-controls-toggle {
    cursor: pointer;
    width: 28px;
    height: 28px;
    display: flex;
    align-items: center;
    justify-content: center;
    border-radius: 50%;
    transition: all 0.2s, transform 0.3s;
    background-color: #f7fafc;
    color: #718096;
}

.ai-controls-toggle:hover {
    background-color: #edf2f7;
}

.ai-controls-toggle.expanded {
    transform: rotate(180deg);
}



.ai-controls-menu.expanded {
    opacity: 1;
    transform: translateY(0);
    pointer-events: all;
}

.ai-controls-item {
    display: flex;
    align-items: center;
    padding: 8px 12px;
    border-radius: 6px;
    cursor: pointer;
    color: #4a5568;
    font-size: 14px;
    transition: background-color 0.2s;
}

.ai-controls-item:hover {
    background-color: #f7fafc;
}

.ai-controls-item svg {
    margin-right: 8px;
    width: 16px;
    height: 16px;
}

.motivational-header {
    position: relative;
}

/* Subtle fade-in animation styles */
@keyframes subtlePulse {
    0% { opacity: 1; }
    50% { opacity: 0.7; }
    100% { opacity: 1; }
}

@keyframes subtleGlow {
    0% { box-shadow: 0 0 0 rgba(90, 103, 216, 0); }
    50% { box-shadow: 0 0 10px rgba(90, 103, 216, 0.2); }
    100% { box-shadow: 0 0 0 rgba(90, 103, 216, 0); }
}

@keyframes wordFadeIn {
    0% { opacity: 0; transform: translateY(3px); }
    100% { opacity: 1; transform: translateY(0); }
}

.insight-refreshing {
    animation: subtlePulse 1.5s infinite ease-in-out;
}

.insight-glow {
    animation: subtleGlow 2s ease-in-out;
}

.fade-in-word {
    opacity: 0;
    display: inline-block;
    animation: wordFadeIn 0.6s ease-out forwards;
}

#insightMessage {
    word-wrap: break-word;
    white-space: normal;
    line-height: 1.6;
}

/* AI controls dropdown styling */
.ai-controls {
    position: relative;
    display: inline-block;
}

.ai-controls-toggle {
    cursor: pointer;
    width: 28px;
    height: 28px;
    display: flex;
    align-items: center;
    justify-content: center;
    border-radius: 50%;
    transition: all 0.2s, transform 0.3s;
    background-color: #f7fafc;
    color: #718096;
}

.ai-controls-toggle:hover {
    background-color: #edf2f7;
}

.ai-controls-toggle.expanded {
    transform: rotate(180deg);
}





.ai-controls-item {
    display: flex;
    align-items: center;
    padding: 8px 12px;
    border-radius: 6px;
    cursor: pointer;
    color: #4a5568;
    font-size: 14px;
    transition: background-color 0.2s;
}

.ai-controls-item:hover {
    background-color: #f7fafc;
}

.ai-controls-item svg {
    margin-right: 8px;
    width: 16px;
    height: 16px;
}

.motivational-header {
    position: relative;
}




/* AI controls dropdown styling */
.ai-controls {
    position: relative;
    display: inline-block;
}

.ai-controls-toggle {
    cursor: pointer;
    width: 28px;
    height: 28px;
    display: flex;
    align-items: center;
    justify-content: center;
    border-radius: 50%;
    transition: all 0.2s, transform 0.3s;
    background-color: #f7fafc;
    color: #718096;
}

.ai-controls-toggle:hover {
    background-color: #edf2f7;
}

.ai-controls-toggle.expanded {
    transform: rotate(180deg);
}

.ai-controls-menu {
    position: absolute;
    top: 36px;
    z-index: 20;
    right: 0;
    background-color: white;
    border-radius: 8px;
    box-shadow: 0 2px 10px rgba(0,0,0,0.1);
    padding: 8px;
    width: 180px;
    z-index: 10;
    opacity: 0;
    transform: translateY(-10px);
    pointer-events: none;
    transition: all 0.2s ease;
}


.ai-controls-item {
    display: flex;
    align-items: center;
    padding: 8px 12px;
    border-radius: 6px;
    cursor: pointer;
    color: #4a5568;
    font-size: 14px;
    transition: background-color 0.2s;
}

.ai-controls-item:hover {
    background-color: #f7fafc;
}

.ai-controls-item svg {
    margin-right: 8px;
    width: 16px;
    height: 16px;
}

#motivationalContent {
    overflow: hidden; /* Prevents content overflow during animation */
    transition: height 0.3s ease; /* Animates height changes over 0.3 seconds */
}

    </style>
</head>
<body>
    <div class="pull-to-refresh" id="pullToRefresh">
        <div class="pull-to-refresh-icon">
            <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                <path d="M23 4v6h-6"></path>
                <path d="M20.49 15a9 9 0 1 1-2.12-9.36L23 10"></path>
            </svg>
        </div>
    </div>
    
    <div class="container">
        <header>
            <div class="app-logo">
                <div class="app-logo-inner">
                    <div class="app-logo-core"></div>
                </div>
            </div>
            <h1>Bladder Diary</h1>
            <p class="subtitle">Track your bladder health</p>
        </header>
        
        <div class="privacy-notice">
            <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                <rect x="3" y="11" width="18" height="11" rx="2" ry="2"></rect>
                <path d="M7 11V7a5 5 0 0 1 10 0v4"></path>
            </svg>
            Your data is stored privately and securely on your device only
        </div>
        
        <div id="storageWarning" class="storage-warning">
            Storage is not working properly. Your entries won't be saved between sessions.
        </div>
        
        <!-- New motivational section with chevron dropdown -->
<div id="motivationalSection" class="card motivational-section">
    <div class="motivational-header">
        <h3 class="motivational-title">Daily Insight</h3>
        <div class="ai-controls">
            <div id="aiControlsToggle" class="ai-controls-toggle" title="AI Controls">
                <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                    <polyline points="15 18 9 12 15 6"></polyline>
                </svg>
            </div>
            <div id="aiControlsMenu" class="ai-controls-menu">
                <div id="refreshInsightBtn" class="ai-controls-item" title="Refresh insight">
                    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                        <path d="M23 4v6h-6"></path>
                        <path d="M20.49 15a9 9 0 1 1-2.12-9.36L23 10"></path>
                    </svg>
                    <span>Refresh Insight</span>
                </div>
                <div id="toggleAiSettings" class="ai-controls-item">
                    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                        <circle cx="12" cy="12" r="3"></circle>
                        <path d="M19.4 15a1.65 1.65 0 0 0 .33 1.82l.06.06a2 2 0 0 1 0 2.83 2 2 0 0 1-2.83 0l-.06-.06a1.65 1.65 0 0 0-1.82-.33 1.65 1.65 0 0 0-1 1.51V21a2 2 0 0 1-2 2 2 2 0 0 1-2-2v-.09A1.65 1.65 0 0 0 9 19.4a1.65 1.65 0 0 0-1.82.33l-.06.06a2 2 0 0 1-2.83 0 2 2 0 0 1 0-2.83l.06-.06a1.65 1.65 0 0 0 .33-1.82 1.65 1.65 0 0 0-1.51-1H3a2 2 0 0 1-2-2 2 2 0 0 1 2-2h.09A1.65 1.65 0 0 0 4.6 9a1.65 1.65 0 0 0-.33-1.82l-.06-.06a2 2 0 0 1 0-2.83 2 2 0 0 1 2.83 0l.06.06a1.65 1.65 0 0 0 1.82.33H9a1.65 1.65 0 0 0 1-1.51V3a2 2 0 0 1 2-2 2 2 0 0 1 2 2v.09a1.65 1.65 0 0 0 1 1.51 1.65 1.65 0 0 0 1.82-.33l.06-.06a2 2 0 0 1 2.83 0 2 2 0 0 1 0 2.83l-.06.06a1.65 1.65 0 0 0-.33 1.82V9a1.65 1.65 0 0 0 1.51 1H21a2 2 0 0 1 2 2 2 2 0 0 1-2 2h-.09a1.65 1.65 0 0 0-1.51 1z"></path>
                    </svg>
                    <span>AI Settings</span>
                </div>
            </div>
        </div>
    </div>
    <div id="motivationalContent" class="motivational-content">
        <div id="loadingMessage" class="insight-loading hidden">
            <div class="insight-loading-spinner"></div>
            <p>Generating insight...</p>
        </div>
        <p id="insightMessage">Welcome to your Bladder Diary. Track your entries to receive personalized insights.</p>
    </div>
    <div class="motivational-footer">
        <div id="aiSettingsPanel" class="ai-settings-panel hidden">
            <div class="form-group">
                <label class="form-label" for="openaiKey">OpenAI API Key (stored locally only)</label>
                <input type="password" id="openaiKey" class="form-control" placeholder="sk-...">
                <small class="ai-settings-helper">Your key is stored securely in your browser only.</small>
            </div>
            <div class="form-check">
                <input type="checkbox" id="useOpenAI" class="form-check-input">
                <label class="form-check-label" for="useOpenAI">Use AI-generated insights</label>
            </div>
            <button id="saveAiSettings" class="btn btn-secondary">Save Settings</button>
        </div>
    </div>
</div>
        
        <button id="toggleFormBtn" class="btn btn-primary">
            Add New Entry
        </button>

        <button class="fab" id="fabAddEntry">+</button>

        <div id="messageArea" class="message hidden"></div>
        
        <form id="entryForm" class="form hidden">
            <div class="form-group grid">
                <div>
                    <label class="form-label" for="date">Date</label>
                    <input class="form-control" type="date" id="date" name="date" required>
                </div>
                <div>
                    <label class="form-label" for="time">Time</label>
                    <input class="form-control" type="time" id="time" name="time" required>
                </div>
            </div>
            
            <h3 class="section-header">Drink</h3>
            <div class="form-group grid">
                <div>
                    <label class="form-label" for="drinkType">Type</label>
                    <select class="form-control" id="drinkType" name="drinkType">
                        <option value="">Select type</option>
                        <option value="Water">Water</option>
                        <option value="Coffee">Coffee</option>
                        <option value="Tea">Tea</option>
                        <option value="Juice">Juice</option>
                        <option value="Soda">Soda</option>
                        <option value="Alcohol">Alcohol</option>
                        <option value="Other">Other</option>
                    </select>
                </div>
                <div>
                    <label class="form-label" for="drinkAmount">Amount (ml)</label>
                    <input class="form-control" type="number" id="drinkAmount" name="drinkAmount" placeholder="ml">
                </div>
            </div>
            
            <h3 class="section-header">Urine</h3>
            <div class="form-group grid">
                <div>
                    <label class="form-label" for="urineVolume">Duration (seconds)</label>
                    <div class="timer-field-container">
                        <input class="form-control" type="number" id="urineVolume" name="urineVolume" placeholder="seconds">
                        <button type="button" id="timerBtn" class="timer-btn">
                            <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                <circle cx="12" cy="12" r="10"></circle>
                                <polyline points="12 6 12 12 16 14"></polyline>
                            </svg>
                            Start
                        </button>
                    </div>
                    <div id="timerIndicator" class="timer-indicator hidden">0s</div>
                </div>
                <div>
                    <label class="form-label" for="urgency">Urgency (0-3)</label>
                    <select class="form-control" id="urgency" name="urgency">
                        <option value="">Select level</option>
                        <option value="0">0 (None)</option>
                        <option value="1">1 (Mild)</option>
                        <option value="2">2 (Moderate)</option>
                        <option value="3">3 (Severe)</option>
                    </select>
                </div>
            </div>
            
            <h3 class="section-header">Urine Flow</h3>
            <div class="form-group">
                <label class="form-label" for="urineStream">Urine Stream</label>
                <select class="form-control" id="urineStream" name="urineStream">
                    <option value="">Select type</option>
                    <option value="Strong">Strong</option>
                    <option value="Intermittent">Intermittent</option>
                    <option value="Weak">Weak</option>
                </select>
            </div>
            
            <button type="submit" class="btn btn-success">Save Entry</button>
        </form>
        
        <div class="card">
            <div class="card-header">
                <h2 class="card-title">Recent Entries</h2>
            </div>
            <div id="entriesList" class="card-body">
                <p id="noEntriesMsg" class="no-entries">No entries yet. Add your first one!</p>
            </div>
        </div>

        <!-- Dashboard section -->
        <div class="dashboard-section">
            <button id="toggleDashboardBtn" class="btn btn-secondary">Show Dashboard</button>
            
            <div id="dashboard" class="dashboard hidden">
                <div class="card">
                    <div class="card-header">
                        <h2 class="card-title">Your Progress Dashboard</h2>
                    </div>
                    <div class="card-body">
                        <div id="noDataMsg" class="no-entries">No data available yet. Add entries to see your dashboard.</div>
                        
                        <div id="dashboardCharts" class="hidden">
                            <!-- Frequency chart -->
                            <div class="chart-container">
                                <h3 class="chart-title">Daily Urination Frequency</h3>
                                <div class="chart" id="frequencyChart">
                                    <canvas id="frequencyCanvas" class="canvas-container"></canvas>
                                </div>
                            </div>
                            
                            <!-- Urgency levels chart -->
                            <div class="chart-container">
                                <h3 class="chart-title">Urgency Levels</h3>
                                <div class="chart" id="urgencyChart">
                                    <canvas id="urgencyCanvas" class="canvas-container"></canvas>
                                </div>
                            </div>

                            <!-- Average Time Between Urinations chart -->
                            <div class="chart-container">
                                <h3 class="chart-title">Average Time Between Urinations</h3>
                                <div class="chart" id="timeGapChart">
                                    <canvas id="timeGapCanvas" class="canvas-container"></canvas>
                                </div>
                            </div>
                            
                            <!-- Fluid intake vs urination -->
                            <div class="chart-container">
                                <h3 class="chart-title">Fluid Intake vs Urination</h3>
                                <div class="chart" id="correlationChart">
                                    <canvas id="correlationCanvas" class="canvas-container"></canvas>
                                </div>
                            </div>
                            
                            <!-- Stream strength distribution -->
                            <div class="chart-container">
                                <h3 class="chart-title">Urine Stream Strength</h3>
                                <div class="chart" id="streamChart">
                                    <canvas id="streamCanvas" class="canvas-container"></canvas>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <div class="export-section">
            <button id="toggleExportBtn" class="btn btn-secondary">Show Export Data</button>
            <textarea id="exportArea" class="export-textarea"></textarea>
            <p class="helper-text">Text is automatically selected for copying</p>
        </div>
    </div>

    <script>
        // DOM elements
        const toggleFormBtn = document.getElementById('toggleFormBtn');
        const fabAddEntry = document.getElementById('fabAddEntry');
        const entryForm = document.getElementById('entryForm');
        const entriesList = document.getElementById('entriesList');
        const noEntriesMsg = document.getElementById('noEntriesMsg');
        const toggleExportBtn = document.getElementById('toggleExportBtn');
        const exportArea = document.getElementById('exportArea');
        const messageArea = document.getElementById('messageArea');
        const storageWarning = document.getElementById('storageWarning');
        const pullToRefresh = document.getElementById('pullToRefresh');
        const timerBtn = document.getElementById('timerBtn');
        const timerIndicator = document.getElementById('timerIndicator');
        const urineVolumeInput = document.getElementById('urineVolume');
        const toggleDashboardBtn = document.getElementById('toggleDashboardBtn');
        const dashboard = document.getElementById('dashboard');
        const noDataMsg = document.getElementById('noDataMsg');
        const dashboardCharts = document.getElementById('dashboardCharts');
        
        
        // Timer variables
        let timerActive = false;
        let timerStart = 0;
        let timerInterval = null;
        
        // Pull-to-refresh variables
        let touchStartY = 0;
        let touchEndY = 0;
        let isRefreshing = false;
        
        // Check if localStorage is available
        let localStorageAvailable = false;
        try {
            localStorage.setItem("test", "test");
            localStorage.removeItem("test");
            localStorageAvailable = true;
            storageWarning.style.display = 'none';
        } catch (e) {
            console.error("localStorage not available:", e);
            storageWarning.style.display = 'block';
            localStorageAvailable = false;
        }
        
        // In-memory storage (backup if localStorage fails)
        let entries = [];
        
        fabAddEntry.addEventListener('click', function() {
            // Simulate clicking the original toggle form button
            toggleFormBtn.click();

            // Optional smooth scroll to the form when it opens
            if (entryForm.style.display !== 'none') {
                entryForm.scrollIntoView({ behavior: 'smooth' });
            }
        });

        // Timer functionality
        timerBtn.addEventListener('click', function() {
            if (!timerActive) {
                // Start timer
                timerActive = true;
                timerStart = Date.now();
                timerBtn.textContent = 'Stop';
                timerBtn.classList.add('active');
                timerIndicator.classList.remove('hidden');
                timerIndicator.classList.add('pulse');
                
                // Update timer display
                timerInterval = setInterval(function() {
                    const elapsedSeconds = Math.floor((Date.now() - timerStart) / 1000);
                    timerIndicator.textContent = elapsedSeconds + 's';
                }, 1000);
            } else {
                // Stop timer
                timerActive = false;
                clearInterval(timerInterval);
                const elapsedSeconds = Math.floor((Date.now() - timerStart) / 1000);
                
                // Set value to input field
                urineVolumeInput.value = elapsedSeconds;
                
                // Reset timer UI
                timerBtn.textContent = 'Start';
                timerBtn.classList.remove('active');
                timerIndicator.classList.add('hidden');
                timerIndicator.classList.remove('pulse');
            }
        });
        
// Enhanced loading with backup recovery
function loadEntries() {
    try {
        if (localStorageAvailable) {
            let loadedEntries = null;
            
            // Try to load from primary storage
            const stored = localStorage.getItem('bladderDiaryEntries');
            if (stored) {
                try {
                    loadedEntries = JSON.parse(stored);
                    console.log("Loaded entries from primary storage:", loadedEntries.length);
                } catch (parseError) {
                    console.error("Error parsing primary storage:", parseError);
                }
            }
            
            // If primary storage failed, try backup
            if (!loadedEntries || loadedEntries.length === 0) {
                const backup = localStorage.getItem('bladderDiaryEntries_backup');
                if (backup) {
                    try {
                        const backupEntries = JSON.parse(backup);
                        if (backupEntries && backupEntries.length > 0) {
                            loadedEntries = backupEntries;
                            console.log("Recovered entries from backup storage:", loadedEntries.length);
                            showMessage("Data recovered from backup", "success");
                        }
                    } catch (parseError) {
                        console.error("Error parsing backup storage:", parseError);
                    }
                }
            }
            
            // Update entries if we loaded something
            if (loadedEntries && loadedEntries.length > 0) {
                entries = loadedEntries;
            }
        }
        renderEntries();
    } catch (e) {
        console.error("Error loading entries:", e);
        showMessage("Error loading saved entries", "danger");
    }
}
        
// Create a backup when saving entries
function saveEntries() {
    try {
        if (localStorageAvailable) {
            // Save to primary storage
            localStorage.setItem('bladderDiaryEntries', JSON.stringify(entries));
            
            // Create backup every time we save
            localStorage.setItem('bladderDiaryEntries_backup', JSON.stringify(entries));
            
            // Save a timestamp of the last save
            localStorage.setItem('bladderDiaryLastSave', new Date().toISOString());
        }
    } catch (e) {
        console.error("Error saving entries:", e);
        showMessage("Error saving entries", "danger");
    }
}
        
        // Helper function to show a message
        function showMessage(message, type = 'danger') {
            messageArea.textContent = message;
            messageArea.className = `message message-${type}`;
            messageArea.style.display = 'block';
            setTimeout(function() {
                messageArea.style.display = 'none';
            }, 3000);
        }
        
        // Set current date and time
        function setCurrentDateTime() {
            try {
                const now = new Date();
                const dateInput = document.getElementById('date');
                const timeInput = document.getElementById('time');
                
                // Format date as YYYY-MM-DD
                const year = now.getFullYear();
                const month = String(now.getMonth() + 1).padStart(2, '0');
                const day = String(now.getDate()).padStart(2, '0');
                dateInput.value = `${year}-${month}-${day}`;
                
                // Format time as HH:MM
                const hours = String(now.getHours()).padStart(2, '0');
                const minutes = String(now.getMinutes()).padStart(2, '0');
                timeInput.value = `${hours}:${minutes}`;
            } catch (error) {
                console.error('Error setting date/time', error);
            }
        }
        
        // Toggle form visibility
        toggleFormBtn.addEventListener('click', function() {
            try {
                if (entryForm.style.display === 'none' || entryForm.style.display === '') {
                    entryForm.style.display = 'block';
                    toggleFormBtn.textContent = 'Cancel';
                    setCurrentDateTime();
                } else {
                    // Make sure timer is stopped if form is closed
                    if (timerActive) {
                        timerActive = false;
                        clearInterval(timerInterval);
                        timerBtn.textContent = 'Start';
                        timerBtn.classList.remove('active');
                        timerIndicator.classList.add('hidden');
                        timerIndicator.classList.remove('pulse');
                    }
                    
                    entryForm.style.display = 'none';
                    toggleFormBtn.textContent = 'Add New Entry';
                    entryForm.reset();
                }
            } catch (error) {
                console.error('Error toggling form', error);
                showMessage('Error showing form');
            }
        });
        
        // Format date for display - FIXED to handle timezone issues
        function formatDate(dateString) {
            try {
                // Parse the date parts directly from the string to avoid timezone issues
                const [year, month, day] = dateString.split('-').map(num => parseInt(num, 10));
                
                // Month names for display
                const months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];
                
                // JavaScript months are 0-based, so subtract 1 from the month
                return `${months[month-1]} ${day}`;
            } catch (error) {
                console.error('Error formatting date', error);
                return dateString;
            }
        }
        
       // Replace the delete function with these two functions
function confirmDeleteEntryAtIndex(index) {
    try {
        if (confirm('Are you sure you want to delete this entry?')) {
            deleteEntryAtIndex(index);
        }
    } catch (error) {
        console.error('Error confirming delete', error);
        showMessage('Error deleting entry');
    }
}

function deleteEntryAtIndex(index) {
    try {
        entries.splice(index, 1);
        saveEntries();
        renderEntries();
        
        // Update dashboard if it's visible
        if (!dashboard.classList.contains('hidden')) {
            renderDashboard();
        }
        
        showMessage('Entry deleted', 'success');
    } catch (error) {
        console.error('Error deleting entry', error);
        showMessage('Error deleting entry');
    }
}
        
        // Make the delete function globally available
        window.deleteEntryAtIndex = deleteEntryAtIndex;
        
        // Function to toggle entry action buttons
        function toggleEntryActions(toggleButton) {
            try {
                // Get the parent entry-actions container
                const actionsContainer = toggleButton.parentElement;
                
                // Toggle the expanded state
                const isExpanded = actionsContainer.classList.toggle('expanded');
                
                // Toggle the button rotation
                toggleButton.classList.toggle('expanded', isExpanded);
                
                // Update accessibility title
                toggleButton.title = isExpanded ? "Hide actions" : "Show actions";
            } catch (error) {
                console.error('Error toggling entry actions', error);
            }
        }
        
        // Make the function globally available
        window.toggleEntryActions = toggleEntryActions;
        
        // Render entries list
        function renderEntries(showAll = false) {
    try {
        entriesList.innerHTML = ''; // Clear current list

        if (entries.length === 0) {
            noEntriesMsg.style.display = 'block';
            return;
        }

        noEntriesMsg.style.display = 'none';

        // Sort entries
        entries.sort((a, b) => (a.date + a.time < b.date + b.time ? 1 : -1));

        const displayLimit = showAll ? entries.length : 12;
        const displayEntries = entries.slice(0, displayLimit);

        let lastDate = '';

        displayEntries.forEach((entry, index) => {
            if (entry.date !== lastDate) {
                const dateSeparator = document.createElement('div');
                dateSeparator.className = 'date-separator';
                
                // Get correct day of week
                const dayOfWeek = getDayOfWeek(entry.date);
                
                dateSeparator.textContent = `${formatDate(entry.date)} (${dayOfWeek})`;
                entriesList.appendChild(dateSeparator);
                lastDate = entry.date;
            }

            const entryEl = document.createElement('div');
            entryEl.className = 'entry-item';

            // Determine icon class based on entry type
            let iconClass = '';
            if (entry.drinkType) {
                iconClass = 'drink-icon';
            } else if (entry.urineVolume) {
                iconClass = 'urine-icon';
            }
            
            // Determine urgency class if applicable
            let urgencyClass = '';
            if (entry.urgency) {
                urgencyClass = `urgency-${entry.urgency}`;
            }
            
            // Get urgency text instead of number
            const urgencyText = getUrgencyText(entry.urgency);
            
            // Determine stream class if applicable
            let streamClass = '';
            if (entry.urineStream) {
                streamClass = `stream-${entry.urineStream.toLowerCase()}`;
            }

            entryEl.innerHTML = `
                <div class="entry-header">
                    <div class="entry-date">
                        <span class="entry-icon ${iconClass}"></span>
                        <span class="entry-time">${formatTime(entry.time)}</span>
                    </div>
                    <div class="entry-actions">
                        <div class="action-toggle" title="Show actions" onclick="toggleEntryActions(this)">
                            <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                <polyline points="15 18 9 12 15 6"></polyline>
                            </svg>
                        </div>
                        <div class="edit-icon" title="Edit" onclick="editEntryAtIndex(${entries.indexOf(entry)})">
                            <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                <path d="M17 3a2.828 2.828 0 1 1 4 4L7.5 20.5 2 22l1.5-5.5L17 3z"></path>
                            </svg>
                        </div>
                        <div class="delete-icon" title="Delete" onclick="confirmDeleteEntryAtIndex(${entries.indexOf(entry)})">
                            <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                <line x1="18" y1="6" x2="6" y2="18"></line>
                                <line x1="6" y1="6" x2="18" y2="18"></line>
                            </svg>
                        </div>
                    </div>
                </div>
                <div class="entry-details">
                    ${entry.drinkType ? `<div class="entry-label">Drink:</div><div>${entry.drinkType} (${entry.drinkAmount || 0} ml)</div>` : ''}
                    ${entry.urineVolume ? `<div class="entry-label">Urine:</div><div>${entry.urineVolume} sec&nbsp;<span class="${urgencyClass}">(Urgency: ${urgencyText})</span></div>` : ''}
                    ${entry.urineStream ? `<div class="entry-label">Urine Flow:</div><div class="${streamClass}">${entry.urineStream}</div>` : ''}
                </div>
            `;

            entriesList.appendChild(entryEl);
        });

        if (!showAll && entries.length > displayLimit) {
            const loadMoreButton = document.createElement('div');
            loadMoreButton.className = 'load-more-button';
            loadMoreButton.textContent = 'Load more...';
            loadMoreButton.onclick = () => renderEntries(true);
            entriesList.appendChild(loadMoreButton);
        }
    } catch (error) {
        console.error('Error rendering entries', error);
        showMessage('Error displaying entries');
    }
}

function formatTime(timeString) {
    try {
        // Check if the time is in 24-hour format
        if (timeString.includes(':')) {
            const [hours, minutes] = timeString.split(':');
            
            // Convert to 12-hour format with AM/PM
            let hour = parseInt(hours, 10);
            const ampm = hour >= 12 ? 'PM' : 'AM';
            hour = hour % 12;
            hour = hour ? hour : 12; // the hour '0' should be '12'
            
            return `${hour}:${minutes} ${ampm}`;
        }
        return timeString;
    } catch (error) {
        console.error('Error formatting time', error);
        return timeString;
    }
}

function getDayOfWeek(dateString) {
    try {
        const [year, month, day] = dateString.split('-').map(num => parseInt(num, 10));
        
        // Create date object - months are 0-based in JavaScript 
        const date = new Date(year, month - 1, day);
        
        // Get day of week
        const dayNames = ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'];
        return dayNames[date.getDay()];
    } catch (error) {
        console.error('Error getting day of week', error);
        return '';
    }
}

function getUrgencyText(urgencyLevel) {
    const urgencyMap = {
        '0': 'None',
        '1': 'Mild',
        '2': 'Moderate',
        '3': 'Severe'
    };
    
    return urgencyMap[urgencyLevel] || 'N/A';
}

// Add this new function for editing entries
function editEntryAtIndex(index) {
    try {
        const entry = entries[index];
        
        // Fill the form with the entry data
        document.getElementById('date').value = entry.date;
        document.getElementById('time').value = entry.time;
        document.getElementById('drinkType').value = entry.drinkType || '';
        document.getElementById('drinkAmount').value = entry.drinkAmount || '';
        document.getElementById('urineVolume').value = entry.urineVolume || '';
        document.getElementById('urgency').value = entry.urgency || '';
        document.getElementById('urineStream').value = entry.urineStream || '';
        
        // Show the form
        entryForm.style.display = 'block';
        toggleFormBtn.textContent = 'Cancel';
        
        // Store the index of the entry being edited
        entryForm.dataset.editIndex = index;
        
        // Change the submit button text
        const submitBtn = entryForm.querySelector('button[type="submit"]');
        submitBtn.textContent = 'Update Entry';
        
        // Scroll to the form
        entryForm.scrollIntoView({ behavior: 'smooth' });
    } catch (error) {
        console.error('Error editing entry', error);
        showMessage('Error editing entry');
    }
}

        // Add this to the export section to enable downloading a JSON backup file
function addBackupButtons() {
    const exportSection = document.querySelector('.export-section');
    
    // Create button container with better spacing
    const buttonContainer = document.createElement('div');
    buttonContainer.style.display = 'flex';
    buttonContainer.style.gap = '8px';
    buttonContainer.style.marginBottom = '16px';
    buttonContainer.style.marginTop = '8px';
    
    // Create download backup button with muted styling
    const downloadButton = document.createElement('button');
    downloadButton.className = 'btn-secondary';
    downloadButton.textContent = 'Download JSON Backup';
    
    // Apply muted styling
    downloadButton.style.backgroundColor = '#a0aec0'; // Grey color
    downloadButton.style.flex = '1'; // Take equal space
    downloadButton.style.padding = '8px 16px';
    downloadButton.style.fontSize = '14px';
    downloadButton.style.color = 'white';
    downloadButton.style.borderRadius = '4px';
    downloadButton.style.border = 'none';
    downloadButton.style.cursor = 'pointer';
    
    // Add click handler for download
    downloadButton.addEventListener('click', function() {
        try {
            if (entries.length === 0) {
                showMessage('No entries to export');
                return;
            }
            
            // Create JSON data
            const jsonData = JSON.stringify(entries, null, 2);
            
            // Create blob and download link
            const blob = new Blob([jsonData], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            
            // Create and trigger download
            const a = document.createElement('a');
            a.href = url;
            a.download = 'bladder_diary_backup.json';
            document.body.appendChild(a);
            a.click();
            
            // Clean up
            setTimeout(function() {
                document.body.removeChild(a);
                window.URL.revokeObjectURL(url);
            }, 0);
            
            showMessage('Backup downloaded successfully!', 'success');
        } catch (error) {
            console.error('Error creating backup:', error);
            showMessage('Error creating backup');
        }
    });
    
    // Create import backup button with matching muted styling
    const importButton = document.createElement('button');
    importButton.className = 'btn-secondary';
    importButton.textContent = 'Import JSON Backup';
    
    // Apply matching muted styling
    importButton.style.backgroundColor = '#a0aec0'; // Same grey color
    importButton.style.flex = '1'; // Take equal space
    importButton.style.padding = '8px 16px';
    importButton.style.fontSize = '14px';
    importButton.style.color = 'white';
    importButton.style.borderRadius = '4px';
    importButton.style.border = 'none';
    importButton.style.cursor = 'pointer';
    
    // Create hidden file input for import
    const fileInput = document.createElement('input');
    fileInput.type = 'file';
    fileInput.accept = '.json';
    fileInput.style.display = 'none';
    
    // Add click handler for import button
    importButton.addEventListener('click', function() {
        fileInput.click();
    });
    
    // Add change handler for file selection
    fileInput.addEventListener('change', function(e) {
        if (e.target.files.length === 0) return;
        
        const file = e.target.files[0];
        const reader = new FileReader();
        
        reader.onload = function(event) {
            try {
                const importedData = JSON.parse(event.target.result);
                
                if (Array.isArray(importedData) && importedData.length > 0) {
                    // Check if the data has the expected structure
                    const isValid = importedData.every(entry =>
                        typeof entry === 'object' &&
                        (entry.date || entry.time || entry.drinkType || entry.urineVolume)
                    );
                    
                    if (isValid) {
                        if (confirm(`Import ${importedData.length} entries? This will replace your current data.`)) {
                            entries = importedData;
                            saveEntries();
                            renderEntries();
                            
                            // Update dashboard if it's visible
                            if (!dashboard.classList.contains('hidden')) {
                                renderDashboard();
                            }
                            
                            showMessage(`Successfully imported ${importedData.length} entries!`, 'success');
                        }
                    } else {
                        showMessage('Invalid backup file format', 'danger');
                    }
                } else {
                    showMessage('No valid entries found in the backup file', 'danger');
                }
            } catch (error) {
                console.error('Error importing backup:', error);
                showMessage('Error importing backup: Invalid JSON format', 'danger');
            }
            
            // Reset the file input
            fileInput.value = '';
        };
        
        reader.readAsText(file);
    });
    
    // Add hover effects
    downloadButton.addEventListener('mouseover', function() {
        this.style.backgroundColor = '#718096'; // Darker grey on hover
    });
    downloadButton.addEventListener('mouseout', function() {
        this.style.backgroundColor = '#a0aec0'; // Back to normal grey
    });
    
    importButton.addEventListener('mouseover', function() {
        this.style.backgroundColor = '#718096'; // Darker grey on hover
    });
    importButton.addEventListener('mouseout', function() {
        this.style.backgroundColor = '#a0aec0'; // Back to normal grey
    });
    
    // Add elements to the container
    buttonContainer.appendChild(downloadButton);
    buttonContainer.appendChild(importButton);
    document.body.appendChild(fileInput);
    
    // Add the container to the export section
    const toggleExportBtn = document.getElementById('toggleExportBtn');
    exportSection.insertBefore(buttonContainer, toggleExportBtn.nextSibling);
}


// Handle form submission
entryForm.addEventListener('submit', function(e) {
    e.preventDefault();

    try {
        // If timer is still running, stop it
        if (timerActive) {
            timerActive = false;
            clearInterval(timerInterval);
            const elapsedSeconds = Math.floor((Date.now() - timerStart) / 1000);
            urineVolumeInput.value = elapsedSeconds;
            timerBtn.textContent = 'Start';
            timerBtn.classList.remove('active');
            timerIndicator.classList.add('hidden');
            timerIndicator.classList.remove('pulse');
        }

        // Get form values
        const drinkType = document.getElementById('drinkType').value;
        const drinkAmount = document.getElementById('drinkAmount').value;
        const urineVolume = document.getElementById('urineVolume').value;
        const urgency = document.getElementById('urgency').value;
        const urineStream = document.getElementById('urineStream').value;

        // Check if at least one field is filled
        if (!drinkType && !drinkAmount && !urineVolume && !urgency && !urineStream) {
            showMessage('Please enter at least one type of data before saving.', 'danger');
            return;
        }

        const entryData = {
            date: document.getElementById('date').value,
            time: document.getElementById('time').value,
            drinkType,
            drinkAmount,
            urineVolume,
            urgency,
            urineStream
        };

        // Check if we're editing an existing entry
        const editIndex = entryForm.dataset.editIndex;
        if (editIndex !== undefined) {
            // Update existing entry
            entries[editIndex] = entryData;
            delete entryForm.dataset.editIndex;

            // Change the submit button text back
            const submitBtn = entryForm.querySelector('button[type="submit"]');
            submitBtn.textContent = 'Save Entry';

            showMessage('Entry updated successfully!', 'success');
        } else {
            // Add new entry
            entries.push(entryData);
            showMessage('Entry saved successfully!', 'success');
        }

        // Save to storage
        saveEntries();

        // Render entries
        renderEntries();
        
        // Check if dashboard is visible and update charts if needed
        if (!dashboard.classList.contains('hidden')) {
            renderDashboard();
        }

        // Reset form and hide
        entryForm.reset();
        entryForm.style.display = 'none';
        toggleFormBtn.textContent = 'Add New Entry';

    } catch (error) {
        console.error('Error saving entry', error);
        showMessage('Error saving entry');
    }
});

        
        // Toggle export data
toggleExportBtn.addEventListener('click', function() {
    try {
        if (entries.length === 0) {
            showMessage('No entries to export');
            return;
        }
        
        const helperText = document.querySelector('.helper-text');
        
        if (exportArea.style.display === 'none' || exportArea.style.display === '') {
            // Create a clean text representation
            let textData = "BLADDER DIARY ENTRIES\n\n";
            
            // Sort by date and time (oldest first for export)
            const sortedEntries = entries.slice().sort(function(a, b) {
                // Compare dates directly as strings (YYYY-MM-DD format sorts correctly)
                if (a.date !== b.date) {
                    return a.date > b.date ? 1 : -1;
                }
                // If dates are the same, compare times
                return a.time > b.time ? 1 : -1;
            });
            
            sortedEntries.forEach(function(entry) {
                textData += `Date: ${entry.date} Time: ${entry.time}\n`;
                
                if (entry.drinkType) {
                    textData += `Drink: ${entry.drinkType} (${entry.drinkAmount || 0} ml)\n`;
                }
                
                if (entry.urineVolume) {
                    textData += `Urine: ${entry.urineVolume} seconds (Urgency: ${entry.urgency || 'N/A'})\n`;
                }
                
                if (entry.urineStream) {
                    textData += `Urine Flow: Stream: ${entry.urineStream}\n`;
                }
                
                textData += `\n`;
            });
            
            // Show in textarea and auto-select
            exportArea.value = textData;
            exportArea.style.display = 'block';
            
            // Show helper text
            if (helperText) {
                helperText.style.display = 'block';
            }
            
            // IMPROVED: Use setTimeout to ensure selection happens after display
            setTimeout(() => {
                exportArea.focus();
                exportArea.select();
            }, 100);
            
            toggleExportBtn.textContent = 'Hide Export Data';
            showMessage('Text is selected and ready to copy', 'success');
        } else {
            exportArea.style.display = 'none';
            
            // Hide helper text
            if (helperText) {
                helperText.style.display = 'none';
            }
            
            toggleExportBtn.textContent = 'Show Export Data';
        }
        
    } catch (error) {
        console.error('Error exporting data', error);
        showMessage('Error creating export');
    }
});
        
        // Dashboard toggle functionality
        toggleDashboardBtn.addEventListener('click', function() {
            try {
                if (dashboard.classList.contains('hidden')) {
                    dashboard.classList.remove('hidden');
                    toggleDashboardBtn.textContent = 'Hide Dashboard';
                    renderDashboard();
                } else {
                    dashboard.classList.add('hidden');
                    toggleDashboardBtn.textContent = 'Show Dashboard';
                }
            } catch (error) {
                console.error('Error toggling dashboard', error);
                showMessage('Error showing dashboard');
            }
        });
        
        // IMPROVED: Canvas utility functions
        function clearCanvas(canvas) {
            const ctx = canvas.getContext('2d');
            ctx.clearRect(0, 0, canvas.width, canvas.height);
        }
        
        function setCanvasDimensions(canvas) {
            // Get the display dimensions
            const displayWidth = canvas.clientWidth;
            const displayHeight = canvas.clientHeight;
            
            // Check if the canvas is not the same size
            if (canvas.width !== displayWidth || canvas.height !== displayHeight) {
                // Set the canvas size to match the display size
                canvas.width = displayWidth;
                canvas.height = displayHeight;
            }
        }
        
        function drawEmptyState(canvas, message) {
            const ctx = canvas.getContext('2d');
            const width = canvas.width;
            const height = canvas.height;
            
            // Detect if we're on a small screen (like mobile)
            const isMobile = width < 400;
            
            ctx.fillStyle = '#f8f9fa';
            ctx.fillRect(0, 0, width, height);
            
            ctx.font = `${isMobile ? 12 : 14}px sans-serif`;
            ctx.fillStyle = '#a0aec0';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(message, width / 2, height / 2);
            
            // Add an icon or helper text for mobile
            if (isMobile) {
                ctx.font = '10px sans-serif';
                ctx.fillText('Add more entries to see data here', width / 2, height / 2 + 20);
            }
        }
        
        // Dashboard-related functions
        function renderDashboard() {
    try {
        // Check if we have any data
        if (entries.length === 0) {
            noDataMsg.style.display = 'block';
            dashboardCharts.classList.add('hidden');
            return;
        }

        // We have data, show the charts
        noDataMsg.style.display = 'none';
        dashboardCharts.classList.remove('hidden');

        // Render each chart
        renderFrequencyChart();
        renderUrgencyChart();
        renderTimeGapChart(); // Add this line to render the new chart
        renderCorrelationChart();
        renderStreamChart();
    } catch (error) {
        console.error('Error rendering dashboard', error);
        showMessage('Error displaying dashboard');
    }
}

        // IMPROVED: Canvas-based charts
        function renderFrequencyChart() {
            try {
                const canvas = document.getElementById('frequencyCanvas');
                if (!canvas) return;
                
                setCanvasDimensions(canvas);
                clearCanvas(canvas);
                
                // Group entries by date
                const entriesByDate = {};
                let hasUrineData = false;

                entries.forEach(entry => {
                    if (entry.urineVolume) {
                        hasUrineData = true;
                        
                        if (!entriesByDate[entry.date]) {
                            entriesByDate[entry.date] = 0;
                        }
                        entriesByDate[entry.date]++;
                    }
                });

                if (!hasUrineData) {
                    drawEmptyState(canvas, 'No urination data recorded yet');
                    return;
                }

                // Convert to array and sort by date
                const dateFrequencies = Object.entries(entriesByDate)
                    .sort((a, b) => a[0].localeCompare(b[0]))
                    .slice(-7); // Only show the last 7 days with data
                
                if (dateFrequencies.length === 0) {
                    drawEmptyState(canvas, 'No urination data recorded yet');
                    return;
                }

                const ctx = canvas.getContext('2d');
                const width = canvas.width;
                const height = canvas.height;
                
                // Detect if we're on a small screen (like mobile)
                const isMobile = width < 400;
                
                // Adjust padding based on screen size
                const padding = {
                    top: 30,
                    right: isMobile ? 10 : 20,
                    bottom: isMobile ? 60 : 40,
                    left: isMobile ? 40 : 50
                };
                
                const chartWidth = width - padding.left - padding.right;
                const chartHeight = height - padding.top - padding.bottom;
                
                // Find the maximum frequency for scaling
                const maxFrequency = Math.max(...dateFrequencies.map(df => df[1]));
                
                // Draw background
                ctx.fillStyle = '#f8f9fa';
                ctx.fillRect(0, 0, width, height);
                
                // Draw horizontal grid lines
                ctx.strokeStyle = '#e2e8f0';
                ctx.lineWidth = 1;
                
                // Mobile-optimized grid lines - draw fewer on small screens
                const gridLines = isMobile ? 4 : 5;
                
                for (let i = 0; i <= gridLines; i++) {
                    const y = padding.top + chartHeight - (i / gridLines) * chartHeight;
                    ctx.beginPath();
                    ctx.moveTo(padding.left, y);
                    ctx.lineTo(width - padding.right, y);
                    ctx.stroke();
                    
                    // Draw y-axis labels
                    ctx.fillStyle = '#718096';
                    ctx.font = isMobile ? '9px sans-serif' : '10px sans-serif';
                    ctx.textAlign = 'right';
                    ctx.textBaseline = 'middle';
                    ctx.fillText(Math.round((i / gridLines) * maxFrequency), padding.left - 5, y);
                }
                
                // Draw bars
                const barWidth = chartWidth / dateFrequencies.length * (isMobile ? 0.6 : 0.7); // Thinner on mobile
                const barSpacing = chartWidth / dateFrequencies.length;
                
                dateFrequencies.forEach((dateFreq, index) => {
                    const [date, count] = dateFreq;
                    const barHeight = (count / maxFrequency) * chartHeight;
                    const x = padding.left + index * barSpacing + (barSpacing - barWidth) / 2;
                    const y = padding.top + chartHeight - barHeight;
                    
                    // Draw bar with gradient
                    const gradient = ctx.createLinearGradient(x, y, x, y + barHeight);
                    gradient.addColorStop(0, '#a651e6');
                    gradient.addColorStop(1, '#4f9cf9');
                    
                    ctx.fillStyle = gradient;
                    ctx.beginPath();
                    ctx.roundRect(x, y, barWidth, barHeight, [4, 4, 0, 0]);
                    ctx.fill();
                    
                    // Draw bar value
                    ctx.fillStyle = '#4a5568';
                    ctx.font = isMobile ? '9px sans-serif' : '10px sans-serif';
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'bottom';
                    ctx.fillText(count, x + barWidth / 2, y - 5);
                    
                    // Draw x-axis labels
                    ctx.fillStyle = '#718096';
                    ctx.font = isMobile ? '9px sans-serif' : '10px sans-serif';
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'top';
                    ctx.save();
                    
                    // Simplified date format for mobile
                    let displayDate;
                    if (isMobile) {
                        // Show minimal date format on mobile ("25" instead of "Feb 25")
                        const dateParts = date.split('-');
                        const day = parseInt(dateParts[2]);
                        displayDate = `${day}`;
                    } else {
                        displayDate = formatDate(date);
                    }
                    
                    ctx.translate(x + barWidth / 2, height - padding.bottom / 2);
                    ctx.rotate(-Math.PI / (isMobile ? 3 : 4)); // Rotate more on mobile
                    ctx.fillText(displayDate, 0, 0);
                    ctx.restore();
                });
                
                // Add month labels for mobile displays
                if (isMobile && dateFrequencies.length > 0) {
                    // Add month labels above the day numbers
                    dateFrequencies.forEach(([date], index) => {
                        const dateParts = date.split('-');
                        const monthIndex = parseInt(dateParts[1]) - 1; // 0-based month
                        const months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];
                        
                        // Only show month for first day of month or first data point
                        if (index === 0 || dateParts[2] === '01') {
                            const x = padding.left + index * barSpacing + barSpacing / 2;
                            ctx.fillStyle = '#a0aec0'; // Lighter color for month
                            ctx.font = '8px sans-serif'; // Smaller than day
                            ctx.textAlign = 'center';
                            ctx.fillText(months[monthIndex], x, height - padding.bottom + 20);
                        }
                    });
                }
                
                // Add title for context on mobile
                if (isMobile) {
                    ctx.fillStyle = '#4a5568';
                    ctx.font = 'bold 10px sans-serif';
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'top';
                    ctx.fillText('Number of urinations per day', width / 2, height - 15);
                }
            } catch (error) {
                console.error('Error rendering frequency chart', error);
                const canvas = document.getElementById('frequencyCanvas');
                if (canvas) {
                    drawEmptyState(canvas, 'Could not generate chart');
                }
            }
        }

        function renderUrgencyChart() {
            try {
                const canvas = document.getElementById('urgencyCanvas');
                if (!canvas) return;
                
                setCanvasDimensions(canvas);
                clearCanvas(canvas);
                
                // Count urgency levels
                const urgencyCounts = { '0': 0, '1': 0, '2': 0, '3': 0 };
                let hasUrgencyData = false;

                entries.forEach(entry => {
                    if (entry.urgency) {
                        hasUrgencyData = true;
                        urgencyCounts[entry.urgency]++;
                    }
                });

                if (!hasUrgencyData) {
                    drawEmptyState(canvas, 'No urgency data recorded yet');
                    return;
                }

                // Calculate total for percentages
                const total = Object.values(urgencyCounts).reduce((sum, count) => sum + count, 0);
                if (total === 0) {
                    drawEmptyState(canvas, 'No urgency data recorded yet');
                    return;
                }
                
                const ctx = canvas.getContext('2d');
                const width = canvas.width;
                const height = canvas.height;
                
                // Detect if we're on a small screen (like mobile)
                const isMobile = width < 400;
                
                // Adjust dimensions based on screen size
                const centerX = width / 2.2; // Shift pie slightly left to make room for legend
                const centerY = height / 2;
                // Smaller pie on mobile
                const radius = Math.min(width, height) / (isMobile ? 2.8 : 2.5) - 30;
                
                // Colors for urgency levels
                const colors = {
                    '0': '#48bb78', // Green for none
                    '1': '#4299e1', // Blue for mild
                    '2': '#ecc94b', // Yellow for moderate
                    '3': '#e53e3e'  // Red for severe
                };
                
                // Display names for urgency levels
                const urgencyLabels = {
                    '0': 'None',
                    '1': 'Mild',
                    '2': 'Moderate',
                    '3': 'Severe'
                };
                
                // Draw background
                ctx.fillStyle = '#f8f9fa';
                ctx.fillRect(0, 0, width, height);
                
                // Draw pie chart
                let startAngle = 0;
                
                // Draw each slice of the pie
                for (const [level, count] of Object.entries(urgencyCounts)) {
                    if (count > 0) {
                        const sliceAngle = (count / total) * 2 * Math.PI;
                        
                        ctx.beginPath();
                        ctx.moveTo(centerX, centerY);
                        ctx.arc(centerX, centerY, radius, startAngle, startAngle + sliceAngle);
                        ctx.closePath();
                        
                        ctx.fillStyle = colors[level];
                        ctx.fill();
                        
                        // Draw slice label
                        const labelAngle = startAngle + sliceAngle / 2;
                        const percent = Math.round((count / total) * 100);
                        
                        // Only draw percentage label if slice is big enough
                        if (percent >= (isMobile ? 8 : 5)) {
                            // Position the label at 2/3 of radius
                            const labelX = centerX + Math.cos(labelAngle) * (radius * 0.65);
                            const labelY = centerY + Math.sin(labelAngle) * (radius * 0.65);
                            
                            ctx.fillStyle = 'white';
                            ctx.font = `bold ${isMobile ? 10 : 12}px sans-serif`;
                            ctx.textAlign = 'center';
                            ctx.textBaseline = 'middle';
                            ctx.fillText(`${percent}%`, labelX, labelY);
                        }
                        
                        startAngle += sliceAngle;
                    }
                }
                
                // Draw legend - optimized for mobile
                const legendX = isMobile ? width * 0.68 : width * 0.7;
                let legendY = isMobile ? centerY - radius : 20;
                
                ctx.textAlign = 'left';
                ctx.textBaseline = 'middle';
                
                // Draw title for legend on mobile
                if (isMobile) {
                    ctx.fillStyle = '#4a5568';
                    ctx.font = 'bold 10px sans-serif';
                    ctx.fillText('Urgency levels:', legendX, legendY - 20);
                }
                
                for (const [level, count] of Object.entries(urgencyCounts)) {
                    if (count > 0) {
                        // Draw legend color box
                        ctx.fillStyle = colors[level];
                        // Smaller boxes on mobile
                        const boxSize = isMobile ? 10 : 12;
                        ctx.fillRect(legendX, legendY, boxSize, boxSize);
                        
                        // Draw legend text
                        ctx.fillStyle = '#4a5568';
                        ctx.font = `${isMobile ? 9 : 12}px sans-serif`;
                        ctx.fillText(
                            `${urgencyLabels[level]} (${count})`,
                            legendX + boxSize + 6,
                            legendY + boxSize/2
                        );
                        
                        // Less spacing on mobile
                        legendY += isMobile ? 16 : 20;
                    }
                }
                
                // Add note about urgency scale on mobile
                if (isMobile) {
                    const noteY = height - 15;
                    ctx.fillStyle = '#718096';
                    ctx.font = 'italic 8px sans-serif';
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.fillText('Urgency scale: 0 (None) to 3 (Severe)', width / 2, noteY);
                }
                
            } catch (error) {
                console.error('Error rendering urgency chart', error);
                const canvas = document.getElementById('urgencyCanvas');
                if (canvas) {
                    drawEmptyState(canvas, 'Could not generate chart');
                }
            }
        }

        function renderCorrelationChart() {
            try {
                const canvas = document.getElementById('correlationCanvas');
                if (!canvas) return;
                
                setCanvasDimensions(canvas);
                clearCanvas(canvas);
                
                // Group entries by date
                const dailyData = {};
                let hasData = false;

                entries.forEach(entry => {
                    if (!dailyData[entry.date]) {
                        dailyData[entry.date] = {
                            date: entry.date,
                            drinkAmount: 0,
                            urinationCount: 0
                        };
                    }
                    
                    if (entry.drinkAmount) {
                        hasData = true;
                        dailyData[entry.date].drinkAmount += parseInt(entry.drinkAmount) || 0;
                    }
                    
                    if (entry.urineVolume) {
                        hasData = true;
                        dailyData[entry.date].urinationCount++;
                    }
                });

                if (!hasData) {
                    drawEmptyState(canvas, 'Not enough data for correlation');
                    return;
                }

                // Convert to array and sort by date
                const dailyDataArray = Object.values(dailyData)
                    .filter(day => day.drinkAmount > 0 || day.urinationCount > 0)
                    .sort((a, b) => a.date.localeCompare(b.date))
                    .slice(-5); // Last 5 days with data
                    
                if (dailyDataArray.length === 0) {
                    drawEmptyState(canvas, 'Not enough data for correlation');
                    return;
                }
                
                const ctx = canvas.getContext('2d');
                const width = canvas.width;
                const height = canvas.height;
                
                // Detect if we're on a small screen (like mobile)
                const isMobile = width < 400;
                
                // Adjust padding based on screen size
                const padding = {
                    top: 30,
                    right: isMobile ? 10 : 20,
                    bottom: isMobile ? 60 : 40,
                    left: isMobile ? 40 : 50
                };
                
                const chartWidth = width - padding.left - padding.right;
                const chartHeight = height - padding.top - padding.bottom;
                
                // Draw background
                ctx.fillStyle = '#f8f9fa';
                ctx.fillRect(0, 0, width, height);
                
                // Find max values for scaling
                const maxDrink = Math.max(...dailyDataArray.map(day => day.drinkAmount));
                const maxCount = Math.max(...dailyDataArray.map(day => day.urinationCount));
                
                // Draw grid lines
                ctx.strokeStyle = '#e2e8f0';
                ctx.lineWidth = 1;
                
                // Draw y-axis line
                ctx.beginPath();
                ctx.moveTo(padding.left, padding.top);
                ctx.lineTo(padding.left, height - padding.bottom);
                ctx.stroke();
                
                // Draw x-axis line
                ctx.beginPath();
                ctx.moveTo(padding.left, height - padding.bottom);
                ctx.lineTo(width - padding.right, height - padding.bottom);
                ctx.stroke();
                
                // Mobile-optimized grid lines - draw fewer on small screens
                const gridLines = isMobile ? 3 : 5;
                
                // Draw horizontal grid lines for drink amount
                for (let i = 0; i <= gridLines; i++) {
                    const y = padding.top + (1 - i / gridLines) * chartHeight;
                    ctx.beginPath();
                    ctx.moveTo(padding.left, y);
                    ctx.lineTo(width - padding.right, y);
                    ctx.stroke();
                    
                    // Draw y-axis labels for drink amount
                    const drinkValue = Math.round((i / gridLines) * maxDrink);
                    ctx.fillStyle = '#4f9cf9';
                    ctx.font = isMobile ? '9px sans-serif' : '10px sans-serif';
                    ctx.textAlign = 'right';
                    ctx.textBaseline = 'middle';
                    ctx.fillText(`${drinkValue}${isMobile ? '' : ' ml'}`, padding.left - 5, y);
                }
                
                // Draw group bar chart
                const barWidth = chartWidth / dailyDataArray.length * (isMobile ? 0.25 : 0.3);
                const groupWidth = chartWidth / dailyDataArray.length;
                
                dailyDataArray.forEach((day, index) => {
                    // Simplified date format for mobile
                    let displayDate;
                    if (isMobile) {
                        // Show minimal date format on mobile ("25" instead of "Feb 25")
                        const dateParts = day.date.split('-');
                        const dayNum = parseInt(dateParts[2]);
                        displayDate = `${dayNum}`;
                    } else {
                        displayDate = formatDate(day.date);
                    }
                    
                    // Draw date label
                    ctx.fillStyle = '#718096';
                    ctx.font = isMobile ? '9px sans-serif' : '10px sans-serif';
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'top';
                    ctx.save();
                    ctx.translate(padding.left + index * groupWidth + groupWidth / 2, height - padding.bottom + 5);
                    ctx.rotate(-Math.PI / (isMobile ? 3 : 4)); // Rotate more on mobile
                    ctx.fillText(displayDate, 0, 0);
                    ctx.restore();
                    
                    // Draw drink amount bar
                    const drinkBarHeight = maxDrink > 0 ? (day.drinkAmount / maxDrink) * chartHeight : 0;
                    // Move bars closer on mobile
                    const drinkX = padding.left + index * groupWidth + (isMobile ? groupWidth * 0.30 : groupWidth * 0.25);
                    const drinkY = height - padding.bottom - drinkBarHeight;
                    
                    ctx.fillStyle = '#4f9cf9';
                    ctx.beginPath();
                    ctx.roundRect(drinkX, drinkY, barWidth, drinkBarHeight, [4, 4, 0, 0]);
                    ctx.fill();
                    
                    // Draw drink value
                    if (day.drinkAmount > 0) {
                        ctx.fillStyle = '#4a5568';
                        ctx.font = isMobile ? '9px sans-serif' : '10px sans-serif';
                        ctx.textAlign = 'center';
                        ctx.fillText(day.drinkAmount, drinkX + barWidth / 2, drinkY - 5);
                    }
                    
                    // Draw urination count bar scaled up for visibility
                    const countBarHeight = maxCount > 0 ? (day.urinationCount / maxCount) * chartHeight : 0;
                    // Move bars closer on mobile
                    const countX = padding.left + index * groupWidth + (isMobile ? groupWidth * 0.60 : groupWidth * 0.6);
                    const countY = height - padding.bottom - countBarHeight;
                    
                    ctx.fillStyle = '#a651e6';
                    ctx.beginPath();
                    ctx.roundRect(countX, countY, barWidth, countBarHeight, [4, 4, 0, 0]);
                    ctx.fill();
                    
                    // Draw count value
                    if (day.urinationCount > 0) {
                        ctx.fillStyle = '#4a5568';
                        ctx.font = isMobile ? '9px sans-serif' : '10px sans-serif';
                        ctx.textAlign = 'center';
                        ctx.fillText(day.urinationCount, countX + barWidth / 2, countY - 5);
                    }
                });
                
                // Add month labels for mobile displays
                if (isMobile && dailyDataArray.length > 0) {
                    // Add month labels above the day numbers
                    dailyDataArray.forEach((day, index) => {
                        const dateParts = day.date.split('-');
                        const monthIndex = parseInt(dateParts[1]) - 1; // 0-based month
                        const months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];
                        
                        // Only show month for first day of month or first data point
                        if (index === 0 || dateParts[2] === '01') {
                            const x = padding.left + index * groupWidth + groupWidth / 2;
                            ctx.fillStyle = '#a0aec0'; // Lighter color for month
                            ctx.font = '8px sans-serif'; // Smaller than day
                            ctx.textAlign = 'center';
                            ctx.fillText(months[monthIndex], x, height - padding.bottom + 20);
                        }
                    });
                }
                
                // Draw legend
                const legendY = height - 15;
                
                // Drink legend
                ctx.fillStyle = '#4f9cf9';
                ctx.fillRect(padding.left, legendY, 12, 12);
                ctx.fillStyle = '#4a5568';
                ctx.font = '10px sans-serif';
                ctx.textAlign = 'left';
                ctx.textBaseline = 'middle';
                ctx.fillText('Fluid intake (ml)', padding.left + 16, legendY + 6);
                
                // Count legend
                ctx.fillStyle = '#a651e6';
                ctx.fillRect(padding.left + 120, legendY, 12, 12);
                ctx.fillStyle = '#4a5568';
                ctx.fillText('Urination frequency', padding.left + 136, legendY + 6);
                
            } catch (error) {
                console.error('Error rendering correlation chart', error);
                const canvas = document.getElementById('correlationCanvas');
                if (canvas) {
                    drawEmptyState(canvas, 'Could not generate chart');
                }
            }
        }

        function renderStreamChart() {
    try {
        const canvas = document.getElementById('streamCanvas');
        if (!canvas) return;

        // Use the same dynamic sizing approach as other charts:
        setCanvasDimensions(canvas);
        clearCanvas(canvas);

        const ctx = canvas.getContext('2d');
        const width = canvas.width;
        const height = canvas.height;
        
        // Detect if we're on a small screen (like mobile)
        const isMobile = width < 400;

        // Get all entries with urine stream data
        const streamEntries = entries.filter(entry => entry.urineStream);
        if (streamEntries.length === 0) {
            drawEmptyState(canvas, 'No stream data recorded yet');
            return;
        }

        // Sort entries by date/time
        streamEntries.sort((a, b) => {
            if (a.date !== b.date) {
                return a.date.localeCompare(b.date);
            }
            return a.time.localeCompare(b.time);
        });

        // IMPROVED: Limit to the most recent entries for better visibility on mobile
        const recentEntries = streamEntries.slice(-(isMobile ? 8 : 12));

        // Convert stream types to numeric values
        const streamValues = {
            'Strong': 3,
            'Intermittent': 2,
            'Weak': 1
        };

        // Prepare data points
        const dataPoints = recentEntries.map(entry => {
            const value = streamValues[entry.urineStream];
            if (!value) console.error(`Invalid urineStream value: ${entry.urineStream}`);
            return {
                date: entry.date,
                time: entry.time,
                displayDate: formatDate(entry.date),
                value: value || 1, // Default to Weak if invalid
                label: entry.urineStream
            };
        });

        // Fill canvas background
        ctx.fillStyle = '#ffffff';
        ctx.fillRect(0, 0, width, height);

        // IMPROVED: Layout zones with proper margins for all screen sizes
        const padding = Math.min(width, height) * (isMobile ? 0.04 : 0.05); // Less padding on mobile
        
        const layout = {
            goal: { top: padding * 2, height: padding },
            chart: {
                top: padding * 4,
                bottom: height - padding * (isMobile ? 6 : 7), // More chart space on mobile
                left: padding * (isMobile ? 4 : 5), // Less left padding on mobile
                right: width - padding * 2
            },
            trend: { top: height - padding * 4, height: padding * 1.5 },
            legend: { top: height - padding * 2, height: padding }
        };

        // Draw goal with mobile optimization
        ctx.fillStyle = '#4a5568';
        ctx.font = `italic ${isMobile ? 11 : 14}px sans-serif`;
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';

        const goalText = 'Goal: Strong urine stream indicates better bladder health';
        const maxGoalWidth = width * (isMobile ? 0.95 : 0.9); // More width on mobile

        // Check if we need to break the text
        ctx.font = `italic ${isMobile ? 11 : 14}px sans-serif`; // Set font before measuring
        const goalWidth = ctx.measureText(goalText).width;

        if (goalWidth > maxGoalWidth && width < 400) {
            // For smaller screens, break into two lines
            const firstLine = 'Goal: Strong urine stream';
            const secondLine = 'indicates better bladder health';
            
            ctx.fillText(
                firstLine,
                width / 2,
                layout.goal.top + layout.goal.height / 2 - 10
            );
            
            ctx.fillText(
                secondLine,
                width / 2,
                layout.goal.top + layout.goal.height / 2 + 10
            );
        } else {
            // For larger screens, keep as one line but ensure it fits
            ctx.fillText(
                goalText,
                width / 2,
                layout.goal.top + layout.goal.height / 2
            );
        }

        // Make sure to adjust the chart area if we're using two lines
        if (goalWidth > maxGoalWidth && width < 400) {
            // Add some extra space for the two-line goal text
            layout.chart.top += 15;
        }

        // Define y-axis levels (Strong = 3, Intermittent = 2, Weak = 1)
        const streamLevels = [
            { value: 3, label: 'Strong', color: '#22c55e' },
            { value: 2, label: 'Intermittent', color: '#eab308' },
            { value: 1, label: 'Weak', color: '#dc2626' }
        ];

        const chartHeight = layout.chart.bottom - layout.chart.top;
        // IMPROVED: MORE spacing between levels (using 4 divisions for 3 levels gives more space)
        const levelHeight = chartHeight / 4;

        // Draw horizontal lines & labels
        streamLevels.forEach((level) => {
            // IMPROVED: Adjusted level position calculation for more vertical space
            const yPos = layout.chart.top + (4 - level.value) * levelHeight;
            ctx.strokeStyle = '#e2e8f0';
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.moveTo(layout.chart.left, yPos);
            ctx.lineTo(layout.chart.right, yPos);
            ctx.stroke();

            // Adjust font size for stream labels based on available space
            const leftPadding = layout.chart.left;
            const maxLabelWidth = leftPadding - (isMobile ? 10 : 15); // Less margin on mobile
            
            ctx.fillStyle = level.color;
            
            // Mobile-optimized fonts
            const fontSize = isMobile ? 10 : 12;
            
            ctx.font = `bold ${fontSize}px sans-serif`;
            ctx.textAlign = 'right';
            ctx.textBaseline = 'middle';
            
            // Calculate text metrics to check if it fits
            const metrics = ctx.measureText(level.label);
            const textWidth = metrics.width;
            
            // If the text is still too wide, shrink it more
            if (textWidth > maxLabelWidth) {
                const scaleFactor = maxLabelWidth / textWidth;
                const adjustedFontSize = Math.floor(fontSize * scaleFactor);
                ctx.font = `bold ${adjustedFontSize}px sans-serif`;
            }
            
            ctx.fillText(level.label, layout.chart.left - (isMobile ? 6 : 10), yPos);
        });

        // IMPROVED: Calculate available width more accurately
        const chartWidth = layout.chart.right - layout.chart.left;
        if (dataPoints.length > 0) {
            // Better date step calculation
            const dateStep = chartWidth / (dataPoints.length > 1 ? dataPoints.length - 1 : 1);

            ctx.beginPath();
            ctx.strokeStyle = '#4f9cf9';
            ctx.lineWidth = isMobile ? 1.5 : 2; // Thinner line on mobile

            dataPoints.forEach((point, index) => {
                const x = layout.chart.left + index * dateStep;
                // IMPROVED: Use adjusted level height calculation
                const y = layout.chart.top + (4 - point.value) * levelHeight;

                if (index === 0) {
                    ctx.moveTo(x, y);
                } else {
                    ctx.lineTo(x, y);
                }

                // Draw date labels - improved spacing
                ctx.fillStyle = '#718096';
                ctx.font = `${isMobile ? 9 : 12}px sans-serif`;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'top';
                
                // Simplified date format for mobile
                let displayLabel;
                if (isMobile) {
                    const dateParts = point.date.split('-');
                    const day = parseInt(dateParts[2]);
                    displayLabel = `${day}`;
                } else {
                    displayLabel = point.displayDate;
                }
                
                // Rotate date labels if many dates
                if (dataPoints.length > (isMobile ? 3 : 4)) {
                    ctx.save();
                    ctx.translate(x, layout.chart.bottom + 10);
                    ctx.rotate(-Math.PI / (isMobile ? 3 : 6)); // Rotate more on mobile
                    ctx.fillText(displayLabel, 0, 0);
                    ctx.restore();
                } else {
                    ctx.fillText(displayLabel, x, layout.chart.bottom + 10);
                }
            });
            ctx.stroke();

            // Add month labels for mobile displays
            if (isMobile && dataPoints.length > 0) {
                // Add month labels above the day numbers
                dataPoints.forEach((point, index) => {
                    const dateParts = point.date.split('-');
                    const monthIndex = parseInt(dateParts[1]) - 1; // 0-based month
                    const months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];
                    
                    // Only show month for first day of month or first data point
                    if (index === 0 || dateParts[2] === '01') {
                        const x = layout.chart.left + index * dateStep;
                        ctx.fillStyle = '#a0aec0'; // Lighter color for month
                        ctx.font = '8px sans-serif'; // Smaller than day
                        ctx.textAlign = 'center';
                        ctx.fillText(months[monthIndex], x, layout.chart.bottom + 28);
                    }
                });
            }

            // Draw point circles - smaller on mobile
            dataPoints.forEach((point, index) => {
                const x = layout.chart.left + index * dateStep;
                // IMPROVED: Use adjusted level height calculation
                const y = layout.chart.top + (4 - point.value) * levelHeight;

                let pointColor;
                switch (point.value) {
                    case 3: pointColor = '#22c55e'; break;
                    case 2: pointColor = '#eab308'; break;
                    case 1: pointColor = '#dc2626'; break;
                    default: pointColor = '#4f9cf9';
                }

                ctx.beginPath();
                ctx.fillStyle = pointColor;
                ctx.arc(x, y, isMobile ? 6 : 8, 0, Math.PI * 2);
                ctx.fill();

                // White outline
                ctx.strokeStyle = '#ffffff';
                ctx.lineWidth = isMobile ? 1.5 : 2;
                ctx.stroke();
            });

            // Simple trend calculation
            if (dataPoints.length >= 2) {
                const firstPoint = [dataPoints[0]];  // Take just the first point
                const lastPoint = [dataPoints[dataPoints.length - 1]];  // Take just the last point

                const firstAvg = firstPoint[0].value;  // Direct value of first point
                const lastAvg = lastPoint[0].value;    // Direct value of last point

                let trendDirection, trendColor, trendEmoji;
                if (lastAvg > firstAvg + 0.3) {
                    trendDirection = 'Improving';
                    trendColor = '#22c55e';
                    trendEmoji = '👍';
                } else if (lastAvg < firstAvg - 0.3) {
                    trendDirection = 'Worsening';
                    trendColor = '#dc2626';
                    trendEmoji = '👎';
                } else {
                    trendDirection = 'Stable';
                    trendColor = '#eab308';
                    trendEmoji = '➡️';
                }

                // Dotted trend line
                ctx.beginPath();
                ctx.strokeStyle = trendColor;
                ctx.setLineDash([5, 3]);
                ctx.lineWidth = isMobile ? 2 : 2.5;

                const firstX = layout.chart.left;
                // IMPROVED: Use adjusted level height calculation
                const firstY = layout.chart.top + (4 - firstAvg) * levelHeight;
                const lastX = layout.chart.right;
                // IMPROVED: Use adjusted level height calculation
                const lastY = layout.chart.top + (4 - lastAvg) * levelHeight;

                ctx.moveTo(firstX, firstY);
                ctx.lineTo(lastX, lastY);
                ctx.stroke();
                ctx.setLineDash([]);

                // Trend text - smaller on mobile
                ctx.fillStyle = trendColor;
                ctx.font = `bold ${isMobile ? 14 : 16}px sans-serif`;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(
                    `${trendEmoji} ${trendDirection} trend`,
                    width / 2,
                    layout.trend.top + layout.trend.height / 2
                );

                // Legend text - smaller on mobile
                ctx.fillStyle = '#4a5568';
                ctx.font = `${isMobile ? 11 : 14}px sans-serif`;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(
                    'Dotted line shows overall trend',
                    width / 2,
                    layout.legend.top + layout.legend.height / 2
                );
            }
        }
    } catch (error) {
        console.error('Error rendering stream chart', error);
        const canvas = document.getElementById('streamCanvas');
        if (canvas) {
            drawEmptyState(canvas, 'Could not generate chart');
        }
    }
}

        
        // Pull-to-refresh functionality
        function startRefreshing() {
            if (isRefreshing) return;
            isRefreshing = true;
            
            pullToRefresh.classList.add('refreshing');
            
            // Simulate a refresh (in this case, just reload entries from storage)
            setTimeout(function() {
                loadEntries();
                
                // Update dashboard if visible
                if (!dashboard.classList.contains('hidden')) {
                    renderDashboard();
                }
                
                pullToRefresh.classList.remove('visible', 'refreshing');
                isRefreshing = false;
                showMessage('Refreshed', 'success');
            }, 800);
        }

        // Function to make the logo clickable to refresh data
function addLogoRefreshFunctionality() {
    const appLogo = document.querySelector('.app-logo');
    const appLogoInner = document.querySelector('.app-logo-inner');
    
    if (appLogo && appLogoInner) {
        // Add cursor style to indicate it's clickable
        appLogo.style.cursor = 'pointer';
        
        // Add a subtle title/tooltip
        appLogo.title = 'Refresh data';
        
        // Add click handler
        appLogo.addEventListener('click', function() {
            // Show a subtle animation on click
            appLogoInner.style.transition = 'transform 0.5s';
            appLogoInner.style.transform = 'rotate(360deg)';
            
            // Reset the animation after it completes
            setTimeout(() => {
                appLogoInner.style.transition = '';
                appLogoInner.style.transform = '';
            }, 500);
            
            // Perform the actual refresh (same as pull-to-refresh)
            loadEntries();
            
            // Update dashboard if visible
            if (!dashboard.classList.contains('hidden')) {
                renderDashboard();
            }
            
            showMessage('Data refreshed', 'success');
        });
    }
}
        
        // Touch event handlers for pull-to-refresh
        document.addEventListener('touchstart', function(e) {
            // Only trigger if we're at the top of the page
            if (window.scrollY === 0) {
                touchStartY = e.touches[0].clientY;
            }
        }, { passive: true });
        
        document.addEventListener('touchmove', function(e) {
            if (touchStartY > 0 && !isRefreshing) {
                touchEndY = e.touches[0].clientY;
                const distance = touchEndY - touchStartY;
                
                // Only show pull indicator if we're pulling down
                if (distance > 0) {
                    pullToRefresh.classList.add('visible');
                    
                    // Calculate a rotation for the refresh icon based on pull distance
                    const rotationDegrees = Math.min(distance * 2, 180);
                    document.querySelector('.pull-to-refresh-icon').style.transform = `rotate(${rotationDegrees}deg)`;
                }
            }
        }, { passive: true });
        
        document.addEventListener('touchend', function() {
            if (touchStartY > 0 && touchEndY > 0 && !isRefreshing) {
                const distance = touchEndY - touchStartY;
                
                // If pulled far enough, trigger refresh
                if (distance > 60) {
                    startRefreshing();
                } else {
                    // Otherwise, just hide the indicator
                    pullToRefresh.classList.remove('visible');
                }
                
                // Reset values
                touchStartY = 0;
                touchEndY = 0;
            }
        }, { passive: true });
        
        
        
        // IMPROVED: Add focus and select handler for export text
        exportArea.addEventListener('blur', function() {
            setTimeout(() => {
                exportArea.focus();
                exportArea.select();
            }, 100);
        });


// IMPROVED: Add focus and select handler for export text
exportArea.addEventListener('blur', function() {
    setTimeout(() => {
        exportArea.focus();
        exportArea.select();
    }, 100);
});

// Motivational insights functionality
const motivationalSection = document.getElementById('motivationalSection');
const insightMessage = document.getElementById('insightMessage');
const refreshInsightBtn = document.getElementById('refreshInsightBtn');
const toggleAiSettings = document.getElementById('toggleAiSettings');
const aiSettingsPanel = document.getElementById('aiSettingsPanel');
const openaiKeyInput = document.getElementById('openaiKey');
const useOpenAICheckbox = document.getElementById('useOpenAI');
const saveAiSettingsBtn = document.getElementById('saveAiSettings');
const loadingMessage = document.getElementById('loadingMessage');

// Store last generated time to avoid excessive regeneration
let lastInsightTime = null;
let lastInsightType = null;

// AI settings management
function loadAiSettings() {
    const aiSettingsPanel = document.getElementById('aiSettingsPanel');
    const openaiKeyInput = document.getElementById('openaiKey');
    const useOpenAICheckbox = document.getElementById('useOpenAI');
    const saveAiSettingsBtn = document.getElementById('saveAiSettings');

    if (localStorageAvailable) {
        let aiSettings = JSON.parse(localStorage.getItem('bladderDiaryAiSettings') || '{"useOpenAI":false,"openaiKey":""}');
        
        // Ensure useOpenAI is false if no key exists
        if (!aiSettings.openaiKey || aiSettings.openaiKey.trim() === '') {
            aiSettings.useOpenAI = false;
        }

        openaiKeyInput.value = aiSettings.openaiKey || '';
        useOpenAICheckbox.checked = aiSettings.useOpenAI || false;

        saveAiSettingsBtn.addEventListener('click', () => {
            const newSettings = {
                useOpenAI: useOpenAICheckbox.checked,
                openaiKey: openaiKeyInput.value.trim()
            };
            
            // Disable AI use if no key is provided
            if (!newSettings.openaiKey) {
                newSettings.useOpenAI = false;
                useOpenAICheckbox.checked = false;
            }

            localStorage.setItem('bladderDiaryAiSettings', JSON.stringify(newSettings));
            showMessage('AI settings saved', 'success');
            aiSettingsPanel.classList.add('hidden');
            generateInsight(true); // Refresh insight with new settings
        });
    }
}

function saveAiSettings() {
    if (localStorageAvailable) {
        const settings = {
            openaiKey: openaiKeyInput.value.trim(),
            useOpenAI: useOpenAICheckbox.checked
        };
        
        try {
            localStorage.setItem('bladderDiaryAiSettings', JSON.stringify(settings));
            showMessage('AI settings saved', 'success');
        } catch (e) {
            console.error('Error saving AI settings:', e);
            showMessage('Error saving settings', 'danger');
        }
    }
}

// Toggle AI settings panel
toggleAiSettings.addEventListener('click', function() {
    aiSettingsPanel.classList.toggle('hidden');
    
    if (!aiSettingsPanel.classList.contains('hidden')) {
        // Load current settings when panel is shown
        loadAiSettings();
    }
});

// Save AI settings
saveAiSettingsBtn.addEventListener('click', function() {
    saveAiSettings();
    aiSettingsPanel.classList.add('hidden');
    // Generate new insight after saving settings
    generateInsight(true);
});

// Refresh insight manually
refreshInsightBtn.addEventListener('click', function() {
    generateInsight(true);
    
    // Add rotation animation
    refreshInsightBtn.querySelector('svg').style.transition = 'transform 0.5s ease';
    refreshInsightBtn.querySelector('svg').style.transform = 'rotate(360deg)';
    
    // Reset animation after it completes
    setTimeout(() => {
        refreshInsightBtn.querySelector('svg').style.transition = '';
        refreshInsightBtn.querySelector('svg').style.transform = '';
    }, 500);
});

// Determine time-based message type
function getInsightType() {
    const now = new Date();
    const hour = now.getHours();
    
    if (hour >= 5 && hour < 9) return 'morning';
    if (hour >= 9 && hour < 12) return 'midMorning';
    if (hour >= 12 && hour < 15) return 'afternoon';
    if (hour >= 15 && hour < 18) return 'lateAfternoon';
    if (hour >= 18 && hour < 21) return 'evening';
    if (hour >= 21 && hour < 23) return 'night';
    return 'lateNight';
}

// Replace the current generateInsight function with this fixed version
function generateInsight(forceRefresh = false) {
  const loadingMessage = document.getElementById('loadingMessage');
  if (loadingMessage) {
    loadingMessage.classList.remove('hidden');
  }
  
  try {
    const currentType = getInsightType();
    const currentTime = new Date().getTime();
    const timeDiff = lastInsightTime ? (currentTime - lastInsightTime) / (1000 * 60 * 60) : 24;
    
    // Use cached insight if fresh and not forced
    if (!forceRefresh && lastInsightTime && timeDiff < 1 && currentType === lastInsightType) {
      console.log('Using cached insight (still fresh)');
      // Ensure spinner is hidden
      if (loadingMessage) loadingMessage.classList.add('hidden');
      return;
    }
    
    // Get AI settings from localStorage (or default to not using AI)
    const aiSettings = localStorageAvailable
      ? JSON.parse(localStorage.getItem('bladderDiaryAiSettings') || '{"useOpenAI":false}')
      : { useOpenAI: false };
    
    // If AI is enabled and a key is provided, use AI insight; otherwise, fall back to simple insight
    if (aiSettings.useOpenAI && aiSettings.openaiKey) {
      generateAIInsight(currentType, aiSettings.openaiKey)
        .catch((error) => {
          console.error('Error generating AI insight:', error);
          updateInsightMessage('Unable to generate insight. Please try again.');
        })
        .finally(() => {
          if (loadingMessage) loadingMessage.classList.add('hidden');
        });
    } else {
      generateSimpleInsight(currentType);
    }
    
    // Update caching values
    lastInsightTime = currentTime;
    lastInsightType = currentType;
  } catch (error) {
    console.error('Error generating insight:', error);
    updateInsightMessage('Unable to generate insight. Please try again.');
  } finally {
    // Fallback: ensure that the spinner is hidden after 500ms if not already removed.
    setTimeout(() => {
      if (loadingMessage) loadingMessage.classList.add('hidden');
    }, 500);
  }
}


// Simple insight generation without AI
function generateSimpleInsight(timeType) {
    const currentDate = new Date().toLocaleDateString('en-US', {
        weekday: 'long',
        month: 'long',
        day: 'numeric'
    });
    
    // Get today's entries
    const today = new Date().toISOString().split('T')[0]; // YYYY-MM-DD
    const todayEntries = entries.filter(entry => entry.date === today);
    
    // Calculate statistics
    const drinkEntries = todayEntries.filter(entry => entry.drinkAmount);
    const urineEntries = todayEntries.filter(entry => entry.urineVolume);
    
    const totalDrinkAmount = drinkEntries.reduce((sum, entry) => sum + parseInt(entry.drinkAmount || 0), 0);
    const urineCount = urineEntries.length;
    
    let urgencyLevels = {
        '0': 0, '1': 0, '2': 0, '3': 0
    };
    
    urineEntries.forEach(entry => {
        if (entry.urgency) {
            urgencyLevels[entry.urgency]++;
        }
    });
    
    const highUrgencyCount = urgencyLevels['2'] + urgencyLevels['3'];
    
    // Calculate time since last urination
    let timeSinceLastUrination = null;
    if (urineEntries.length > 0) {
        // Sort by date and time
        const sortedEntries = [...urineEntries].sort((a, b) => {
            if (a.date !== b.date) return a.date > b.date ? -1 : 1;
            return a.time > b.time ? -1 : 1;
        });
        
        const lastEntry = sortedEntries[0];
        const lastEntryTime = new Date(`${lastEntry.date}T${lastEntry.time}`);
        const now = new Date();
        
        // Calculate time difference in hours
        timeSinceLastUrination = Math.round((now - lastEntryTime) / (1000 * 60) / 60 * 10) / 10;
    }
    
    // Generate message based on time type
    let message = '';
    
    switch (timeType) {
        case 'morning':
            message = `<strong>Good morning!</strong> It's ${currentDate}.<br><br>`;
            
            if (urineCount === 0) {
                message += "Don't forget to log your first urination of the day. A healthy start helps track your daily patterns.";
            } else {
                message += `You've recorded ${urineCount} urination event${urineCount !== 1 ? 's' : ''} this morning. `;
                
                if (timeSinceLastUrination !== null) {
                    message += `It's been about <span class="insight-highlight">${timeSinceLastUrination}</span> hours since your last recorded urination. `;
                }
                
                message += "Remember to stay hydrated throughout the day!";
            }
            break;
            
        case 'midMorning':
            message = `<strong>Good mid-morning!</strong> It's ${currentDate}.<br><br>`;
            
            if (totalDrinkAmount === 0) {
                message += "You haven't recorded any fluid intake yet today. Staying hydrated is important for bladder health. Aim for 1.5-2 liters throughout the day.";
            } else {
                message += `You've consumed <span class="insight-highlight">${totalDrinkAmount}ml</span> of fluids so far today. `;
                
                if (totalDrinkAmount < 500) {
                    message += "Consider drinking more water to stay properly hydrated.";
                } else {
                    message += "Great job staying hydrated this morning!";
                }
            }
            break;
            
        case 'afternoon':
            message = `<strong>Good afternoon!</strong> It's ${currentDate}.<br><br>`;
            
            if (urineCount === 0 && totalDrinkAmount === 0) {
                message += "No entries recorded yet today. Keeping track of your bladder habits helps establish healthy patterns.";
            } else {
                message += `Today's summary so far: ${urineCount} urination${urineCount !== 1 ? 's' : ''} and ${totalDrinkAmount}ml fluid intake. `;
                
                if (urineCount > 0 && totalDrinkAmount > 0) {
                    const ratio = Math.round((urineCount / (totalDrinkAmount / 250)) * 10) / 10;
                    
                    if (ratio > 2) {
                        message += `You're urinating <span class="insight-warning">more frequently</span> relative to your fluid intake. This could indicate bladder irritability.`;
                    } else if (ratio < 0.5 && totalDrinkAmount > 1000) {
                        message += `You're urinating <span class="insight-warning">less frequently</span> than expected for your fluid intake. Remember not to hold too long.`;
                    } else {
                        message += `Your urination frequency seems appropriate for your fluid intake.`;
                    }
                }
            }
            break;
            
        case 'lateAfternoon':
            message = `<strong>Good late afternoon!</strong> It's ${currentDate}.<br><br>`;
            
            if (highUrgencyCount > 0) {
                message += `You've experienced <span class="insight-warning">${highUrgencyCount}</span> episode${highUrgencyCount !== 1 ? 's' : ''} of moderate to severe urgency today. `;
                
                if (highUrgencyCount > 2) {
                    message += "Try spacing out your fluid intake more evenly and consider reducing bladder irritants like caffeine or alcohol.";
                } else {
                    message += "Keep tracking to identify potential triggers.";
                }
            } else if (urineCount > 0) {
                message += "You haven't recorded any episodes of high urgency today - that's excellent! ";
                
                if (timeSinceLastUrination !== null) {
                    if (timeSinceLastUrination > 4) {
                        message += `It's been <span class="insight-warning">${timeSinceLastUrination}</span> hours since your last urination. Remember to go at regular intervals.`;
                    } else if (timeSinceLastUrination > 2) {
                        message += `It's been about ${timeSinceLastUrination} hours since your last urination. That's a healthy interval.`;
                    }
                }
            } else {
                message += "Remember to log your bladder events to receive more personalized insights.";
            }
            break;
            
        case 'evening':
            message = `<strong>Good evening!</strong> It's ${currentDate}.<br><br>`;
            
            if (totalDrinkAmount > 0 || urineCount > 0) {
                message += `Today's summary: ${urineCount} urination${urineCount !== 1 ? 's' : ''} and ${totalDrinkAmount}ml fluid intake. `;
                
                if (totalDrinkAmount > 2000) {
                    message += `You've had <span class="insight-highlight">plenty of fluids</span> today. `;
                    message += "Consider reducing fluids 2-3 hours before bedtime for better sleep.";
                } else if (totalDrinkAmount < 1000 && totalDrinkAmount > 0) {
                    message += `Your fluid intake is <span class="insight-warning">lower than recommended</span>. `;
                    message += "Try to increase your water consumption earlier in the day.";
                }
            } else {
                message += "No entries recorded today. Remember that consistent tracking provides the most valuable insights.";
            }
            break;
            
        case 'night':
            message = `<strong>Evening summary</strong> for ${currentDate}:<br><br>`;
            
            if (urineCount > 0 || totalDrinkAmount > 0) {
                message += `You recorded ${urineCount} urination${urineCount !== 1 ? 's' : ''} and consumed ${totalDrinkAmount}ml of fluids today. `;
                
                // Stream quality assessment
                const streamTypes = {};
                urineEntries.forEach(entry => {
                    if (entry.urineStream) {
                        streamTypes[entry.urineStream] = (streamTypes[entry.urineStream] || 0) + 1;
                    }
                });
                
                if (Object.keys(streamTypes).length > 0) {
                    const totalStreams = Object.values(streamTypes).reduce((a, b) => a + b, 0);
                    const weakPercentage = ((streamTypes['Weak'] || 0) / totalStreams) * 100;
                    
                    if (weakPercentage > 50) {
                        message += `<span class="insight-warning">Note:</span> The majority of your recorded urinations had a weak stream. `;
                        message += "This may be worth discussing with your healthcare provider.";
                    } else if (streamTypes['Strong'] && streamTypes['Strong'] / totalStreams > 0.7) {
                        message += `<span class="insight-success">Good news:</span> Most of your recorded urinations had a strong stream, which is a positive sign.`;
                    }
                }
            } else {
                message += "No entries were recorded today. Consistent tracking helps identify patterns in your bladder health.";
            }
            
            message += "<br><br>If you haven't already, consider logging your final urination before bed.";
            break;
            
        case 'lateNight':
            message = `<strong>Good night!</strong> It's the end of ${currentDate}.<br><br>`;
            
            if (urineCount > 0 || totalDrinkAmount > 0) {
                message += `Today's final tally: ${urineCount} urination${urineCount !== 1 ? 's' : ''} and ${totalDrinkAmount}ml fluid intake. `;
                
                // Provide sleeping advice
                if (totalDrinkAmount > 500 && new Date().getHours() >= 22) {
                    message += `You've consumed <span class="insight-warning">${totalDrinkAmount}ml</span> of fluids in the evening. `;
                    message += "If you find yourself waking up to urinate, consider reducing late evening fluids tomorrow.";
                } else {
                    message += "Get a good night's rest, and we'll continue tracking tomorrow.";
                }
            } else {
                message += "No entries were recorded today. Tomorrow's a new day to establish healthy bladder habits.";
            }
            break;
            
        default:
            message = `Hello! It's ${currentDate}.<br><br>`;
            message += "Keep tracking your bladder habits to receive personalized insights.";
    }
    
    // Display the message with a fade-in effect
    insightMessage.style.opacity = '0';
    setTimeout(() => {
        updateInsightMessage(message); // Use our new function instead of directly setting innerHTML
        insightMessage.style.transition = 'opacity 0.5s ease';
        insightMessage.style.opacity = '1';
    }, 300);
}



// Function for text streaming effect
function streamText(element, text, speed = 20) {
    // Start with empty text
    let currentText = '';
    let index = 0;
    
    // If there's a blinking cursor already, remove it
    const existingCursors = element.querySelectorAll('.streaming-cursor');
    existingCursors.forEach(cursor => cursor.remove());
    
    // Add blinking cursor
    const cursor = document.createElement('span');
    cursor.className = 'streaming-cursor';
    element.appendChild(cursor);
    
    // Slightly randomize the speed for natural feel
    const getRandomSpeed = () => speed + Math.random() * 20 - 10;
    
    // Stream the text character by character
    const streamNextChar = () => {
        if (index < text.length) {
            currentText += text.charAt(index);
            
            // Update the text before the cursor
            element.innerHTML = currentText;
            
            // Re-add the cursor
            element.appendChild(cursor);
            
            index++;
            
            // Random delay for next character to mimic natural typing
            const delay = getRandomSpeed();
            
            // Add slightly longer pauses at punctuation
            const char = text.charAt(index - 1);
            if (char === '.' || char === '!' || char === '?') {
                setTimeout(streamNextChar, delay * 5);
            } else if (char === ',' || char === ';' || char === ':') {
                setTimeout(streamNextChar, delay * 3);
            } else {
                setTimeout(streamNextChar, delay);
            }
        } else {
            // Remove cursor when done
            setTimeout(() => {
                cursor.remove();
            }, 500);
        }
    };
    
    // Start streaming
    streamNextChar();
}

// Function for elegant word-by-word fade-in effect
function fadeInWords(element, text, speed = 40) {
    // Clear existing content
    element.innerHTML = '';
    
    // Split text into words
    const words = text.split(' ');
    
    // Create a wrapper div to maintain proper text layout
    const wrapper = document.createElement('div');
    wrapper.style.width = '100%';
    element.appendChild(wrapper);
    
    // Create a span for each word and add it to the element
    words.forEach((word, index) => {
        // Create span for the word
        const wordSpan = document.createElement('span');
        wordSpan.className = 'fade-in-word';
        wordSpan.textContent = word;
        
        // Set a delay for each word to create a sequential fade-in effect
        wordSpan.style.animationDelay = `${index * speed}ms`;
        
        // Add the word span to the wrapper
        wrapper.appendChild(wordSpan);
        
        // Add a space after each word except the last one
        if (index < words.length - 1) {
            // Create a text node for the space to ensure proper rendering
            const space = document.createTextNode(' ');
            wrapper.appendChild(space);
        }
    });
}

// Enhanced generateAIInsight function with elegant fade-in
async function generateAIInsight(timeType, apiKey) {
    const motivationalContent = document.getElementById('motivationalContent');
    const insightMessage = document.getElementById('insightMessage');
    const loadingMessage = document.getElementById('loadingMessage');

    insightMessage.classList.add('insight-refreshing');

    try {
        // Get references to key elements
        const motivationalContent = document.getElementById('motivationalContent');
        const insightMessage = document.getElementById('insightMessage');
        
        // Apply subtle pulse animation to current content
        insightMessage.classList.add('insight-refreshing');
        
        // ⚠️ Loading indicator is managed by the parent function now

        // Get today's entries
        const today = new Date().toISOString().split('T')[0]; // YYYY-MM-DD
        const todayEntries = entries.filter(entry => entry.date === today);
        
        // Calculate data and prepare the prompt
        const timeTypeMap = {
            'morning': 'Good morning (5-9am)',
            'midMorning': 'Mid-morning (9am-12pm)',
            'afternoon': 'Good afternoon (12-3pm)',
            'lateAfternoon': 'Late afternoon (3-6pm)',
            'evening': 'Good evening (6-9pm)',
            'night': 'Night summary (9-11pm)',
            'lateNight': 'Good night (11pm-5am)'
        };
        
        const drinkEntries = todayEntries.filter(entry => entry.drinkAmount);
        const urineEntries = todayEntries.filter(entry => entry.urineVolume);
        
        const totalDrinkAmount = drinkEntries.reduce((sum, entry) => sum + parseInt(entry.drinkAmount || 0), 0);
        const urineCount = urineEntries.length;
        
        // Format the data for OpenAI
        const prompt = `Time of day: ${timeTypeMap[timeType]}
Date: ${new Date().toLocaleDateString('en-US', {weekday: 'long', month: 'long', day: 'numeric'})}

Today's bladder diary data:
- Urination events: ${urineCount}
- Total fluid intake: ${totalDrinkAmount}ml
- Drink entries: ${drinkEntries.map(e => `${e.time} - ${e.drinkType}: ${e.drinkAmount}ml`).join(', ')}
- Urination entries: ${urineEntries.map(e => `${e.time} - Duration: ${e.urineVolume}s, Urgency: ${e.urgency || 'Not recorded'}, Stream: ${e.urineStream || 'Not recorded'}`).join(', ')}

Based on this data, generate a brief, personalized insight message for the user's bladder diary app. The message should:
1. Begin with a time-appropriate greeting
2. Be about 2-3 sentences long
3. Include at least one piece of specific feedback or advice based on their data
4. Be encouraging and motivational
5. Use plain language that a patient would understand
6. Sound friendly and supportive, not clinical
7. If needed, mention that more data would help provide better insights

Respond only with the message text that should be shown to the user. No headers or additional explanation.`;

        // Make API request to OpenAI with proper timeout
        const controller = new AbortController();
        const timeoutId = setTimeout(() => controller.abort(), 10000); // 10-second timeout
        
        const response = await fetch('https://api.openai.com/v1/chat/completions', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
                'Authorization': `Bearer ${apiKey}`
            },
            body: JSON.stringify({
                model: "gpt-4o-mini",
                messages: [
                    {
                        role: "user",
                        content: prompt
                    }
                ],
                temperature: 0.7,
                max_tokens: 150
            }),
            signal: controller.signal
        });
        
        clearTimeout(timeoutId);
        
        if (!response.ok) {
            throw new Error(`API request failed with status ${response.status}`);
        }

        const data = await response.json();
        const aiMessage = data.choices[0].message.content.trim();

        insightMessage.classList.remove('insight-refreshing');
        motivationalContent.classList.add('insight-glow');
        updateInsightMessage(''); // Clear content first
        setTimeout(() => {
            fadeInWords(insightMessage, aiMessage, 40);
        }, 50);

        const wordCount = aiMessage.split(' ').length;
        const totalFadeTime = wordCount * 40 + 600;
        setTimeout(() => {
            motivationalContent.classList.remove('insight-glow');
        }, totalFadeTime);

    } catch (error) {
        console.error('Error generating AI insight:', error);
        insightMessage.classList.remove('insight-refreshing');
        if (loadingMessage) loadingMessage.classList.add('hidden');
        fadeInWords(insightMessage, `Unable to generate insight: ${error.message}. Please configure your API key in AI settings.`, 30);
    } finally {
        if (loadingMessage) loadingMessage.classList.add('hidden'); // Ensure spinner hides even if uncaught errors occur
    }
}


document.addEventListener('DOMContentLoaded', function() {
    // Fix for AI controls toggle
    const aiControlsToggle = document.getElementById('aiControlsToggle');
    const aiControlsMenu = document.getElementById('aiControlsMenu');
    
    if (aiControlsToggle && aiControlsMenu) {
        // Remove existing event listeners (if any)
        aiControlsToggle.replaceWith(aiControlsToggle.cloneNode(true));
        
        // Re-get the element after replacement
        const newToggle = document.getElementById('aiControlsToggle');
        
        // Add the event listener directly (not using setupAIControlsDropdown)
        newToggle.addEventListener('click', function(e) {
            console.log('AI controls toggle clicked');
            e.stopPropagation();
            const isExpanded = this.classList.toggle('expanded');
            aiControlsMenu.classList.toggle('expanded', isExpanded);
        });
    }
});
window.addEventListener('load', function() {
    console.log('Page fully loaded, initializing app components');
    
    // Hide loading message initially
    const loadingMessage = document.getElementById('loadingMessage');
    if (loadingMessage) {
        loadingMessage.classList.add('hidden');
    }
    
    // Ensure AI controls are set up properly
    setupAIControlsDropdown();
    
    // Generate initial insight with proper error handling
    try {
        generateInsight();
    } catch (e) {
        console.error('Error during initial insight generation:', e);
        // Make sure default message is shown if generation fails
        const insightMessage = document.getElementById('insightMessage');
        if (insightMessage) {
            insightMessage.innerHTML = 'Welcome to your Bladder Diary. Track your entries to receive personalized insights.';
        }
    }
});

// You might also want to add a subtle animation when the user clicks the refresh button
// Add this to your existing refreshInsightBtn event listener:

refreshInsightBtn.addEventListener('click', function() {
    generateInsight(true);
    
    // Add gradient pulse effect to the entire motivational section
    const motivationalSection = document.getElementById('motivationalSection');
    motivationalSection.classList.add('insight-glow');
    
    setTimeout(() => {
        motivationalSection.classList.remove('insight-glow');
    }, 2000);
    
    // Original rotation animation for the refresh icon
    refreshInsightBtn.querySelector('svg').style.transition = 'transform 0.5s ease';
    refreshInsightBtn.querySelector('svg').style.transform = 'rotate(360deg)';
    
    setTimeout(() => {
        refreshInsightBtn.querySelector('svg').style.transition = '';
        refreshInsightBtn.querySelector('svg').style.transform = '';
    }, 500);
});

// The issue might also be in the motivationalContent div structure
// Add this debugging code to run once to identify any structure issues:
function debugMotivationalContent() {
    console.log("Debugging motivational content structure:");
    
    const motivationalContent = document.getElementById('motivationalContent');
    if (motivationalContent) {
        console.log("Motivational content found:", motivationalContent);
        console.log("Children:", motivationalContent.children);
        
        const loadingMessage = document.getElementById('loadingMessage');
        if (loadingMessage) {
            console.log("Loading message found:", loadingMessage);
            console.log("Loading message classes:", loadingMessage.className);
            console.log("Loading message display style:", loadingMessage.style.display);
            console.log("Loading message computed style:", window.getComputedStyle(loadingMessage).display);
        } else {
            console.error("Loading message element not found by ID");
        }
        
        const insightMessage = document.getElementById('insightMessage');
        if (insightMessage) {
            console.log("Insight message found:", insightMessage);
            console.log("Insight message style:", insightMessage.style);
        } else {
            console.error("Insight message element not found by ID");
        }
    } else {
        console.error("Motivational content element not found");
    }
}

// Here's the improved version of the function that should create a smooth animation
function updateInsightMessage(newMessage) {
    const content = document.getElementById('motivationalContent');
    const messageElement = document.getElementById('insightMessage');

    // Step 1: Capture the current height and set it explicitly
    const currentHeight = content.scrollHeight;
    content.style.height = `${currentHeight}px`;
    
    // Step 2: Force a reflow to make sure the fixed height is applied
    void content.offsetHeight;
    
    // Step 3: Update the content
    messageElement.innerHTML = newMessage;
    
    // Step 4: Allow the browser to calculate the new content height
    // by putting this in the next animation frame
    requestAnimationFrame(() => {
        // Step 5: Set the new height to trigger transition
        const newHeight = messageElement.scrollHeight;
        content.style.height = `${newHeight}px`;
        
        // Step 6: Reset to auto height after transition completes
        setTimeout(() => {
            content.style.height = 'auto';
        }, 300); // Match transition duration
    });
}

// Run the debug function once
setTimeout(debugMotivationalContent, 1000);
        
        // Initialize app
entryForm.style.display = 'none';
exportArea.style.display = 'none';
setCurrentDateTime();

// Load entries first
loadEntries(); 

// Load AI settings
loadAiSettings();

// Generate initial insight
generateInsight();

// Only load sample data if no entries exist at all
if (entries.length === 0) {
    loadSampleData();
    showMessage("Sample data loaded for demonstration", "success");
}

// Call this function during initialization
addBackupButtons();
addLogoRefreshFunctionality();

// Modify the loadSampleData function to not call saveEntries automatically:
function loadSampleData() {
    entries = [
        {date: "2025-02-25", time: "19:36", urineVolume: "9", urgency: "2", urineStream: "Strong"},
        {date: "2025-02-25", time: "20:50", drinkType: "Water", drinkAmount: "250"},
        {date: "2025-02-25", time: "22:15", urineVolume: "9", urgency: "2", urineStream: "Intermittent"},
        {date: "2025-02-26", time: "07:05", urineVolume: "17", urgency: "2", urineStream: "Intermittent"},
        {date: "2025-02-26", time: "07:52", drinkType: "Water", drinkAmount: "250"},
        {date: "2025-02-26", time: "08:32", drinkType: "Tea", drinkAmount: "500"},
        {date: "2025-02-26", time: "09:24", drinkType: "Water", drinkAmount: "750"},
        {date: "2025-02-26", time: "09:56", urineVolume: "22", urgency: "1", urineStream: "Strong"},
        {date: "2025-02-26", time: "12:41", urineVolume: "25", urgency: "1", urineStream: "Intermittent"},
        {date: "2025-02-26", time: "12:51", drinkType: "Other", drinkAmount: "250"},
        {date: "2025-02-26", time: "13:41", drinkType: "Water", drinkAmount: "750"}
    ];
    
    // Mark these as sample data (optional)
    entries.forEach(entry => entry.isSampleData = true);
    
    // Now save to storage
    saveEntries();
    
    // Render entries to display
    renderEntries();
}

// Calculate average time between urinations per day
function calculateAverageTimeBetweenUrinations() {
    // Group urination entries by date
    const urinationsByDate = {};
    
    entries.forEach(entry => {
        if (entry.urineVolume) {  // Check if it's a urination entry
            // Only consider entries between 7am and 11pm
            const hour = parseInt(entry.time.split(':')[0]);
            if (hour >= 7 && hour <= 23) {
                if (!urinationsByDate[entry.date]) {
                    urinationsByDate[entry.date] = [];
                }
                // Store the time of urination
                urinationsByDate[entry.date].push(entry.time);
            }
        }
    });
    
    // Calculate average time between urinations for each date
    const avgTimeByDate = {};
    
    Object.entries(urinationsByDate).forEach(([date, times]) => {
        if (times.length <= 1) {
            // Need at least 2 urinations to calculate gap
            return;
        }
        
        // Sort times chronologically
        times.sort();
        
        // Calculate time differences in minutes
        let totalMinutes = 0;
        let gapCount = 0;
        
        for (let i = 1; i < times.length; i++) {
            const prevTime = times[i-1];
            const currTime = times[i];
            
            // Convert times to minutes since midnight
            const prevMinutes = (parseInt(prevTime.split(':')[0]) * 60) + parseInt(prevTime.split(':')[1]);
            const currMinutes = (parseInt(currTime.split(':')[0]) * 60) + parseInt(currTime.split(':')[1]);
            
            // Calculate difference
            const diffMinutes = currMinutes - prevMinutes;
            
            // Only count reasonable gaps (we already filtered for 8am-11pm entries)
            if (diffMinutes > 0) {
                totalMinutes += diffMinutes;
                gapCount++;
            }
        }
        
        // Calculate average if we have valid gaps
        if (gapCount > 0) {
            avgTimeByDate[date] = Math.round(totalMinutes / gapCount);
        }
    });
    
    return avgTimeByDate;
}

// Mobile-optimized Time Gap Chart function
function renderTimeGapChart() {
    try {
        const canvas = document.getElementById('timeGapCanvas');
        if (!canvas) return;
        
        setCanvasDimensions(canvas);
        clearCanvas(canvas);
        
        // Get average time between urinations by date
        const avgTimeByDate = calculateAverageTimeBetweenUrinations();
        
        // If we don't have data, show empty state
        if (Object.keys(avgTimeByDate).length === 0) {
            drawEmptyState(canvas, 'Not enough urination data to calculate time gaps');
            return;
        }
        
        // Convert to array and sort by date
        const timeData = Object.entries(avgTimeByDate)
            .sort(([dateA], [dateB]) => dateA.localeCompare(dateB))
            .slice(-7);  // Show last 7 days with data
        
        const ctx = canvas.getContext('2d');
        const width = canvas.width;
        const height = canvas.height;
        
        // Detect if we're on a small screen (like mobile)
        const isMobile = width < 400;
        
        // Adjust padding based on screen size
        const padding = {
            top: 30,
            right: isMobile ? 10 : 20, 
            bottom: isMobile ? 70 : 40,
            left: isMobile ? 40 : 50
        };
        
        const chartWidth = width - padding.left - padding.right;
        const chartHeight = height - padding.top - padding.bottom;
        
        // Draw background
        ctx.fillStyle = '#f8f9fa';
        ctx.fillRect(0, 0, width, height);
        
        // Find the maximum average time for scaling
        let maxAvgTime = Math.max(...timeData.map(([, time]) => time));
        
        // Define golden window values
        const goldenMinLower = 180; // 3 hours = 180 minutes
        const goldenMinUpper = 240; // 4 hours = 240 minutes
        
        // IMPORTANT CHANGE: Always ensure the scale goes to at least 5 hours (300 minutes)
        // This ensures the golden window (3-4h) plus some space above it is always visible
        const minScaleValue = 300; // 5 hours for motivation
        maxAvgTime = Math.max(maxAvgTime, minScaleValue);
        
        // If data has values below 45 minutes, we need to show them
        // Otherwise start y-axis at 45 minutes to focus on the important range
        let minDisplayValue = 0;
        const minRecordedValue = Math.min(...timeData.map(([, time]) => time));
        
        // Only adjust min display value if no low values exist in data
        if (minRecordedValue > 45) {
            minDisplayValue = 45; // Start at 45 minutes if no lower values exist
        }
        
        // Effective chart range (for calculating positions)
        const effectiveRange = maxAvgTime - minDisplayValue;
        
        // Draw horizontal grid lines and y-axis
        ctx.strokeStyle = '#e2e8f0';
        ctx.lineWidth = 1;
        
        // Mobile-optimized grid lines - draw fewer on small screens
        const gridLines = isMobile ? 4 : 6;
        
        for (let i = 0; i <= gridLines; i++) {
            // Calculate actual minutes value for this grid line
            const minutes = Math.round(minDisplayValue + (i / gridLines) * effectiveRange);
            
            // Calculate y position
            const y = padding.top + chartHeight - ((minutes - minDisplayValue) / effectiveRange) * chartHeight;
            
            ctx.beginPath();
            ctx.moveTo(padding.left, y);
            ctx.lineTo(width - padding.right, y);
            ctx.stroke();
            
            // Draw y-axis labels (convert minutes to hours and minutes)
            const hours = Math.floor(minutes / 60);
            const mins = minutes % 60;
            // Mobile-optimized labels
            const timeLabel = hours > 0 ? 
                (isMobile ? `${hours}h ${mins > 0 ? mins + 'm' : ''}` : `${hours}h ${mins}m`) :
                `${mins}m`;
            
            ctx.fillStyle = '#718096';
            // Smaller font on mobile
            ctx.font = isMobile ? '9px sans-serif' : '10px sans-serif';
            ctx.textAlign = 'right';
            ctx.textBaseline = 'middle';
            ctx.fillText(timeLabel, padding.left - 5, y);
        }
        
        // Create gradient for area under the line
        const gradient = ctx.createLinearGradient(0, padding.top, 0, height - padding.bottom);
        gradient.addColorStop(0, 'rgba(166, 81, 230, 0.2)'); // Similar to app's purple color
        gradient.addColorStop(1, 'rgba(166, 81, 230, 0.0)');
        
        // Calculate point width for data plotting
        const pointWidth = chartWidth / (timeData.length > 1 ? timeData.length - 1 : 1);
        
        // Draw area under the line
        ctx.beginPath();
        timeData.forEach(([date, avgTime], index) => {
            const x = padding.left + index * pointWidth;
            const y = padding.top + chartHeight - ((avgTime - minDisplayValue) / effectiveRange) * chartHeight;
            
            if (index === 0) {
                ctx.moveTo(x, y);
            } else {
                ctx.lineTo(x, y);
            }
        });
        
        // Complete the area path
        ctx.lineTo(padding.left + (timeData.length - 1) * pointWidth, height - padding.bottom);
        ctx.lineTo(padding.left, height - padding.bottom);
        ctx.closePath();
        ctx.fillStyle = gradient;
        ctx.fill();
        
        // Draw the line
        ctx.beginPath();
        ctx.strokeStyle = '#a651e6'; // Using the app's purple color
        ctx.lineWidth = 2.5;
        
        timeData.forEach(([date, avgTime], index) => {
            const x = padding.left + index * pointWidth;
            const y = padding.top + chartHeight - ((avgTime - minDisplayValue) / effectiveRange) * chartHeight;
            
            if (index === 0) {
                ctx.moveTo(x, y);
            } else {
                ctx.lineTo(x, y);
            }
            
            // Draw x-axis labels with mobile optimization
            ctx.fillStyle = '#718096';
            // Smaller font on mobile
            ctx.font = isMobile ? '9px sans-serif' : '10px sans-serif';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'top';
            
            // Format dates differently for mobile
            let displayDate;
            if (isMobile) {
                // Show minimal date format on mobile ("25" instead of "Feb 25")
                const dateParts = date.split('-');
                const day = parseInt(dateParts[2]);
                displayDate = `${day}`;
            } else {
                displayDate = formatDate(date);
            }
            
            ctx.save();
            // Position labels farther from axis on mobile
            const labelY = height - padding.bottom + (isMobile ? 8 : 5);
            ctx.translate(x, labelY);
            // More rotation on mobile to prevent overlap
            ctx.rotate(isMobile ? -Math.PI / 3 : -Math.PI / 4);
            ctx.fillText(displayDate, 0, 0);
            ctx.restore();
        });
        
        ctx.stroke();
        
        // Add month labels for mobile displays
        if (isMobile && timeData.length > 0) {
            // Add month labels above the day numbers
            timeData.forEach(([date], index) => {
                const dateParts = date.split('-');
                const monthIndex = parseInt(dateParts[1]) - 1; // 0-based month
                const months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];
                
                // Only show month for first day of month or first data point
                if (index === 0 || dateParts[2] === '01') {
                    const x = padding.left + index * pointWidth;
                    ctx.fillStyle = '#a0aec0'; // Lighter color for month
                    ctx.font = '8px sans-serif'; // Smaller than day
                    ctx.textAlign = 'center';
                    ctx.fillText(months[monthIndex], x, height - padding.bottom + 20);
                }
            });
        }
        
        // Draw data points and values
        timeData.forEach(([date, avgTime], index) => {
            const x = padding.left + index * pointWidth;
            const y = padding.top + chartHeight - ((avgTime - minDisplayValue) / effectiveRange) * chartHeight;
            
            // Draw point with gradient circle
            const pointGradient = ctx.createRadialGradient(x, y, 0, x, y, 6);
            pointGradient.addColorStop(0, '#a651e6');
            pointGradient.addColorStop(1, '#4f9cf9');
            
            ctx.beginPath();
            // Smaller points on mobile
            const pointRadius = isMobile ? 5 : 6;
            ctx.arc(x, y, pointRadius, 0, Math.PI * 2);
            ctx.fillStyle = pointGradient;
            ctx.fill();
            ctx.strokeStyle = 'white';
            ctx.lineWidth = 2;
            ctx.stroke();
            
            // Draw time value with nicer formatting
            const hours = Math.floor(avgTime / 60);
            const mins = Math.round(avgTime % 60);
            
            // Mobile-optimized time label
            const timeLabel = isMobile ? 
                `${hours}h ${mins > 0 ? mins + 'm' : ''}` :
                `${hours}h ${mins}m`;
            
            // Draw with small shadow for better readability
            ctx.fillStyle = '#4a5568';
            ctx.font = isMobile ? 'bold 9px sans-serif' : 'bold 10px sans-serif';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'bottom';
            ctx.fillText(timeLabel, x, y - (isMobile ? 8 : 10));
        });
        
        // Always show the golden window (3-4 hours or 180-240 minutes)
        // Calculate y positions for the golden window using the new scaling
        const goldenLowerY = padding.top + chartHeight - ((goldenMinLower - minDisplayValue) / effectiveRange) * chartHeight;
        const goldenUpperY = padding.top + chartHeight - ((goldenMinUpper - minDisplayValue) / effectiveRange) * chartHeight;
        
        // Draw the golden window zone with more transparency on mobile
        ctx.fillStyle = isMobile ? 'rgba(249, 199, 79, 0.10)' : 'rgba(249, 199, 79, 0.15)';
        ctx.fillRect(padding.left, goldenUpperY, chartWidth, goldenLowerY - goldenUpperY);
        
        // Add a subtle border
        ctx.strokeStyle = 'rgba(249, 199, 79, 0.5)';
        ctx.setLineDash([3, 3]);
        ctx.lineWidth = 1;
        
        // Upper line
        ctx.beginPath();
        ctx.moveTo(padding.left, goldenUpperY);
        ctx.lineTo(padding.left + chartWidth, goldenUpperY);
        ctx.stroke();
        
        // Lower line
        ctx.beginPath();
        ctx.moveTo(padding.left, goldenLowerY);
        ctx.lineTo(padding.left + chartWidth, goldenLowerY);
        ctx.stroke();
        
        // Reset line dash
        ctx.setLineDash([]);
        
        // Label for golden window - position in upper part for mobile
        ctx.fillStyle = 'rgba(249, 151, 79, 0.8)';
        ctx.font = isMobile ? 'bold 9px sans-serif' : 'bold 10px sans-serif';
        ctx.textAlign = 'left';
        ctx.textBaseline = 'middle';
        
        // Position label higher in the window on mobile
        const labelY = isMobile ? 
            (goldenUpperY + (goldenLowerY - goldenUpperY) * 0.3) : 
            ((goldenUpperY + goldenLowerY) / 2);
            
        ctx.fillText(
            isMobile ? 'Golden Window (3-4h)' : 'Golden Window (3-4h)',
            padding.left + 5, 
            labelY
        );
        
        // Calculate and draw trend line
        if (timeData.length >= 2) {
            // Simple linear regression
            let sumX = 0, sumY = 0, sumXY = 0, sumXX = 0;
            const n = timeData.length;
            
            timeData.forEach(([, avgTime], index) => {
                sumX += index;
                sumY += avgTime;
                sumXY += index * avgTime;
                sumXX += index * index;
            });
            
            const slope = (n * sumXY - sumX * sumY) / (n * sumXX - sumX * sumX);
            const intercept = (sumY - slope * sumX) / n;
            
            // Calculate start and end points for trend line
            const startX = padding.left;
            const startY = padding.top + chartHeight - ((intercept - minDisplayValue) / effectiveRange) * chartHeight;
            
            const endX = padding.left + (timeData.length - 1) * pointWidth;
            const endY = padding.top + chartHeight - ((intercept + slope * (timeData.length - 1) - minDisplayValue) / effectiveRange) * chartHeight;
            
            // Draw trend line
            ctx.beginPath();
            ctx.moveTo(startX, startY);
            ctx.lineTo(endX, endY);
            ctx.strokeStyle = slope > 0 ? '#22c55e' : '#e53e3e'; // Green if increasing, red if decreasing
            ctx.lineWidth = 2;
            ctx.setLineDash([5, 3]);
            ctx.stroke();
            ctx.setLineDash([]);
            
            // Determine trend direction relative to golden window
            let trendMessage = '';
            let trendColor = '';
            let trendIcon = '';
            
            // Get the latest average time
            const latestAvgTime = timeData[timeData.length - 1][1];
            
            if (slope > 0) {
                // Time between urinations is increasing
                if (latestAvgTime < goldenMinLower) {
                    trendMessage = isMobile ? 'Trending toward golden window' : 'Trending toward golden window';
                    trendColor = '#22c55e'; // Green (good)
                    trendIcon = '👍';
                } else if (latestAvgTime > goldenMinUpper) {
                    trendMessage = isMobile ? 'Trending away from golden window' : 'Trending away from golden window';
                    trendColor = '#e53e3e'; // Red (bad)
                    trendIcon = '👎';
                } else {
                    trendMessage = isMobile ? 'Trending toward longer intervals' : 'Trending toward longer intervals';
                    trendColor = '#eab308'; // Yellow (neutral)
                    trendIcon = '➡️';
                }
            } else {
                // Time between urinations is decreasing
                if (latestAvgTime > goldenMinUpper) {
                    trendMessage = isMobile ? 'Trending toward golden window' : 'Trending toward golden window';
                    trendColor = '#22c55e'; // Green (good)
                    trendIcon = '👍';
                } else if (latestAvgTime < goldenMinLower) {
                    trendMessage = isMobile ? 'Trending away from golden window' : 'Trending away from golden window';
                    trendColor = '#e53e3e'; // Red (bad)
                    trendIcon = '👎';
                } else {
                    trendMessage = isMobile ? 'Trending toward shorter intervals' : 'Trending toward shorter intervals';
                    trendColor = '#eab308'; // Yellow (neutral)
                    trendIcon = '➡️';
                }
            }
            
            // Draw trend message - Position HIGHER for mobile
            ctx.fillStyle = trendColor;
            // Smaller font on mobile
            ctx.font = isMobile ? 'bold 11px sans-serif' : 'bold 12px sans-serif';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'top';
            
            // Draw message well ABOVE the x-axis labels on mobile
            const messageY = height - padding.bottom + (isMobile ? 32 : 22);
            
            ctx.fillText(
                `${trendIcon} ${trendMessage}`,
                width / 2,
                messageY
            );
        }
        
        // Draw an improved note about the data with clearer explanation
        ctx.fillStyle = '#718096';
        // Smaller font on mobile
        ctx.font = isMobile ? 'italic 8px sans-serif' : 'italic 10px sans-serif';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'top';

        // Position well below the trend message on mobile
        const noteY = height - padding.bottom + (isMobile ? 48 : 42);

        ctx.fillText(
            '* Only includes urinations between 7am and 11pm',
            width / 2,
            noteY
        );
                
    } catch (error) {
        console.error('Error rendering time gap chart', error);
        const canvas = document.getElementById('timeGapCanvas');
        if (canvas) {
            drawEmptyState(canvas, 'Could not generate chart');
        }
    }
}

// Additional helper function for chart height optimization
function optimizeChartContainers() {
    // Make sure all chart containers have proper height on mobile
    const isMobile = window.innerWidth < 480;
    const charts = document.querySelectorAll('.chart-container');
    
    charts.forEach(chart => {
        // Find the specific chart
        if (chart.querySelector('#timeGapChart')) {
            // Set appropriate height for the time gap chart
            const timeGapChart = chart.querySelector('#timeGapChart');
            timeGapChart.style.height = isMobile ? '300px' : '220px';
        }
        
        // Optimize frequency chart height
        if (chart.querySelector('#frequencyChart')) {
            const frequencyChart = chart.querySelector('#frequencyChart');
            frequencyChart.style.height = isMobile ? '280px' : '220px';
        }
        
        // Optimize urgency chart height
        if (chart.querySelector('#urgencyChart')) {
            const urgencyChart = chart.querySelector('#urgencyChart');
            urgencyChart.style.height = isMobile ? '280px' : '220px';
        }
        
        // Optimize correlation chart height
        if (chart.querySelector('#correlationChart')) {
            const correlationChart = chart.querySelector('#correlationChart');
            correlationChart.style.height = isMobile ? '280px' : '220px';
        }
        
        // Optimize stream chart height
        if (chart.querySelector('#streamChart')) {
            const streamChart = chart.querySelector('#streamChart');
            streamChart.style.height = isMobile ? '320px' : '350px';
        }
    });
}

// Add optimizeChartContainers function to dynamically set chart heights
function optimizeChartContainers() {
    // Make sure all chart containers have proper height on mobile
    const isMobile = window.innerWidth < 480;
    const charts = document.querySelectorAll('.chart-container');
    
    charts.forEach(chart => {
        // Find the specific chart
        if (chart.querySelector('#timeGapChart')) {
            // Set appropriate height for the time gap chart
            const timeGapChart = chart.querySelector('#timeGapChart');
            timeGapChart.style.height = isMobile ? '300px' : '220px';
        }
        
        // Optimize frequency chart height
        if (chart.querySelector('#frequencyChart')) {
            const frequencyChart = chart.querySelector('#frequencyChart');
            frequencyChart.style.height = isMobile ? '280px' : '220px';
        }
        
        // Optimize urgency chart height
        if (chart.querySelector('#urgencyChart')) {
            const urgencyChart = chart.querySelector('#urgencyChart');
            urgencyChart.style.height = isMobile ? '280px' : '220px';
        }
        
        // Optimize correlation chart height
        if (chart.querySelector('#correlationChart')) {
            const correlationChart = chart.querySelector('#correlationChart');
            correlationChart.style.height = isMobile ? '280px' : '220px';
        }
        
        // Optimize stream chart height
        if (chart.querySelector('#streamChart')) {
            const streamChart = chart.querySelector('#streamChart');
            streamChart.style.height = isMobile ? '320px' : '350px';
        }
    });
}

// Call this function on page load and window resize
window.addEventListener('load', optimizeChartContainers);
window.addEventListener('resize', optimizeChartContainers);

// Setup the AI controls dropdown
function setupAIControlsDropdown() {
    const aiControlsToggle = document.getElementById('aiControlsToggle');
    const aiControlsMenu = document.getElementById('aiControlsMenu');
    const refreshInsightBtn = document.getElementById('refreshInsightBtn');
    const toggleAiSettings = document.getElementById('toggleAiSettings');
    
    if (!aiControlsToggle || !aiControlsMenu || !refreshInsightBtn || !toggleAiSettings) {
        console.error("Could not find all required elements for AI controls");
        return;
    }
    
    // Toggle dropdown when clicking the toggle button
    aiControlsToggle.addEventListener('click', function(e) {
        e.stopPropagation(); // Prevent document click from immediately closing it
        const isExpanded = this.classList.toggle('expanded');
        aiControlsMenu.classList.toggle('expanded', isExpanded);
    });
    
    // Handle the refresh insight button click
    refreshInsightBtn.addEventListener('click', function(e) {
        e.stopPropagation(); // Prevent document click handler
        generateInsight(true); // Generate a new insight
        
        // Add subtle rotation animation
        const svgIcon = this.querySelector('svg');
        if (svgIcon) {
            svgIcon.style.transition = 'transform 0.5s ease';
            svgIcon.style.transform = 'rotate(360deg)';
            setTimeout(() => {
                svgIcon.style.transition = '';
                svgIcon.style.transform = '';
            }, 500);
        }
        
        // Close the dropdown
        aiControlsToggle.classList.remove('expanded');
        aiControlsMenu.classList.remove('expanded');
    });
    
    // Handle the AI settings button click
    toggleAiSettings.addEventListener('click', function(e) {
        e.stopPropagation(); // Prevent document click handler
        
        // Close the dropdown
        aiControlsToggle.classList.remove('expanded');
        aiControlsMenu.classList.remove('expanded');
        
        // Show the settings panel - assuming aiSettingsPanel is the ID of your settings panel
        const aiSettingsPanel = document.getElementById('aiSettingsPanel');
        if (aiSettingsPanel) {
            aiSettingsPanel.classList.remove('hidden');
        }
    });
    
    // Close dropdown when clicking outside
    document.addEventListener('click', function(event) {
        if (aiControlsMenu.classList.contains('expanded')) {
            aiControlsToggle.classList.remove('expanded');
            aiControlsMenu.classList.remove('expanded');
        }
    });
}

// Call this function after the DOM is loaded
document.addEventListener('DOMContentLoaded', setupAIControlsDropdown);

// Also call it now in case the DOM is already loaded
setupAIControlsDropdown();



// Fix for the loading spinner issue

// 1. Add this style fix to make sure .hidden works correctly
const fixStyle = document.createElement('style');
fixStyle.textContent = `
  /* Fix for loading spinner visibility */
  #loadingMessage.hidden {
    display: none !important;
    opacity: 0 !important; 
    visibility: hidden !important;
  }
`;
document.head.appendChild(fixStyle);

// 2. Helper functions to properly show and hide the spinner
function showLoadingSpinner() {
  const spinner = document.getElementById('loadingMessage');
  if (spinner) {
    spinner.classList.remove('hidden');
    spinner.style.display = 'flex';
  }
}

function hideLoadingSpinner() {
  const spinner = document.getElementById('loadingMessage');
  if (spinner) {
    spinner.classList.add('hidden');
    spinner.style.display = 'none';
  }
}

// 3. Replacement generateInsight function
function generateInsight(forceRefresh = false) {
  // Always hide spinner at the start to reset state
  hideLoadingSpinner();
  
  try {
    console.log('Starting insight generation...');
    
    const currentType = getInsightType();
    const currentTime = new Date().getTime();
    const timeDiff = lastInsightTime ? (currentTime - lastInsightTime) / (1000 * 60 * 60) : 24;
    
    // Use cached insight if appropriate
    if (!forceRefresh && lastInsightTime && timeDiff < 1 && currentType === lastInsightType) {
      console.log('Using cached insight (still fresh)');
      return;
    }
    
    // Show spinner only for forced refresh
    if (forceRefresh) {
      showLoadingSpinner();
    }
    
    // Set a failsafe timer to hide spinner after 3 seconds no matter what
    const failsafeTimer = setTimeout(hideLoadingSpinner, 3000);
    
    // Get AI settings
    let aiSettings = { useOpenAI: false };
    if (localStorageAvailable) {
      try {
        const settingsStr = localStorage.getItem('bladderDiaryAiSettings');
        if (settingsStr) {
          aiSettings = JSON.parse(settingsStr);
        }
      } catch (error) {
        console.error('Error reading AI settings:', error);
      }
    }
    
    // Choose insight generation method
    if (aiSettings.useOpenAI && aiSettings.openaiKey && aiSettings.openaiKey.trim().length > 20) {
      // Use AI insight with proper error handling
      generateAIInsight(currentType, aiSettings.openaiKey)
        .catch(error => {
          console.error('AI insight failed:', error);
          generateSimpleInsight(currentType);
        })
        .finally(() => {
          hideLoadingSpinner();
          clearTimeout(failsafeTimer);
        });
    } else {
      // Use simple insight
      generateSimpleInsight(currentType);
      hideLoadingSpinner();
      clearTimeout(failsafeTimer);
    }
    
    // Update tracking state
    lastInsightTime = currentTime;
    lastInsightType = currentType;
  } catch (error) {
    console.error('Error generating insight:', error);
    hideLoadingSpinner();
    
    // Show error message
    const insightMessage = document.getElementById('insightMessage');
    if (insightMessage) {
      insightMessage.innerHTML = 'Unable to generate insight. Please try again.';
    }
  }
}

// 4. Make the spinner invisible immediately
hideLoadingSpinner();

// Once the page is fully loaded, ensure our changes are applied
window.addEventListener('load', function() {
  // Replace the original function
  window.generateInsight = generateInsight;
  
  // Make sure spinner is hidden
  hideLoadingSpinner();
  
  // Refresh insight with the new function
  setTimeout(generateInsight, 500);
});
    </script>

<script>
    document.getElementById('aiControlsToggle').onclick = function(e) {
      e.stopPropagation();
      document.getElementById('aiControlsMenu').classList.toggle('expanded');
      this.classList.toggle('expanded');
    };
  </script>    



</body>
</html>
