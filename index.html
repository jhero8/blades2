<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black">
    <meta name="apple-mobile-web-app-title" content="Bladder Diary">
    <title>Bladder Diary</title>
    <style>
        /* Basic reset */
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
        }
        
        body {
            background: linear-gradient(to bottom right, #f0f8ff, #f7f7f7);
            color:  #2d3748;
            line-height: 1.8;
            padding: 16px;
            max-width: 500px;
            margin: 0 auto;
            overflow-x: hidden; /* Prevent horizontal scrolling */
        }
        
        /* Header styles */
        header {
            text-align: center;
            margin-bottom: 16px;
        }
        
        .app-logo {
            width: 64px;
            height: 64px;
            border-radius: 50%;
            background: linear-gradient(135deg, #4f9cf9, #a651e6, #f9c74f);
            margin: 0 auto 12px;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .app-logo-inner {
            width: 56px;
            height: 56px;
            border-radius: 50%;
            background: white;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .app-logo-core {
            width: 48px;
            height: 48px;
            border-radius: 50%;
            background: linear-gradient(135deg, #4f9cf9, #a651e6, #f9c74f);
            opacity: 0.8;
        }
        
        h1 {
            font-size: 24px;
            color: #333;
            margin-bottom: 4px;
        }
        
        .subtitle {
            font-size: 14px;
            color: #666;
        }
        
        /* Privacy notice */
        .privacy-notice {
            text-align: center;
            font-size: 12px;
            color: #718096;
            background-color: rgba(237, 242, 247, 0.7);
            border-radius: 8px;
            padding: 8px 12px;
            margin-bottom: 16px;
            line-height: 1.4;
        }
        
        .privacy-notice svg {
            width: 14px;
            height: 14px;
            vertical-align: middle;
            margin-right: 4px;
        }
        .btn:hover, .card:hover {
    box-shadow: 0 8px 16px rgba(0,0,0,0.1);
}
        /* Button styles */
        .btn {
            display: block;
            width: 100%;
            padding: 12px;
            border-radius: 8px;
            border: none;
            font-weight: 500;
            cursor: pointer;
            text-align: center;
            margin-bottom: 16px;
            font-size: 16px;
            box-shadow: 0 4px 8px rgba(0,0,0,0.05);
    transition: box-shadow 0.2s ease;
        }
        
        .btn-primary {
            background-color: #5a67d8;
            color: white;
        }
        
        .btn-primary:hover {
            background-color: #4c51bf;
        }
        
        .btn-success {
            background-color: #48bb78;
            color: white;
        }
        
        .btn-success:hover {
            background-color: #38a169;
        }
        
        .btn-danger {
            background-color: #e53e3e;
            color: white;
            padding: 8px 12px;
            border-radius: 4px;
            font-size: 14px;
            display: inline-block;
            width: auto;
            margin-bottom: 0;
        }
        
        .btn-secondary {
            background-color: #4299e1;
            color: white;
            padding: 8px 16px;
            font-size: 14px;
            margin: 8px 0;
            display: inline-block;
        }
        
        /* Timer button styles */
        .timer-btn {
            background-color: #4299e1;
            color: white;
            padding: 8px 12px;
            border-radius: 4px;
            border: none;
            font-size: 14px;
            cursor: pointer;
            display: inline-flex;
            align-items: center;
            margin-left: 8px;
        }
        
        .timer-btn.active {
            background-color: #e53e3e;
            animation: pulseBorder 1s infinite;
        }
        @keyframes pulseBorder {
    0%, 100% { box-shadow: 0 0 0 2px #e53e3e; }
    50% { box-shadow: 0 0 0 6px rgba(229,62,62,0.5); }
}
        
        .timer-btn svg {
            margin-right: 4px;
            width: 14px;
            height: 14px;
        }
        
        /* Timer indicator */
        .timer-indicator {
            display: inline-block;
            margin-left: 8px;
            font-size: 14px;
            font-weight: 500;
            color: #e53e3e;
        }
        
        /* Timer field container */
        .timer-field-container {
            display: flex;
            align-items: center;
        }
        
        /* Form styles */
        .form {
            background-color: white;
            padding: 16px;
            border-radius: 8px;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
            margin-bottom: 24px;
        }
        
        .form.hidden {
            display: none;
        }
        
        .form-group {
            margin-bottom: 16px;
        }
        
        .form-group.grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 12px;
        }
        
        .form-label {
            display: block;
            font-size: 14px;
            font-weight: 500;
            margin-bottom: 4px;
            color: #4a5568;
        }
        
        .form-control {
            display: block;
            width: 100%;
            padding: 8px;
            border: 1px solid #e2e8f0;
            border-radius: 4px;
            font-size: 16px;
            box-shadow: 0 4px 8px rgba(0,0,0,0.05);
    transition: box-shadow 0.2s ease;
        }
        
        .form-control:focus {
            border-color: #a0aec0;
            outline: none;
        }
        
        .form-check {
            display: flex;
            align-items: center;
        }
        
        .form-check-input {
            margin-right: 8px;
        }
        
        .section-header {
            font-size: 16px;
            font-weight: 500;
            color: #4a5568;
            margin-bottom: 8px;
            padding-top: 8px;
            border-top: 1px solid #e2e8f0;
        }
        
        /* Entries list */
        .card {
            background-color: white;
            border-radius: 8px;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
            overflow: hidden;
            margin-bottom: 16px;
            box-shadow: 0 4px 8px rgba(0,0,0,0.05);
    transition: box-shadow 0.2s ease;
        }
        
        .card-header {
            background-color: #f8fafc;
            padding: 12px 16px;
            border-bottom: 1px solid #e2e8f0;
        }
        
        .card-title {
            font-size: 18px;
            font-weight: 500;
            color: #4a5568;
        }
        
        .card-body {
            padding: 16px;
        }
        @keyframes fadeInUp {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
}
.entry-item {
    padding: 12px 16px; /* Reduced from 16px all around */
    border-bottom: 1px solid #e2e8f0;
    animation: fadeInUp 0.3s ease;
    transition: background-color 0.2s;
    margin-top: 1px;
    margin-bottom: 1px; /* Reduced from 4px */
    border-radius: 4px;
}

.entry-item:hover {
    background-color: #f7fafc;
}

.entry-time {
    font-weight: 600;
    line-height: 1.5;
    padding-left: 0; /* Remove any left padding */
    margin-left: 0; /* Remove any left margin */
    color: #2d3748;
    font-size: 15px; /* Increased from default */
    display: flex;
    align-items: center;
}

.urgency-0 {
    color: #48bb78; /* Green */
}
.urgency-1 {
    color: #4299e1; /* Blue */
}
.urgency-2 {
    color: #ecc94b; /* Yellow */
}
.urgency-3 {
    color: #f56565; /* Red */
}

.stream-strong {
    color: #48bb78; /* Green */
    font-weight: 600;
}
.stream-intermittent {
    color: #ecc94b; /* Yellow */
    font-weight: 600;
}
.stream-weak {
    color: #f56565; /* Red */
    font-weight: 600;
}
        
        .entry-header {
            display: flex;
            justify-content: space-between;
            margin-bottom: 6px;
            align-items: center;
        }
        
        .entry-date {
    display: flex;
    align-items: center;
}
        
.entry-details {
    display: grid;
    grid-template-columns: auto 1fr;
    gap: 4px 12px; /* Horizontal gap between label and value */
    font-size: 14px;
    line-height: 1.5;
    margin-top: 4px;
}
        
.entry-label {
    font-weight: 600;
    color: #718096;
}

.entry-label, .entry-details div {
    display: flex;
    align-items: center;
}
        
        .no-entries {
            text-align: center;
            color: #a0aec0;
            padding: 24px;
        }
        
        /* Message styles */
        .message {
            padding: 12px;
            border-radius: 4px;
            margin-bottom: 16px;
        }
        
        .message-danger {
            background-color: #fed7d7;
            border: 1px solid #feb2b2;
            color: #c53030;
        }
        
        .message-success {
            background-color: #c6f6d5;
            border: 1px solid #9ae6b4;
            color: #2f855a;
        }
        
        .hidden {
            display: none;
        }
        
        /* Export section */
        .export-section {
            margin-top: 24px;
            margin-bottom: 32px;
        }
        
        .export-textarea {
            width: 100%;
            height: 200px;
            padding: 8px;
            border: 1px solid #e2e8f0;
            border-radius: 4px;
            font-family: monospace;
            margin-bottom: 8px;
            display: none;
        }
        
        .helper-text {
            font-size: 12px;
            color: #718096;
            margin-top: 8px;
        }
        
        /* Storage warning */
        .storage-warning {
            background-color: #feebc8;
            border: 1px solid #f6ad55;
            color: #c05621;
            border-radius: 4px;
            padding: 8px 12px;
            margin-bottom: 16px;
            font-size: 14px;
            display: none;
        }
        
        /* Pull to refresh styles */
        .pull-to-refresh {
            height: 0;
            overflow: hidden;
            text-align: center;
            transition: height 0.3s;
            position: relative;
            margin-bottom: 8px;
        }
        
        .pull-to-refresh-icon {
            display: inline-block;
            margin-top: 10px;
            transition: transform 0.3s;
        }
        
        .pull-to-refresh.visible {
            height: 60px;
        }
        
        .pull-to-refresh.refreshing .pull-to-refresh-icon {
            animation: spin 1s linear infinite;
        }
        
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        
        /* Pulse animation for active timer */
        @keyframes pulse {
            0% { opacity: 1; }
            50% { opacity: 0.5; }
            100% { opacity: 1; }
        }
        
        .pulse {
            animation: pulse 1s infinite;
        }
        
        /* Dashboard section */
        .dashboard-section {
            margin-top: 24px;
            margin-bottom: 24px;
        }
        
        .dashboard {
            margin-top: 16px;
        }
        
        .dashboard.hidden {
            display: none;
        }
        
        /* Chart containers */
        .chart-container {
            overflow-x: auto;
            margin-bottom: 32px;
            background-color: #fcfcfc;
            border-radius: 6px;
            padding: 12px;
            border: 1px solid #f0f0f0;
        }
        
        .chart-title {
            font-size: 16px;
            font-weight: 500;
            color: #4a5568;
            margin-bottom: 12px;
            text-align: center;
        }
        
        .chart {
            height: 220px;
            width: 100%;
            position: relative;
        }

        /* Specific height for the stream chart container */
#streamChart {
    height: 350px;
}
        
        /* IMPROVED: Bar chart styling */
        .bar-chart {
            display: flex;
            align-items: flex-end;
            height: 150px;
            padding-bottom: 24px;
            position: relative;
            background: linear-gradient(135deg, #68d391, #4299e1);
        }
        
        .bar-container {
            flex: 1;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 0 4px;
            position: relative;
        }
        
        .bar {
            width: 80%;
            max-width: 32px;
            background: linear-gradient(to top, #4f9cf9, #a651e6);
            border-radius: 4px 4px 0 0;
            transition: height 0.3s;
            min-height: 2px;
        }
        
        .bar-label {
            font-size: 10px;
            color: #718096;
            margin-top: 6px;
            text-align: center;
            position: absolute;
            bottom: -24px;
            white-space: nowrap;
            transform: rotate(-45deg);
            transform-origin: top left;
            left: 50%;
        }
        
        .bar-value {
            font-size: 10px;
            color: #4a5568;
            position: absolute;
            top: -16px;
            left: 50%;
            transform: translateX(-50%);
            white-space: nowrap;
        }
        
        /* IMPROVED: Pie chart styling */
        .pie-chart {
            display: flex;
            align-items: center;
            justify-content: center;
            height: 150px;
            padding: 10px;
        }
        
        .pie-container {
            position: relative;
            width: 120px;
            height: 120px;
        }
        
        .pie-slice {
            position: absolute;
            width: 100%;
            height: 100%;
            border-radius: 50%;
            clip-path: polygon(50% 50%, 100% 0, 100% 100%);
            transform-origin: center;
        }
        
        .pie-legend {
            margin-left: 24px;
            display: flex;
            flex-direction: column;
        }
        
        .legend-item {
            display: flex;
            align-items: center;
            margin-bottom: 8px;
        }
        
        .legend-color {
            width: 12px;
            height: 12px;
            margin-right: 8px;
            border-radius: 2px;
        }
        
        .legend-label {
            font-size: 12px;
            color: #4a5568;
        }
        
        /* IMPROVED: Comparison chart styling */
        .comparison-chart {
            display: flex;
            height: 150px;
            align-items: flex-end;
            position: relative;
            padding-bottom: 32px;
        }
        
        .comparison-bar-group {
            flex: 1;
            display: flex;
            justify-content: center;
            gap: 4px;
            position: relative;
        }
        
        .comparison-bar {
            width: 20px;
            border-radius: 4px 4px 0 0;
            transition: height 0.3s;
            min-height: 2px;
            background: linear-gradient(135deg, #68d391, #4299e1);
        }
        
        .comparison-bar.primary {
            background-color: #4f9cf9;
        }
        
        .comparison-bar.secondary {
            background-color: #a651e6;
        }
        
        .comparison-label {
            position: absolute;
            bottom: -24px;
            font-size: 10px;
            color: #718096;
            transform: rotate(-45deg);
            transform-origin: top left;
            white-space: nowrap;
            left: 50%;
        }
        
        .comparison-bar-value {
            position: absolute;
            top: -16px;
            font-size: 10px;
            color: #4a5568;
            text-align: center;
            white-space: nowrap;
            left: 50%;
            transform: translateX(-50%);
        }
        
        .comparison-legend {
            display: flex;
            justify-content: center;
            margin-top: 16px;
        }
        
        .comparison-legend-item {
            display: flex;
            align-items: center;
            margin: 0 8px;
        }
        
        .comparison-legend-color {
            width: 12px;
            height: 12px;
            margin-right: 6px;
            border-radius: 2px;
        }
        
        /* Stats cards */
        .stats-container {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 12px;
            margin-bottom: 24px;
        }
        
        .stat-card {
            background-color: white;
            border-radius: 6px;
            padding: 12px;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.05);
            text-align: center;
        }
        
        .stat-value {
            font-size: 24px;
            font-weight: 600;
            color: #4f9cf9;
        }
        
        .stat-label {
            font-size: 12px;
            color: #718096;
            margin-top: 4px;
        }
        
        /* Empty state styling */
        .empty-chart {
            height: 150px;
            display: flex;
            align-items: center;
            justify-content: center;
            flex-direction: column;
            color: #a0aec0;
        }
        
        .empty-chart svg {
            width: 24px;
            height: 24px;
            margin-bottom: 8px;
            stroke: #cbd5e0;
        }
        
        .empty-chart-text {
            font-size: 14px;
        }

        /* IMPROVED: Canvas-based charts */
        .canvas-container {
            height: 100%;
            width: 100%;
            position: relative;
        }

        .helper-text {
    font-size: 12px;
    color: #718096;
    margin-top: 8px;
    display: none; /* Hidden by default */
}
.load-more-button {
    text-align: center;
    padding: 8px 0;
    color: #718096;
    font-size: 14px;
    cursor: pointer;
    background-color: #f8fafc;
    border-radius: 4px;
    margin-top: 8px;
}

.load-more-button:hover {
    background-color: #edf2f7;
}

.entry-actions {
    display: flex;
    gap: 12px;
    align-items: center;
    margin-left: auto; /* Push to right edge */
    height: 32px; /* Fixed height to match entry time row */
    overflow: hidden; /* Hide overflowing content when collapsed */
    transition: width 0.3s ease; /* Smooth width transition */
    width: 28px; /* Start with just enough width for the toggle button */
}

.entry-actions.expanded {
    width: 108px; /* Increased from 84px to properly fit all three buttons (28px each) plus gaps (12px each) */
}

.action-toggle {
    cursor: pointer;
    width: 28px;
    height: 28px;
    display: flex;
    align-items: center;
    justify-content: center;
    border-radius: 50%;
    transition: all 0.2s, transform 0.3s;
    background-color: #f7fafc;
    color: #718096;
    flex-shrink: 0; /* Don't allow this button to shrink */
}

.action-toggle:hover {
    background-color: #edf2f7;
}

.action-toggle.expanded {
    transform: rotate(180deg);
}

.edit-icon, .delete-icon {
    cursor: pointer;
    width: 28px; /* Increased from 20px */
    height: 28px; /* Increased from 20px */
    display: flex;
    align-items: center;
    justify-content: center;
    border-radius: 50%; /* Make circular */
    transition: all 0.2s, opacity 0.3s, transform 0.3s;
    opacity: 0;
    transform: translateX(10px);
    flex-shrink: 0; /* Don't allow these buttons to shrink */
}

.entry-actions.expanded .edit-icon,
.entry-actions.expanded .delete-icon {
    opacity: 1;
    transform: translateX(0);
}

.edit-icon {
    color: #718096;
    background-color: #edf2f7;
}

.edit-icon:hover {
    background-color: #e2e8f0;
    transform: scale(1.1);
}

.delete-icon {
    color: #e53e3e;
    background-color: #fff5f5;
}

.delete-icon:hover {
    background-color: #fed7d7;
    transform: scale(1.1);
}

.fab {
    position: fixed;
    bottom: 20px;
    right: 20px;
    width: 56px;
    height: 56px;
    background-color: #5a67d8;
    color: white;
    border-radius: 50%;
    box-shadow: 0 3px 6px rgba(0,0,0,0.16);
    font-size: 24px;
    border: none;
    cursor: pointer;
    z-index: 99999;
    transition: transform 0.3s;
}
.fab:hover {
    transform: scale(1.1);
}

/* Date separator styling */
.date-separator {
    margin-top: 16px;
    margin-bottom: 8px;
    font-size: 16px; /* Increased from 14px */
    font-weight: 600;
    color: #4a5568;
    border-bottom: 1px solid #e2e8f0;
    padding-bottom: 8px;
    background-color: #f7fafc; /* Light background to make date stand out */
    padding: 6px 10px;
    border-radius: 8px 8px 0 0;
    display: flex;
    align-items: center;
}

/* Set specific distance from date to first entry */
.date-separator + .entry-item {
    margin-top: 8px;
}


.date-separator::before {
    /*content: "📅"; /* Calendar emoji adds visual indicator */
    margin-right: 8px;
    font-size: 16px;
}

/* Icon styling */
.entry-icon {
    display: none;
}

/* Entry animation */
@keyframes entryAdded {
    0% { background-color: rgba(72,187,120,0.2); }
    100% { background-color: white; }
}

@keyframes entryDeleted {
    0% { background-color: rgba(229,62,62,0.2); opacity: 1; }
    100% { opacity: 0; transform: translateX(-50px); }
}

.entry-added {
    animation: entryAdded 1s ease;
}

.entry-deleted {
    animation: entryDeleted 0.5s ease forwards;
}


    </style>
</head>
<body>
    <div class="pull-to-refresh" id="pullToRefresh">
        <div class="pull-to-refresh-icon">
            <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                <path d="M23 4v6h-6"></path>
                <path d="M20.49 15a9 9 0 1 1-2.12-9.36L23 10"></path>
            </svg>
        </div>
    </div>
    
    <div class="container">
        <header>
            <div class="app-logo">
                <div class="app-logo-inner">
                    <div class="app-logo-core"></div>
                </div>
            </div>
            <h1>Bladder Diary</h1>
            <p class="subtitle">Track your bladder health</p>
        </header>
        
        <div class="privacy-notice">
            <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                <rect x="3" y="11" width="18" height="11" rx="2" ry="2"></rect>
                <path d="M7 11V7a5 5 0 0 1 10 0v4"></path>
            </svg>
            Your data is stored privately and securely on your device only
        </div>
        
        <div id="storageWarning" class="storage-warning">
            Storage is not working properly. Your entries won't be saved between sessions.
        </div>
        
        <button id="toggleFormBtn" class="btn btn-primary">
            Add New Entry
        </button>

        <button class="fab" id="fabAddEntry">+</button>

        <div id="messageArea" class="message hidden"></div>
        
        <form id="entryForm" class="form hidden">
            <div class="form-group grid">
                <div>
                    <label class="form-label" for="date">Date</label>
                    <input class="form-control" type="date" id="date" name="date" required>
                </div>
                <div>
                    <label class="form-label" for="time">Time</label>
                    <input class="form-control" type="time" id="time" name="time" required>
                </div>
            </div>
            
            <h3 class="section-header">Drink</h3>
            <div class="form-group grid">
                <div>
                    <label class="form-label" for="drinkType">Type</label>
                    <select class="form-control" id="drinkType" name="drinkType">
                        <option value="">Select type</option>
                        <option value="Water">Water</option>
                        <option value="Coffee">Coffee</option>
                        <option value="Tea">Tea</option>
                        <option value="Juice">Juice</option>
                        <option value="Soda">Soda</option>
                        <option value="Alcohol">Alcohol</option>
                        <option value="Other">Other</option>
                    </select>
                </div>
                <div>
                    <label class="form-label" for="drinkAmount">Amount (ml)</label>
                    <input class="form-control" type="number" id="drinkAmount" name="drinkAmount" placeholder="ml">
                </div>
            </div>
            
            <h3 class="section-header">Urine</h3>
            <div class="form-group grid">
                <div>
                    <label class="form-label" for="urineVolume">Duration (seconds)</label>
                    <div class="timer-field-container">
                        <input class="form-control" type="number" id="urineVolume" name="urineVolume" placeholder="seconds">
                        <button type="button" id="timerBtn" class="timer-btn">
                            <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                <circle cx="12" cy="12" r="10"></circle>
                                <polyline points="12 6 12 12 16 14"></polyline>
                            </svg>
                            Start
                        </button>
                    </div>
                    <div id="timerIndicator" class="timer-indicator hidden">0s</div>
                </div>
                <div>
                    <label class="form-label" for="urgency">Urgency (0-3)</label>
                    <select class="form-control" id="urgency" name="urgency">
                        <option value="">Select level</option>
                        <option value="0">0 (None)</option>
                        <option value="1">1 (Mild)</option>
                        <option value="2">2 (Moderate)</option>
                        <option value="3">3 (Severe)</option>
                    </select>
                </div>
            </div>
            
            <h3 class="section-header">Urine Flow</h3>
            <div class="form-group">
                <label class="form-label" for="urineStream">Urine Stream</label>
                <select class="form-control" id="urineStream" name="urineStream">
                    <option value="">Select type</option>
                    <option value="Strong">Strong</option>
                    <option value="Intermittent">Intermittent</option>
                    <option value="Weak">Weak</option>
                </select>
            </div>
            
            <button type="submit" class="btn btn-success">Save Entry</button>
        </form>
        
        <div class="card">
            <div class="card-header">
                <h2 class="card-title">Recent Entries</h2>
            </div>
            <div id="entriesList" class="card-body">
                <p id="noEntriesMsg" class="no-entries">No entries yet. Add your first one!</p>
            </div>
        </div>

        <!-- Dashboard section -->
        <div class="dashboard-section">
            <button id="toggleDashboardBtn" class="btn btn-secondary">Show Dashboard</button>
            
            <div id="dashboard" class="dashboard hidden">
                <div class="card">
                    <div class="card-header">
                        <h2 class="card-title">Your Progress Dashboard</h2>
                    </div>
                    <div class="card-body">
                        <div id="noDataMsg" class="no-entries">No data available yet. Add entries to see your dashboard.</div>
                        
                        <div id="dashboardCharts" class="hidden">
                            <!-- Frequency chart -->
                            <div class="chart-container">
                                <h3 class="chart-title">Daily Urination Frequency</h3>
                                <div class="chart" id="frequencyChart">
                                    <canvas id="frequencyCanvas" class="canvas-container"></canvas>
                                </div>
                            </div>
                            
                            <!-- Urgency levels chart -->
                            <div class="chart-container">
                                <h3 class="chart-title">Urgency Levels</h3>
                                <div class="chart" id="urgencyChart">
                                    <canvas id="urgencyCanvas" class="canvas-container"></canvas>
                                </div>
                            </div>

                            <!-- Average Time Between Urinations chart -->
                            <div class="chart-container">
                                <h3 class="chart-title">Average Time Between Urinations</h3>
                                <div class="chart" id="timeGapChart">
                                    <canvas id="timeGapCanvas" class="canvas-container"></canvas>
                                </div>
                            </div>
                            
                            <!-- Fluid intake vs urination -->
                            <div class="chart-container">
                                <h3 class="chart-title">Fluid Intake vs Urination</h3>
                                <div class="chart" id="correlationChart">
                                    <canvas id="correlationCanvas" class="canvas-container"></canvas>
                                </div>
                            </div>
                            
                            <!-- Stream strength distribution -->
                            <div class="chart-container">
                                <h3 class="chart-title">Urine Stream Strength</h3>
                                <div class="chart" id="streamChart">
                                    <canvas id="streamCanvas" class="canvas-container"></canvas>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <div class="export-section">
            <button id="toggleExportBtn" class="btn btn-secondary">Show Export Data</button>
            <textarea id="exportArea" class="export-textarea"></textarea>
            <p class="helper-text">Text is automatically selected for copying</p>
        </div>
    </div>

    <script>
        // DOM elements
        const toggleFormBtn = document.getElementById('toggleFormBtn');
        const fabAddEntry = document.getElementById('fabAddEntry');
        const entryForm = document.getElementById('entryForm');
        const entriesList = document.getElementById('entriesList');
        const noEntriesMsg = document.getElementById('noEntriesMsg');
        const toggleExportBtn = document.getElementById('toggleExportBtn');
        const exportArea = document.getElementById('exportArea');
        const messageArea = document.getElementById('messageArea');
        const storageWarning = document.getElementById('storageWarning');
        const pullToRefresh = document.getElementById('pullToRefresh');
        const timerBtn = document.getElementById('timerBtn');
        const timerIndicator = document.getElementById('timerIndicator');
        const urineVolumeInput = document.getElementById('urineVolume');
        const toggleDashboardBtn = document.getElementById('toggleDashboardBtn');
        const dashboard = document.getElementById('dashboard');
        const noDataMsg = document.getElementById('noDataMsg');
        const dashboardCharts = document.getElementById('dashboardCharts');
        
        
        // Timer variables
        let timerActive = false;
        let timerStart = 0;
        let timerInterval = null;
        
        // Pull-to-refresh variables
        let touchStartY = 0;
        let touchEndY = 0;
        let isRefreshing = false;
        
        // Check if localStorage is available
        let localStorageAvailable = false;
        try {
            localStorage.setItem("test", "test");
            localStorage.removeItem("test");
            localStorageAvailable = true;
            storageWarning.style.display = 'none';
        } catch (e) {
            console.error("localStorage not available:", e);
            storageWarning.style.display = 'block';
            localStorageAvailable = false;
        }
        
        // In-memory storage (backup if localStorage fails)
        let entries = [];
        
        fabAddEntry.addEventListener('click', function() {
            // Simulate clicking the original toggle form button
            toggleFormBtn.click();

            // Optional smooth scroll to the form when it opens
            if (entryForm.style.display !== 'none') {
                entryForm.scrollIntoView({ behavior: 'smooth' });
            }
        });

        // Timer functionality
        timerBtn.addEventListener('click', function() {
            if (!timerActive) {
                // Start timer
                timerActive = true;
                timerStart = Date.now();
                timerBtn.textContent = 'Stop';
                timerBtn.classList.add('active');
                timerIndicator.classList.remove('hidden');
                timerIndicator.classList.add('pulse');
                
                // Update timer display
                timerInterval = setInterval(function() {
                    const elapsedSeconds = Math.floor((Date.now() - timerStart) / 1000);
                    timerIndicator.textContent = elapsedSeconds + 's';
                }, 1000);
            } else {
                // Stop timer
                timerActive = false;
                clearInterval(timerInterval);
                const elapsedSeconds = Math.floor((Date.now() - timerStart) / 1000);
                
                // Set value to input field
                urineVolumeInput.value = elapsedSeconds;
                
                // Reset timer UI
                timerBtn.textContent = 'Start';
                timerBtn.classList.remove('active');
                timerIndicator.classList.add('hidden');
                timerIndicator.classList.remove('pulse');
            }
        });
        
// Enhanced loading with backup recovery
function loadEntries() {
    try {
        if (localStorageAvailable) {
            let loadedEntries = null;
            
            // Try to load from primary storage
            const stored = localStorage.getItem('bladderDiaryEntries');
            if (stored) {
                try {
                    loadedEntries = JSON.parse(stored);
                    console.log("Loaded entries from primary storage:", loadedEntries.length);
                } catch (parseError) {
                    console.error("Error parsing primary storage:", parseError);
                }
            }
            
            // If primary storage failed, try backup
            if (!loadedEntries || loadedEntries.length === 0) {
                const backup = localStorage.getItem('bladderDiaryEntries_backup');
                if (backup) {
                    try {
                        const backupEntries = JSON.parse(backup);
                        if (backupEntries && backupEntries.length > 0) {
                            loadedEntries = backupEntries;
                            console.log("Recovered entries from backup storage:", loadedEntries.length);
                            showMessage("Data recovered from backup", "success");
                        }
                    } catch (parseError) {
                        console.error("Error parsing backup storage:", parseError);
                    }
                }
            }
            
            // Update entries if we loaded something
            if (loadedEntries && loadedEntries.length > 0) {
                entries = loadedEntries;
            }
        }
        renderEntries();
    } catch (e) {
        console.error("Error loading entries:", e);
        showMessage("Error loading saved entries", "danger");
    }
}
        
// Create a backup when saving entries
function saveEntries() {
    try {
        if (localStorageAvailable) {
            // Save to primary storage
            localStorage.setItem('bladderDiaryEntries', JSON.stringify(entries));
            
            // Create backup every time we save
            localStorage.setItem('bladderDiaryEntries_backup', JSON.stringify(entries));
            
            // Save a timestamp of the last save
            localStorage.setItem('bladderDiaryLastSave', new Date().toISOString());
        }
    } catch (e) {
        console.error("Error saving entries:", e);
        showMessage("Error saving entries", "danger");
    }
}
        
        // Helper function to show a message
        function showMessage(message, type = 'danger') {
            messageArea.textContent = message;
            messageArea.className = `message message-${type}`;
            messageArea.style.display = 'block';
            setTimeout(function() {
                messageArea.style.display = 'none';
            }, 3000);
        }
        
        // Set current date and time
        function setCurrentDateTime() {
            try {
                const now = new Date();
                const dateInput = document.getElementById('date');
                const timeInput = document.getElementById('time');
                
                // Format date as YYYY-MM-DD
                const year = now.getFullYear();
                const month = String(now.getMonth() + 1).padStart(2, '0');
                const day = String(now.getDate()).padStart(2, '0');
                dateInput.value = `${year}-${month}-${day}`;
                
                // Format time as HH:MM
                const hours = String(now.getHours()).padStart(2, '0');
                const minutes = String(now.getMinutes()).padStart(2, '0');
                timeInput.value = `${hours}:${minutes}`;
            } catch (error) {
                console.error('Error setting date/time', error);
            }
        }
        
        // Toggle form visibility
        toggleFormBtn.addEventListener('click', function() {
            try {
                if (entryForm.style.display === 'none' || entryForm.style.display === '') {
                    entryForm.style.display = 'block';
                    toggleFormBtn.textContent = 'Cancel';
                    setCurrentDateTime();
                } else {
                    // Make sure timer is stopped if form is closed
                    if (timerActive) {
                        timerActive = false;
                        clearInterval(timerInterval);
                        timerBtn.textContent = 'Start';
                        timerBtn.classList.remove('active');
                        timerIndicator.classList.add('hidden');
                        timerIndicator.classList.remove('pulse');
                    }
                    
                    entryForm.style.display = 'none';
                    toggleFormBtn.textContent = 'Add New Entry';
                    entryForm.reset();
                }
            } catch (error) {
                console.error('Error toggling form', error);
                showMessage('Error showing form');
            }
        });
        
        // Format date for display - FIXED to handle timezone issues
        function formatDate(dateString) {
            try {
                // Parse the date parts directly from the string to avoid timezone issues
                const [year, month, day] = dateString.split('-').map(num => parseInt(num, 10));
                
                // Month names for display
                const months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];
                
                // JavaScript months are 0-based, so subtract 1 from the month
                return `${months[month-1]} ${day}`;
            } catch (error) {
                console.error('Error formatting date', error);
                return dateString;
            }
        }
        
       // Replace the delete function with these two functions
function confirmDeleteEntryAtIndex(index) {
    try {
        if (confirm('Are you sure you want to delete this entry?')) {
            deleteEntryAtIndex(index);
        }
    } catch (error) {
        console.error('Error confirming delete', error);
        showMessage('Error deleting entry');
    }
}

function deleteEntryAtIndex(index) {
    try {
        entries.splice(index, 1);
        saveEntries();
        renderEntries();
        showMessage('Entry deleted', 'success');
    } catch (error) {
        console.error('Error deleting entry', error);
        showMessage('Error deleting entry');
    }
}
        
        // Make the delete function globally available
        window.deleteEntryAtIndex = deleteEntryAtIndex;
        
        // Function to toggle entry action buttons
        function toggleEntryActions(toggleButton) {
            try {
                // Get the parent entry-actions container
                const actionsContainer = toggleButton.parentElement;
                
                // Toggle the expanded state
                const isExpanded = actionsContainer.classList.toggle('expanded');
                
                // Toggle the button rotation
                toggleButton.classList.toggle('expanded', isExpanded);
                
                // Update accessibility title
                toggleButton.title = isExpanded ? "Hide actions" : "Show actions";
            } catch (error) {
                console.error('Error toggling entry actions', error);
            }
        }
        
        // Make the function globally available
        window.toggleEntryActions = toggleEntryActions;
        
        // Render entries list
        function renderEntries(showAll = false) {
    try {
        entriesList.innerHTML = ''; // Clear current list

        if (entries.length === 0) {
            noEntriesMsg.style.display = 'block';
            return;
        }

        noEntriesMsg.style.display = 'none';

        // Sort entries
        entries.sort((a, b) => (a.date + a.time < b.date + b.time ? 1 : -1));

        const displayLimit = showAll ? entries.length : 12;
        const displayEntries = entries.slice(0, displayLimit);

        let lastDate = '';

        displayEntries.forEach((entry, index) => {
            if (entry.date !== lastDate) {
                const dateSeparator = document.createElement('div');
                dateSeparator.className = 'date-separator';
                
                // Get correct day of week
                const dayOfWeek = getDayOfWeek(entry.date);
                
                dateSeparator.textContent = `${formatDate(entry.date)} (${dayOfWeek})`;
                entriesList.appendChild(dateSeparator);
                lastDate = entry.date;
            }

            const entryEl = document.createElement('div');
            entryEl.className = 'entry-item';

            // Determine icon class based on entry type
            let iconClass = '';
            if (entry.drinkType) {
                iconClass = 'drink-icon';
            } else if (entry.urineVolume) {
                iconClass = 'urine-icon';
            }
            
            // Determine urgency class if applicable
            let urgencyClass = '';
            if (entry.urgency) {
                urgencyClass = `urgency-${entry.urgency}`;
            }
            
            // Get urgency text instead of number
            const urgencyText = getUrgencyText(entry.urgency);
            
            // Determine stream class if applicable
            let streamClass = '';
            if (entry.urineStream) {
                streamClass = `stream-${entry.urineStream.toLowerCase()}`;
            }

            entryEl.innerHTML = `
                <div class="entry-header">
                    <div class="entry-date">
                        <span class="entry-icon ${iconClass}"></span>
                        <span class="entry-time">${formatTime(entry.time)}</span>
                    </div>
                    <div class="entry-actions">
                        <div class="action-toggle" title="Show actions" onclick="toggleEntryActions(this)">
                            <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                <polyline points="15 18 9 12 15 6"></polyline>
                            </svg>
                        </div>
                        <div class="edit-icon" title="Edit" onclick="editEntryAtIndex(${entries.indexOf(entry)})">
                            <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                <path d="M17 3a2.828 2.828 0 1 1 4 4L7.5 20.5 2 22l1.5-5.5L17 3z"></path>
                            </svg>
                        </div>
                        <div class="delete-icon" title="Delete" onclick="confirmDeleteEntryAtIndex(${entries.indexOf(entry)})">
                            <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                <line x1="18" y1="6" x2="6" y2="18"></line>
                                <line x1="6" y1="6" x2="18" y2="18"></line>
                            </svg>
                        </div>
                    </div>
                </div>
                <div class="entry-details">
                    ${entry.drinkType ? `<div class="entry-label">Drink:</div><div>${entry.drinkType} (${entry.drinkAmount || 0} ml)</div>` : ''}
                    ${entry.urineVolume ? `<div class="entry-label">Urine:</div><div>${entry.urineVolume} sec&nbsp;<span class="${urgencyClass}">(Urgency: ${urgencyText})</span></div>` : ''}
                    ${entry.urineStream ? `<div class="entry-label">Urine Flow:</div><div class="${streamClass}">${entry.urineStream}</div>` : ''}
                </div>
            `;

            entriesList.appendChild(entryEl);
        });

        if (!showAll && entries.length > displayLimit) {
            const loadMoreButton = document.createElement('div');
            loadMoreButton.className = 'load-more-button';
            loadMoreButton.textContent = 'Load more...';
            loadMoreButton.onclick = () => renderEntries(true);
            entriesList.appendChild(loadMoreButton);
        }
    } catch (error) {
        console.error('Error rendering entries', error);
        showMessage('Error displaying entries');
    }
}

function formatTime(timeString) {
    try {
        // Check if the time is in 24-hour format
        if (timeString.includes(':')) {
            const [hours, minutes] = timeString.split(':');
            
            // Convert to 12-hour format with AM/PM
            let hour = parseInt(hours, 10);
            const ampm = hour >= 12 ? 'PM' : 'AM';
            hour = hour % 12;
            hour = hour ? hour : 12; // the hour '0' should be '12'
            
            return `${hour}:${minutes} ${ampm}`;
        }
        return timeString;
    } catch (error) {
        console.error('Error formatting time', error);
        return timeString;
    }
}

function getDayOfWeek(dateString) {
    try {
        const [year, month, day] = dateString.split('-').map(num => parseInt(num, 10));
        
        // Create date object - months are 0-based in JavaScript 
        const date = new Date(year, month - 1, day);
        
        // Get day of week
        const dayNames = ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'];
        return dayNames[date.getDay()];
    } catch (error) {
        console.error('Error getting day of week', error);
        return '';
    }
}

function getUrgencyText(urgencyLevel) {
    const urgencyMap = {
        '0': 'None',
        '1': 'Mild',
        '2': 'Moderate',
        '3': 'Severe'
    };
    
    return urgencyMap[urgencyLevel] || 'N/A';
}

// Add this new function for editing entries
function editEntryAtIndex(index) {
    try {
        const entry = entries[index];
        
        // Fill the form with the entry data
        document.getElementById('date').value = entry.date;
        document.getElementById('time').value = entry.time;
        document.getElementById('drinkType').value = entry.drinkType || '';
        document.getElementById('drinkAmount').value = entry.drinkAmount || '';
        document.getElementById('urineVolume').value = entry.urineVolume || '';
        document.getElementById('urgency').value = entry.urgency || '';
        document.getElementById('urineStream').value = entry.urineStream || '';
        
        // Show the form
        entryForm.style.display = 'block';
        toggleFormBtn.textContent = 'Cancel';
        
        // Store the index of the entry being edited
        entryForm.dataset.editIndex = index;
        
        // Change the submit button text
        const submitBtn = entryForm.querySelector('button[type="submit"]');
        submitBtn.textContent = 'Update Entry';
        
        // Scroll to the form
        entryForm.scrollIntoView({ behavior: 'smooth' });
    } catch (error) {
        console.error('Error editing entry', error);
        showMessage('Error editing entry');
    }
}

        // Add this to the export section to enable downloading a JSON backup file
        function addBackupButtons() {
    const exportSection = document.querySelector('.export-section');
    
    // Create button container with better spacing
    const buttonContainer = document.createElement('div');
    buttonContainer.style.display = 'flex';
    buttonContainer.style.gap = '8px';
    buttonContainer.style.marginBottom = '16px';
    buttonContainer.style.marginTop = '8px';
    
    // Create download backup button with muted styling
    const downloadButton = document.createElement('button');
    downloadButton.className = 'btn-secondary';
    downloadButton.textContent = 'Download JSON Backup';
    
    // Apply muted styling
    downloadButton.style.backgroundColor = '#a0aec0'; // Grey color
    downloadButton.style.flex = '1'; // Take equal space
    downloadButton.style.padding = '8px 16px';
    downloadButton.style.fontSize = '14px';
    downloadButton.style.color = 'white';
    downloadButton.style.borderRadius = '4px';
    downloadButton.style.border = 'none';
    downloadButton.style.cursor = 'pointer';
    
    // Add click handler for download
    downloadButton.addEventListener('click', function() {
        try {
            if (entries.length === 0) {
                showMessage('No entries to export');
                return;
            }
            
            // Create JSON data
            const jsonData = JSON.stringify(entries, null, 2);
            
            // Create blob and download link
            const blob = new Blob([jsonData], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            
            // Create and trigger download
            const a = document.createElement('a');
            a.href = url;
            a.download = 'bladder_diary_backup.json';
            document.body.appendChild(a);
            a.click();
            
            // Clean up
            setTimeout(function() {
                document.body.removeChild(a);
                window.URL.revokeObjectURL(url);
            }, 0);
            
            showMessage('Backup downloaded successfully!', 'success');
        } catch (error) {
            console.error('Error creating backup:', error);
            showMessage('Error creating backup');
        }
    });
    
    // Create import backup button with matching muted styling
    const importButton = document.createElement('button');
    importButton.className = 'btn-secondary';
    importButton.textContent = 'Import JSON Backup';
    
    // Apply matching muted styling
    importButton.style.backgroundColor = '#a0aec0'; // Same grey color
    importButton.style.flex = '1'; // Take equal space
    importButton.style.padding = '8px 16px';
    importButton.style.fontSize = '14px';
    importButton.style.color = 'white';
    importButton.style.borderRadius = '4px';
    importButton.style.border = 'none';
    importButton.style.cursor = 'pointer';
    
    // Create hidden file input for import
    const fileInput = document.createElement('input');
    fileInput.type = 'file';
    fileInput.accept = '.json';
    fileInput.style.display = 'none';
    
    // Add click handler for import button
    importButton.addEventListener('click', function() {
        fileInput.click();
    });
    
    // Add change handler for file selection
    fileInput.addEventListener('change', function(e) {
        if (e.target.files.length === 0) return;
        
        const file = e.target.files[0];
        const reader = new FileReader();
        
        reader.onload = function(event) {
            try {
                const importedData = JSON.parse(event.target.result);
                
                if (Array.isArray(importedData) && importedData.length > 0) {
                    // Check if the data has the expected structure
                    const isValid = importedData.every(entry => 
                        typeof entry === 'object' && 
                        (entry.date || entry.time || entry.drinkType || entry.urineVolume)
                    );
                    
                    if (isValid) {
                        if (confirm(`Import ${importedData.length} entries? This will replace your current data.`)) {
                            entries = importedData;
                            saveEntries();
                            renderEntries();
                            showMessage(`Successfully imported ${importedData.length} entries!`, 'success');
                        }
                    } else {
                        showMessage('Invalid backup file format', 'danger');
                    }
                } else {
                    showMessage('No valid entries found in the backup file', 'danger');
                }
            } catch (error) {
                console.error('Error importing backup:', error);
                showMessage('Error importing backup: Invalid JSON format', 'danger');
            }
            
            // Reset the file input
            fileInput.value = '';
        };
        
        reader.readAsText(file);
    });
    
    // Add hover effects
    downloadButton.addEventListener('mouseover', function() {
        this.style.backgroundColor = '#718096'; // Darker grey on hover
    });
    downloadButton.addEventListener('mouseout', function() {
        this.style.backgroundColor = '#a0aec0'; // Back to normal grey
    });
    
    importButton.addEventListener('mouseover', function() {
        this.style.backgroundColor = '#718096'; // Darker grey on hover
    });
    importButton.addEventListener('mouseout', function() {
        this.style.backgroundColor = '#a0aec0'; // Back to normal grey
    });
    
    // Add elements to the container
    buttonContainer.appendChild(downloadButton);
    buttonContainer.appendChild(importButton);
    document.body.appendChild(fileInput);
    
    // Add the container to the export section
    const toggleExportBtn = document.getElementById('toggleExportBtn');
    exportSection.insertBefore(buttonContainer, toggleExportBtn.nextSibling);
}


        
        // Handle form submission
entryForm.addEventListener('submit', function(e) {
    e.preventDefault();

    try {
        // If timer is still running, stop it
        if (timerActive) {
            timerActive = false;
            clearInterval(timerInterval);
            const elapsedSeconds = Math.floor((Date.now() - timerStart) / 1000);
            urineVolumeInput.value = elapsedSeconds;
            timerBtn.textContent = 'Start';
            timerBtn.classList.remove('active');
            timerIndicator.classList.add('hidden');
            timerIndicator.classList.remove('pulse');
        }

        // Get form values
        const drinkType = document.getElementById('drinkType').value;
        const drinkAmount = document.getElementById('drinkAmount').value;
        const urineVolume = document.getElementById('urineVolume').value;
        const urgency = document.getElementById('urgency').value;
        const urineStream = document.getElementById('urineStream').value;

        // Check if at least one field is filled
        if (!drinkType && !drinkAmount && !urineVolume && !urgency && !urineStream) {
            showMessage('Please enter at least one type of data before saving.', 'danger');
            return;
        }

        const entryData = {
            date: document.getElementById('date').value,
            time: document.getElementById('time').value,
            drinkType,
            drinkAmount,
            urineVolume,
            urgency,
            urineStream
        };

        // Check if we're editing an existing entry
        const editIndex = entryForm.dataset.editIndex;
        if (editIndex !== undefined) {
            // Update existing entry
            entries[editIndex] = entryData;
            delete entryForm.dataset.editIndex;

            // Change the submit button text back
            const submitBtn = entryForm.querySelector('button[type="submit"]');
            submitBtn.textContent = 'Save Entry';

            showMessage('Entry updated successfully!', 'success');
        } else {
            // Add new entry
            entries.push(entryData);
            showMessage('Entry saved successfully!', 'success');
        }

        // Save to storage
        saveEntries();

        // Render entries
        renderEntries();

        // Reset form and hide
        entryForm.reset();
        entryForm.style.display = 'none';
        toggleFormBtn.textContent = 'Add New Entry';

    } catch (error) {
        console.error('Error saving entry', error);
        showMessage('Error saving entry');
    }
});

        
        // Toggle export data
toggleExportBtn.addEventListener('click', function() {
    try {
        if (entries.length === 0) {
            showMessage('No entries to export');
            return;
        }
        
        const helperText = document.querySelector('.helper-text');
        
        if (exportArea.style.display === 'none' || exportArea.style.display === '') {
            // Create a clean text representation
            let textData = "BLADDER DIARY ENTRIES\n\n";
            
            // Sort by date and time (oldest first for export)
            const sortedEntries = entries.slice().sort(function(a, b) {
                // Compare dates directly as strings (YYYY-MM-DD format sorts correctly)
                if (a.date !== b.date) {
                    return a.date > b.date ? 1 : -1;
                }
                // If dates are the same, compare times
                return a.time > b.time ? 1 : -1;
            });
            
            sortedEntries.forEach(function(entry) {
                textData += `Date: ${entry.date} Time: ${entry.time}\n`;
                
                if (entry.drinkType) {
                    textData += `Drink: ${entry.drinkType} (${entry.drinkAmount || 0} ml)\n`;
                }
                
                if (entry.urineVolume) {
                    textData += `Urine: ${entry.urineVolume} seconds (Urgency: ${entry.urgency || 'N/A'})\n`;
                }
                
                if (entry.urineStream) {
                    textData += `Urine Flow: Stream: ${entry.urineStream}\n`;
                }
                
                textData += `\n`;
            });
            
            // Show in textarea and auto-select
            exportArea.value = textData;
            exportArea.style.display = 'block';
            
            // Show helper text
            if (helperText) {
                helperText.style.display = 'block';
            }
            
            // IMPROVED: Use setTimeout to ensure selection happens after display
            setTimeout(() => {
                exportArea.focus();
                exportArea.select();
            }, 100);
            
            toggleExportBtn.textContent = 'Hide Export Data';
            showMessage('Text is selected and ready to copy', 'success');
        } else {
            exportArea.style.display = 'none';
            
            // Hide helper text
            if (helperText) {
                helperText.style.display = 'none';
            }
            
            toggleExportBtn.textContent = 'Show Export Data';
        }
        
    } catch (error) {
        console.error('Error exporting data', error);
        showMessage('Error creating export');
    }
});
        
        // Dashboard toggle functionality
        toggleDashboardBtn.addEventListener('click', function() {
            try {
                if (dashboard.classList.contains('hidden')) {
                    dashboard.classList.remove('hidden');
                    toggleDashboardBtn.textContent = 'Hide Dashboard';
                    renderDashboard();
                } else {
                    dashboard.classList.add('hidden');
                    toggleDashboardBtn.textContent = 'Show Dashboard';
                }
            } catch (error) {
                console.error('Error toggling dashboard', error);
                showMessage('Error showing dashboard');
            }
        });
        
        // IMPROVED: Canvas utility functions
        function clearCanvas(canvas) {
            const ctx = canvas.getContext('2d');
            ctx.clearRect(0, 0, canvas.width, canvas.height);
        }
        
        function setCanvasDimensions(canvas) {
            // Get the display dimensions
            const displayWidth = canvas.clientWidth;
            const displayHeight = canvas.clientHeight;
            
            // Check if the canvas is not the same size
            if (canvas.width !== displayWidth || canvas.height !== displayHeight) {
                // Set the canvas size to match the display size
                canvas.width = displayWidth;
                canvas.height = displayHeight;
            }
        }
        
        function drawEmptyState(canvas, message) {
            const ctx = canvas.getContext('2d');
            const width = canvas.width;
            const height = canvas.height;
            
            // Detect if we're on a small screen (like mobile)
            const isMobile = width < 400;
            
            ctx.fillStyle = '#f8f9fa';
            ctx.fillRect(0, 0, width, height);
            
            ctx.font = `${isMobile ? 12 : 14}px sans-serif`;
            ctx.fillStyle = '#a0aec0';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(message, width / 2, height / 2);
            
            // Add an icon or helper text for mobile
            if (isMobile) {
                ctx.font = '10px sans-serif';
                ctx.fillText('Add more entries to see data here', width / 2, height / 2 + 20);
            }
        }
        
        // Dashboard-related functions
        function renderDashboard() {
    try {
        // Check if we have any data
        if (entries.length === 0) {
            noDataMsg.style.display = 'block';
            dashboardCharts.classList.add('hidden');
            return;
        }

        // We have data, show the charts
        noDataMsg.style.display = 'none';
        dashboardCharts.classList.remove('hidden');

        // Render each chart
        renderFrequencyChart();
        renderUrgencyChart();
        renderTimeGapChart(); // Add this line to render the new chart
        renderCorrelationChart();
        renderStreamChart();
    } catch (error) {
        console.error('Error rendering dashboard', error);
        showMessage('Error displaying dashboard');
    }
}

        // IMPROVED: Canvas-based charts
        function renderFrequencyChart() {
            try {
                const canvas = document.getElementById('frequencyCanvas');
                if (!canvas) return;
                
                setCanvasDimensions(canvas);
                clearCanvas(canvas);
                
                // Group entries by date
                const entriesByDate = {};
                let hasUrineData = false;

                entries.forEach(entry => {
                    if (entry.urineVolume) {
                        hasUrineData = true;
                        
                        if (!entriesByDate[entry.date]) {
                            entriesByDate[entry.date] = 0;
                        }
                        entriesByDate[entry.date]++;
                    }
                });

                if (!hasUrineData) {
                    drawEmptyState(canvas, 'No urination data recorded yet');
                    return;
                }

                // Convert to array and sort by date
                const dateFrequencies = Object.entries(entriesByDate)
                    .sort((a, b) => a[0].localeCompare(b[0]))
                    .slice(-7); // Only show the last 7 days with data
                
                if (dateFrequencies.length === 0) {
                    drawEmptyState(canvas, 'No urination data recorded yet');
                    return;
                }

                const ctx = canvas.getContext('2d');
                const width = canvas.width;
                const height = canvas.height;
                
                // Detect if we're on a small screen (like mobile)
                const isMobile = width < 400;
                
                // Adjust padding based on screen size
                const padding = {
                    top: 30,
                    right: isMobile ? 10 : 20,
                    bottom: isMobile ? 60 : 40,
                    left: isMobile ? 40 : 50
                };
                
                const chartWidth = width - padding.left - padding.right;
                const chartHeight = height - padding.top - padding.bottom;
                
                // Find the maximum frequency for scaling
                const maxFrequency = Math.max(...dateFrequencies.map(df => df[1]));
                
                // Draw background
                ctx.fillStyle = '#f8f9fa';
                ctx.fillRect(0, 0, width, height);
                
                // Draw horizontal grid lines
                ctx.strokeStyle = '#e2e8f0';
                ctx.lineWidth = 1;
                
                // Mobile-optimized grid lines - draw fewer on small screens
                const gridLines = isMobile ? 4 : 5;
                
                for (let i = 0; i <= gridLines; i++) {
                    const y = padding.top + chartHeight - (i / gridLines) * chartHeight;
                    ctx.beginPath();
                    ctx.moveTo(padding.left, y);
                    ctx.lineTo(width - padding.right, y);
                    ctx.stroke();
                    
                    // Draw y-axis labels
                    ctx.fillStyle = '#718096';
                    ctx.font = isMobile ? '9px sans-serif' : '10px sans-serif';
                    ctx.textAlign = 'right';
                    ctx.textBaseline = 'middle';
                    ctx.fillText(Math.round((i / gridLines) * maxFrequency), padding.left - 5, y);
                }
                
                // Draw bars
                const barWidth = chartWidth / dateFrequencies.length * (isMobile ? 0.6 : 0.7); // Thinner on mobile
                const barSpacing = chartWidth / dateFrequencies.length;
                
                dateFrequencies.forEach((dateFreq, index) => {
                    const [date, count] = dateFreq;
                    const barHeight = (count / maxFrequency) * chartHeight;
                    const x = padding.left + index * barSpacing + (barSpacing - barWidth) / 2;
                    const y = padding.top + chartHeight - barHeight;
                    
                    // Draw bar with gradient
                    const gradient = ctx.createLinearGradient(x, y, x, y + barHeight);
                    gradient.addColorStop(0, '#a651e6');
                    gradient.addColorStop(1, '#4f9cf9');
                    
                    ctx.fillStyle = gradient;
                    ctx.beginPath();
                    ctx.roundRect(x, y, barWidth, barHeight, [4, 4, 0, 0]);
                    ctx.fill();
                    
                    // Draw bar value
                    ctx.fillStyle = '#4a5568';
                    ctx.font = isMobile ? '9px sans-serif' : '10px sans-serif';
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'bottom';
                    ctx.fillText(count, x + barWidth / 2, y - 5);
                    
                    // Draw x-axis labels
                    ctx.fillStyle = '#718096';
                    ctx.font = isMobile ? '9px sans-serif' : '10px sans-serif';
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'top';
                    ctx.save();
                    
                    // Simplified date format for mobile
                    let displayDate;
                    if (isMobile) {
                        // Show minimal date format on mobile ("25" instead of "Feb 25")
                        const dateParts = date.split('-');
                        const day = parseInt(dateParts[2]);
                        displayDate = `${day}`;
                    } else {
                        displayDate = formatDate(date);
                    }
                    
                    ctx.translate(x + barWidth / 2, height - padding.bottom / 2);
                    ctx.rotate(-Math.PI / (isMobile ? 3 : 4)); // Rotate more on mobile
                    ctx.fillText(displayDate, 0, 0);
                    ctx.restore();
                });
                
                // Add month labels for mobile displays
                if (isMobile && dateFrequencies.length > 0) {
                    // Add month labels above the day numbers
                    dateFrequencies.forEach(([date], index) => {
                        const dateParts = date.split('-');
                        const monthIndex = parseInt(dateParts[1]) - 1; // 0-based month
                        const months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];
                        
                        // Only show month for first day of month or first data point
                        if (index === 0 || dateParts[2] === '01') {
                            const x = padding.left + index * barSpacing + barSpacing / 2;
                            ctx.fillStyle = '#a0aec0'; // Lighter color for month
                            ctx.font = '8px sans-serif'; // Smaller than day
                            ctx.textAlign = 'center';
                            ctx.fillText(months[monthIndex], x, height - padding.bottom + 20);
                        }
                    });
                }
                
                // Add title for context on mobile
                if (isMobile) {
                    ctx.fillStyle = '#4a5568';
                    ctx.font = 'bold 10px sans-serif';
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'top';
                    ctx.fillText('Number of urinations per day', width / 2, height - 15);
                }
            } catch (error) {
                console.error('Error rendering frequency chart', error);
                const canvas = document.getElementById('frequencyCanvas');
                if (canvas) {
                    drawEmptyState(canvas, 'Could not generate chart');
                }
            }
        }

        function renderUrgencyChart() {
            try {
                const canvas = document.getElementById('urgencyCanvas');
                if (!canvas) return;
                
                setCanvasDimensions(canvas);
                clearCanvas(canvas);
                
                // Count urgency levels
                const urgencyCounts = { '0': 0, '1': 0, '2': 0, '3': 0 };
                let hasUrgencyData = false;

                entries.forEach(entry => {
                    if (entry.urgency) {
                        hasUrgencyData = true;
                        urgencyCounts[entry.urgency]++;
                    }
                });

                if (!hasUrgencyData) {
                    drawEmptyState(canvas, 'No urgency data recorded yet');
                    return;
                }

                // Calculate total for percentages
                const total = Object.values(urgencyCounts).reduce((sum, count) => sum + count, 0);
                if (total === 0) {
                    drawEmptyState(canvas, 'No urgency data recorded yet');
                    return;
                }
                
                const ctx = canvas.getContext('2d');
                const width = canvas.width;
                const height = canvas.height;
                
                // Detect if we're on a small screen (like mobile)
                const isMobile = width < 400;
                
                // Adjust dimensions based on screen size
                const centerX = width / 2.2; // Shift pie slightly left to make room for legend
                const centerY = height / 2;
                // Smaller pie on mobile
                const radius = Math.min(width, height) / (isMobile ? 2.8 : 2.5) - 30;
                
                // Colors for urgency levels
                const colors = {
                    '0': '#48bb78', // Green for none
                    '1': '#4299e1', // Blue for mild
                    '2': '#ecc94b', // Yellow for moderate
                    '3': '#e53e3e'  // Red for severe
                };
                
                // Display names for urgency levels
                const urgencyLabels = {
                    '0': 'None',
                    '1': 'Mild',
                    '2': 'Moderate',
                    '3': 'Severe'
                };
                
                // Draw background
                ctx.fillStyle = '#f8f9fa';
                ctx.fillRect(0, 0, width, height);
                
                // Draw pie chart
                let startAngle = 0;
                
                // Draw each slice of the pie
                for (const [level, count] of Object.entries(urgencyCounts)) {
                    if (count > 0) {
                        const sliceAngle = (count / total) * 2 * Math.PI;
                        
                        ctx.beginPath();
                        ctx.moveTo(centerX, centerY);
                        ctx.arc(centerX, centerY, radius, startAngle, startAngle + sliceAngle);
                        ctx.closePath();
                        
                        ctx.fillStyle = colors[level];
                        ctx.fill();
                        
                        // Draw slice label
                        const labelAngle = startAngle + sliceAngle / 2;
                        const percent = Math.round((count / total) * 100);
                        
                        // Only draw percentage label if slice is big enough
                        if (percent >= (isMobile ? 8 : 5)) {
                            // Position the label at 2/3 of radius
                            const labelX = centerX + Math.cos(labelAngle) * (radius * 0.65);
                            const labelY = centerY + Math.sin(labelAngle) * (radius * 0.65);
                            
                            ctx.fillStyle = 'white';
                            ctx.font = `bold ${isMobile ? 10 : 12}px sans-serif`;
                            ctx.textAlign = 'center';
                            ctx.textBaseline = 'middle';
                            ctx.fillText(`${percent}%`, labelX, labelY);
                        }
                        
                        startAngle += sliceAngle;
                    }
                }
                
                // Draw legend - optimized for mobile
                const legendX = isMobile ? width * 0.68 : width * 0.7;
                let legendY = isMobile ? centerY - radius : 20;
                
                ctx.textAlign = 'left';
                ctx.textBaseline = 'middle';
                
                // Draw title for legend on mobile
                if (isMobile) {
                    ctx.fillStyle = '#4a5568';
                    ctx.font = 'bold 10px sans-serif';
                    ctx.fillText('Urgency levels:', legendX, legendY - 20);
                }
                
                for (const [level, count] of Object.entries(urgencyCounts)) {
                    if (count > 0) {
                        // Draw legend color box
                        ctx.fillStyle = colors[level];
                        // Smaller boxes on mobile
                        const boxSize = isMobile ? 10 : 12;
                        ctx.fillRect(legendX, legendY, boxSize, boxSize);
                        
                        // Draw legend text
                        ctx.fillStyle = '#4a5568';
                        ctx.font = `${isMobile ? 9 : 12}px sans-serif`;
                        ctx.fillText(
                            `${urgencyLabels[level]} (${count})`,
                            legendX + boxSize + 6,
                            legendY + boxSize/2
                        );
                        
                        // Less spacing on mobile
                        legendY += isMobile ? 16 : 20;
                    }
                }
                
                // Add note about urgency scale on mobile
                if (isMobile) {
                    const noteY = height - 15;
                    ctx.fillStyle = '#718096';
                    ctx.font = 'italic 8px sans-serif';
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.fillText('Urgency scale: 0 (None) to 3 (Severe)', width / 2, noteY);
                }
                
            } catch (error) {
                console.error('Error rendering urgency chart', error);
                const canvas = document.getElementById('urgencyCanvas');
                if (canvas) {
                    drawEmptyState(canvas, 'Could not generate chart');
                }
            }
        }

        function renderCorrelationChart() {
            try {
                const canvas = document.getElementById('correlationCanvas');
                if (!canvas) return;
                
                setCanvasDimensions(canvas);
                clearCanvas(canvas);
                
                // Group entries by date
                const dailyData = {};
                let hasData = false;

                entries.forEach(entry => {
                    if (!dailyData[entry.date]) {
                        dailyData[entry.date] = {
                            date: entry.date,
                            drinkAmount: 0,
                            urinationCount: 0
                        };
                    }
                    
                    if (entry.drinkAmount) {
                        hasData = true;
                        dailyData[entry.date].drinkAmount += parseInt(entry.drinkAmount) || 0;
                    }
                    
                    if (entry.urineVolume) {
                        hasData = true;
                        dailyData[entry.date].urinationCount++;
                    }
                });

                if (!hasData) {
                    drawEmptyState(canvas, 'Not enough data for correlation');
                    return;
                }

                // Convert to array and sort by date
                const dailyDataArray = Object.values(dailyData)
                    .filter(day => day.drinkAmount > 0 || day.urinationCount > 0)
                    .sort((a, b) => a.date.localeCompare(b.date))
                    .slice(-5); // Last 5 days with data
                    
                if (dailyDataArray.length === 0) {
                    drawEmptyState(canvas, 'Not enough data for correlation');
                    return;
                }
                
                const ctx = canvas.getContext('2d');
                const width = canvas.width;
                const height = canvas.height;
                
                // Detect if we're on a small screen (like mobile)
                const isMobile = width < 400;
                
                // Adjust padding based on screen size
                const padding = {
                    top: 30,
                    right: isMobile ? 10 : 20,
                    bottom: isMobile ? 60 : 40,
                    left: isMobile ? 40 : 50
                };
                
                const chartWidth = width - padding.left - padding.right;
                const chartHeight = height - padding.top - padding.bottom;
                
                // Draw background
                ctx.fillStyle = '#f8f9fa';
                ctx.fillRect(0, 0, width, height);
                
                // Find max values for scaling
                const maxDrink = Math.max(...dailyDataArray.map(day => day.drinkAmount));
                const maxCount = Math.max(...dailyDataArray.map(day => day.urinationCount));
                
                // Draw grid lines
                ctx.strokeStyle = '#e2e8f0';
                ctx.lineWidth = 1;
                
                // Draw y-axis line
                ctx.beginPath();
                ctx.moveTo(padding.left, padding.top);
                ctx.lineTo(padding.left, height - padding.bottom);
                ctx.stroke();
                
                // Draw x-axis line
                ctx.beginPath();
                ctx.moveTo(padding.left, height - padding.bottom);
                ctx.lineTo(width - padding.right, height - padding.bottom);
                ctx.stroke();
                
                // Mobile-optimized grid lines - draw fewer on small screens
                const gridLines = isMobile ? 3 : 5;
                
                // Draw horizontal grid lines for drink amount
                for (let i = 0; i <= gridLines; i++) {
                    const y = padding.top + (1 - i / gridLines) * chartHeight;
                    ctx.beginPath();
                    ctx.moveTo(padding.left, y);
                    ctx.lineTo(width - padding.right, y);
                    ctx.stroke();
                    
                    // Draw y-axis labels for drink amount
                    const drinkValue = Math.round((i / gridLines) * maxDrink);
                    ctx.fillStyle = '#4f9cf9';
                    ctx.font = isMobile ? '9px sans-serif' : '10px sans-serif';
                    ctx.textAlign = 'right';
                    ctx.textBaseline = 'middle';
                    ctx.fillText(`${drinkValue}${isMobile ? '' : ' ml'}`, padding.left - 5, y);
                }
                
                // Draw group bar chart
                const barWidth = chartWidth / dailyDataArray.length * (isMobile ? 0.25 : 0.3);
                const groupWidth = chartWidth / dailyDataArray.length;
                
                dailyDataArray.forEach((day, index) => {
                    // Simplified date format for mobile
                    let displayDate;
                    if (isMobile) {
                        // Show minimal date format on mobile ("25" instead of "Feb 25")
                        const dateParts = day.date.split('-');
                        const dayNum = parseInt(dateParts[2]);
                        displayDate = `${dayNum}`;
                    } else {
                        displayDate = formatDate(day.date);
                    }
                    
                    // Draw date label
                    ctx.fillStyle = '#718096';
                    ctx.font = isMobile ? '9px sans-serif' : '10px sans-serif';
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'top';
                    ctx.save();
                    ctx.translate(padding.left + index * groupWidth + groupWidth / 2, height - padding.bottom + 5);
                    ctx.rotate(-Math.PI / (isMobile ? 3 : 4)); // Rotate more on mobile
                    ctx.fillText(displayDate, 0, 0);
                    ctx.restore();
                    
                    // Draw drink amount bar
                    const drinkBarHeight = maxDrink > 0 ? (day.drinkAmount / maxDrink) * chartHeight : 0;
                    // Move bars closer on mobile
                    const drinkX = padding.left + index * groupWidth + (isMobile ? groupWidth * 0.30 : groupWidth * 0.25);
                    const drinkY = height - padding.bottom - drinkBarHeight;
                    
                    ctx.fillStyle = '#4f9cf9';
                    ctx.beginPath();
                    ctx.roundRect(drinkX, drinkY, barWidth, drinkBarHeight, [4, 4, 0, 0]);
                    ctx.fill();
                    
                    // Draw drink value
                    if (day.drinkAmount > 0) {
                        ctx.fillStyle = '#4a5568';
                        ctx.font = isMobile ? '9px sans-serif' : '10px sans-serif';
                        ctx.textAlign = 'center';
                        ctx.fillText(day.drinkAmount, drinkX + barWidth / 2, drinkY - 5);
                    }
                    
                    // Draw urination count bar scaled up for visibility
                    const countBarHeight = maxCount > 0 ? (day.urinationCount / maxCount) * chartHeight : 0;
                    // Move bars closer on mobile
                    const countX = padding.left + index * groupWidth + (isMobile ? groupWidth * 0.60 : groupWidth * 0.6);
                    const countY = height - padding.bottom - countBarHeight;
                    
                    ctx.fillStyle = '#a651e6';
                    ctx.beginPath();
                    ctx.roundRect(countX, countY, barWidth, countBarHeight, [4, 4, 0, 0]);
                    ctx.fill();
                    
                    // Draw count value
                    if (day.urinationCount > 0) {
                        ctx.fillStyle = '#4a5568';
                        ctx.font = isMobile ? '9px sans-serif' : '10px sans-serif';
                        ctx.textAlign = 'center';
                        ctx.fillText(day.urinationCount, countX + barWidth / 2, countY - 5);
                    }
                });
                
                // Add month labels for mobile displays
                if (isMobile && dailyDataArray.length > 0) {
                    // Add month labels above the day numbers
                    dailyDataArray.forEach((day, index) => {
                        const dateParts = day.date.split('-');
                        const monthIndex = parseInt(dateParts[1]) - 1; // 0-based month
                        const months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];
                        
                        // Only show month for first day of month or first data point
                        if (index === 0 || dateParts[2] === '01') {
                            const x = padding.left + index * groupWidth + groupWidth / 2;
                            ctx.fillStyle = '#a0aec0'; // Lighter color for month
                            ctx.font = '8px sans-serif'; // Smaller than day
                            ctx.textAlign = 'center';
                            ctx.fillText(months[monthIndex], x, height - padding.bottom + 20);
                        }
                    });
                }
                
                // Draw legend
                const legendY = height - 15;
                
                // Drink legend
                ctx.fillStyle = '#4f9cf9';
                ctx.fillRect(padding.left, legendY, 12, 12);
                ctx.fillStyle = '#4a5568';
                ctx.font = '10px sans-serif';
                ctx.textAlign = 'left';
                ctx.textBaseline = 'middle';
                ctx.fillText('Fluid intake (ml)', padding.left + 16, legendY + 6);
                
                // Count legend
                ctx.fillStyle = '#a651e6';
                ctx.fillRect(padding.left + 120, legendY, 12, 12);
                ctx.fillStyle = '#4a5568';
                ctx.fillText('Urination frequency', padding.left + 136, legendY + 6);
                
            } catch (error) {
                console.error('Error rendering correlation chart', error);
                const canvas = document.getElementById('correlationCanvas');
                if (canvas) {
                    drawEmptyState(canvas, 'Could not generate chart');
                }
            }
        }

        function renderStreamChart() {
    try {
        const canvas = document.getElementById('streamCanvas');
        if (!canvas) return;

        // Use the same dynamic sizing approach as other charts:
        setCanvasDimensions(canvas);
        clearCanvas(canvas);

        const ctx = canvas.getContext('2d');
        const width = canvas.width;
        const height = canvas.height;
        
        // Detect if we're on a small screen (like mobile)
        const isMobile = width < 400;

        // Get all entries with urine stream data
        const streamEntries = entries.filter(entry => entry.urineStream);
        if (streamEntries.length === 0) {
            drawEmptyState(canvas, 'No stream data recorded yet');
            return;
        }

        // Sort entries by date/time
        streamEntries.sort((a, b) => {
            if (a.date !== b.date) {
                return a.date.localeCompare(b.date);
            }
            return a.time.localeCompare(b.time);
        });

        // IMPROVED: Limit to the most recent entries for better visibility on mobile
        const recentEntries = streamEntries.slice(-(isMobile ? 8 : 12));

        // Convert stream types to numeric values
        const streamValues = {
            'Strong': 3,
            'Intermittent': 2,
            'Weak': 1
        };

        // Prepare data points
        const dataPoints = recentEntries.map(entry => {
            const value = streamValues[entry.urineStream];
            if (!value) console.error(`Invalid urineStream value: ${entry.urineStream}`);
            return {
                date: entry.date,
                time: entry.time,
                displayDate: formatDate(entry.date),
                value: value || 1, // Default to Weak if invalid
                label: entry.urineStream
            };
        });

        // Fill canvas background
        ctx.fillStyle = '#ffffff';
        ctx.fillRect(0, 0, width, height);

        // IMPROVED: Layout zones with proper margins for all screen sizes
        const padding = Math.min(width, height) * (isMobile ? 0.04 : 0.05); // Less padding on mobile
        
        const layout = {
            goal: { top: padding * 2, height: padding },
            chart: {
                top: padding * 4,
                bottom: height - padding * (isMobile ? 6 : 7), // More chart space on mobile
                left: padding * (isMobile ? 4 : 5), // Less left padding on mobile
                right: width - padding * 2
            },
            trend: { top: height - padding * 4, height: padding * 1.5 },
            legend: { top: height - padding * 2, height: padding }
        };

        // Draw goal with mobile optimization
        ctx.fillStyle = '#4a5568';
        ctx.font = `italic ${isMobile ? 11 : 14}px sans-serif`;
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';

        const goalText = 'Goal: Strong urine stream indicates better bladder health';
        const maxGoalWidth = width * (isMobile ? 0.95 : 0.9); // More width on mobile

        // Check if we need to break the text
        ctx.font = `italic ${isMobile ? 11 : 14}px sans-serif`; // Set font before measuring
        const goalWidth = ctx.measureText(goalText).width;

        if (goalWidth > maxGoalWidth && width < 400) {
            // For smaller screens, break into two lines
            const firstLine = 'Goal: Strong urine stream';
            const secondLine = 'indicates better bladder health';
            
            ctx.fillText(
                firstLine,
                width / 2,
                layout.goal.top + layout.goal.height / 2 - 10
            );
            
            ctx.fillText(
                secondLine,
                width / 2,
                layout.goal.top + layout.goal.height / 2 + 10
            );
        } else {
            // For larger screens, keep as one line but ensure it fits
            ctx.fillText(
                goalText,
                width / 2,
                layout.goal.top + layout.goal.height / 2
            );
        }

        // Make sure to adjust the chart area if we're using two lines
        if (goalWidth > maxGoalWidth && width < 400) {
            // Add some extra space for the two-line goal text
            layout.chart.top += 15;
        }

        // Define y-axis levels (Strong = 3, Intermittent = 2, Weak = 1)
        const streamLevels = [
            { value: 3, label: 'Strong', color: '#22c55e' },
            { value: 2, label: 'Intermittent', color: '#eab308' },
            { value: 1, label: 'Weak', color: '#dc2626' }
        ];

        const chartHeight = layout.chart.bottom - layout.chart.top;
        // IMPROVED: MORE spacing between levels (using 4 divisions for 3 levels gives more space)
        const levelHeight = chartHeight / 4;

        // Draw horizontal lines & labels
        streamLevels.forEach((level) => {
            // IMPROVED: Adjusted level position calculation for more vertical space
            const yPos = layout.chart.top + (4 - level.value) * levelHeight;
            ctx.strokeStyle = '#e2e8f0';
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.moveTo(layout.chart.left, yPos);
            ctx.lineTo(layout.chart.right, yPos);
            ctx.stroke();

            // Adjust font size for stream labels based on available space
            const leftPadding = layout.chart.left;
            const maxLabelWidth = leftPadding - (isMobile ? 10 : 15); // Less margin on mobile
            
            ctx.fillStyle = level.color;
            
            // Mobile-optimized fonts
            const fontSize = isMobile ? 10 : 12;
            
            ctx.font = `bold ${fontSize}px sans-serif`;
            ctx.textAlign = 'right';
            ctx.textBaseline = 'middle';
            
            // Calculate text metrics to check if it fits
            const metrics = ctx.measureText(level.label);
            const textWidth = metrics.width;
            
            // If the text is still too wide, shrink it more
            if (textWidth > maxLabelWidth) {
                const scaleFactor = maxLabelWidth / textWidth;
                const adjustedFontSize = Math.floor(fontSize * scaleFactor);
                ctx.font = `bold ${adjustedFontSize}px sans-serif`;
            }
            
            ctx.fillText(level.label, layout.chart.left - (isMobile ? 6 : 10), yPos);
        });

        // IMPROVED: Calculate available width more accurately
        const chartWidth = layout.chart.right - layout.chart.left;
        if (dataPoints.length > 0) {
            // Better date step calculation
            const dateStep = chartWidth / (dataPoints.length > 1 ? dataPoints.length - 1 : 1);

            ctx.beginPath();
            ctx.strokeStyle = '#4f9cf9';
            ctx.lineWidth = isMobile ? 1.5 : 2; // Thinner line on mobile

            dataPoints.forEach((point, index) => {
                const x = layout.chart.left + index * dateStep;
                // IMPROVED: Use adjusted level height calculation
                const y = layout.chart.top + (4 - point.value) * levelHeight;

                if (index === 0) {
                    ctx.moveTo(x, y);
                } else {
                    ctx.lineTo(x, y);
                }

                // Draw date labels - improved spacing
                ctx.fillStyle = '#718096';
                ctx.font = `${isMobile ? 9 : 12}px sans-serif`;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'top';
                
                // Simplified date format for mobile
                let displayLabel;
                if (isMobile) {
                    const dateParts = point.date.split('-');
                    const day = parseInt(dateParts[2]);
                    displayLabel = `${day}`;
                } else {
                    displayLabel = point.displayDate;
                }
                
                // Rotate date labels if many dates
                if (dataPoints.length > (isMobile ? 3 : 4)) {
                    ctx.save();
                    ctx.translate(x, layout.chart.bottom + 10);
                    ctx.rotate(-Math.PI / (isMobile ? 3 : 6)); // Rotate more on mobile
                    ctx.fillText(displayLabel, 0, 0);
                    ctx.restore();
                } else {
                    ctx.fillText(displayLabel, x, layout.chart.bottom + 10);
                }
            });
            ctx.stroke();

            // Add month labels for mobile displays
            if (isMobile && dataPoints.length > 0) {
                // Add month labels above the day numbers
                dataPoints.forEach((point, index) => {
                    const dateParts = point.date.split('-');
                    const monthIndex = parseInt(dateParts[1]) - 1; // 0-based month
                    const months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];
                    
                    // Only show month for first day of month or first data point
                    if (index === 0 || dateParts[2] === '01') {
                        const x = layout.chart.left + index * dateStep;
                        ctx.fillStyle = '#a0aec0'; // Lighter color for month
                        ctx.font = '8px sans-serif'; // Smaller than day
                        ctx.textAlign = 'center';
                        ctx.fillText(months[monthIndex], x, layout.chart.bottom + 28);
                    }
                });
            }

            // Draw point circles - smaller on mobile
            dataPoints.forEach((point, index) => {
                const x = layout.chart.left + index * dateStep;
                // IMPROVED: Use adjusted level height calculation
                const y = layout.chart.top + (4 - point.value) * levelHeight;

                let pointColor;
                switch (point.value) {
                    case 3: pointColor = '#22c55e'; break;
                    case 2: pointColor = '#eab308'; break;
                    case 1: pointColor = '#dc2626'; break;
                    default: pointColor = '#4f9cf9';
                }

                ctx.beginPath();
                ctx.fillStyle = pointColor;
                ctx.arc(x, y, isMobile ? 6 : 8, 0, Math.PI * 2);
                ctx.fill();

                // White outline
                ctx.strokeStyle = '#ffffff';
                ctx.lineWidth = isMobile ? 1.5 : 2;
                ctx.stroke();
            });

            // Simple trend calculation
            if (dataPoints.length >= 2) {
                const firstPoint = [dataPoints[0]];  // Take just the first point
                const lastPoint = [dataPoints[dataPoints.length - 1]];  // Take just the last point

                const firstAvg = firstPoint[0].value;  // Direct value of first point
                const lastAvg = lastPoint[0].value;    // Direct value of last point

                let trendDirection, trendColor, trendEmoji;
                if (lastAvg > firstAvg + 0.3) {
                    trendDirection = 'Improving';
                    trendColor = '#22c55e';
                    trendEmoji = '👍';
                } else if (lastAvg < firstAvg - 0.3) {
                    trendDirection = 'Worsening';
                    trendColor = '#dc2626';
                    trendEmoji = '👎';
                } else {
                    trendDirection = 'Stable';
                    trendColor = '#eab308';
                    trendEmoji = '➡️';
                }

                // Dotted trend line
                ctx.beginPath();
                ctx.strokeStyle = trendColor;
                ctx.setLineDash([5, 3]);
                ctx.lineWidth = isMobile ? 2 : 2.5;

                const firstX = layout.chart.left;
                // IMPROVED: Use adjusted level height calculation
                const firstY = layout.chart.top + (4 - firstAvg) * levelHeight;
                const lastX = layout.chart.right;
                // IMPROVED: Use adjusted level height calculation
                const lastY = layout.chart.top + (4 - lastAvg) * levelHeight;

                ctx.moveTo(firstX, firstY);
                ctx.lineTo(lastX, lastY);
                ctx.stroke();
                ctx.setLineDash([]);

                // Trend text - smaller on mobile
                ctx.fillStyle = trendColor;
                ctx.font = `bold ${isMobile ? 14 : 16}px sans-serif`;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(
                    `${trendEmoji} ${trendDirection} trend`,
                    width / 2,
                    layout.trend.top + layout.trend.height / 2
                );

                // Legend text - smaller on mobile
                ctx.fillStyle = '#4a5568';
                ctx.font = `${isMobile ? 11 : 14}px sans-serif`;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(
                    'Dotted line shows overall trend',
                    width / 2,
                    layout.legend.top + layout.legend.height / 2
                );
            }
        }
    } catch (error) {
        console.error('Error rendering stream chart', error);
        const canvas = document.getElementById('streamCanvas');
        if (canvas) {
            drawEmptyState(canvas, 'Could not generate chart');
        }
    }
}

        
        // Pull-to-refresh functionality
        function startRefreshing() {
            if (isRefreshing) return;
            isRefreshing = true;
            
            pullToRefresh.classList.add('refreshing');
            
            // Simulate a refresh (in this case, just reload entries from storage)
            setTimeout(function() {
                loadEntries();
                pullToRefresh.classList.remove('visible', 'refreshing');
                isRefreshing = false;
                showMessage('Refreshed', 'success');
            }, 800);
        }

        // Function to make the logo clickable to refresh data
function addLogoRefreshFunctionality() {
    const appLogo = document.querySelector('.app-logo');
    const appLogoInner = document.querySelector('.app-logo-inner');
    
    if (appLogo && appLogoInner) {
        // Add cursor style to indicate it's clickable
        appLogo.style.cursor = 'pointer';
        
        // Add a subtle title/tooltip
        appLogo.title = 'Refresh data';
        
        // Add click handler
        appLogo.addEventListener('click', function() {
            // Show a subtle animation on click
            appLogoInner.style.transition = 'transform 0.5s';
            appLogoInner.style.transform = 'rotate(360deg)';
            
            // Reset the animation after it completes
            setTimeout(() => {
                appLogoInner.style.transition = '';
                appLogoInner.style.transform = '';
            }, 500);
            
            // Perform the actual refresh (same as pull-to-refresh)
            loadEntries();
            showMessage('Data refreshed', 'success');
        });
    }
}
        
        // Touch event handlers for pull-to-refresh
        document.addEventListener('touchstart', function(e) {
            // Only trigger if we're at the top of the page
            if (window.scrollY === 0) {
                touchStartY = e.touches[0].clientY;
            }
        }, { passive: true });
        
        document.addEventListener('touchmove', function(e) {
            if (touchStartY > 0 && !isRefreshing) {
                touchEndY = e.touches[0].clientY;
                const distance = touchEndY - touchStartY;
                
                // Only show pull indicator if we're pulling down
                if (distance > 0) {
                    pullToRefresh.classList.add('visible');
                    
                    // Calculate a rotation for the refresh icon based on pull distance
                    const rotationDegrees = Math.min(distance * 2, 180);
                    document.querySelector('.pull-to-refresh-icon').style.transform = `rotate(${rotationDegrees}deg)`;
                }
            }
        }, { passive: true });
        
        document.addEventListener('touchend', function() {
            if (touchStartY > 0 && touchEndY > 0 && !isRefreshing) {
                const distance = touchEndY - touchStartY;
                
                // If pulled far enough, trigger refresh
                if (distance > 60) {
                    startRefreshing();
                } else {
                    // Otherwise, just hide the indicator
                    pullToRefresh.classList.remove('visible');
                }
                
                // Reset values
                touchStartY = 0;
                touchEndY = 0;
            }
        }, { passive: true });
        
        
        
        // IMPROVED: Add focus and select handler for export text
        exportArea.addEventListener('blur', function() {
            setTimeout(() => {
                exportArea.focus();
                exportArea.select();
            }, 100);
        });
        
        // Initialize app
entryForm.style.display = 'none';
exportArea.style.display = 'none';
setCurrentDateTime();

// Load entries first
loadEntries(); 

// Only load sample data if no entries exist at all
if (entries.length === 0) {
    loadSampleData();
    showMessage("Sample data loaded for demonstration", "success");
}

// Call this function during initialization
addBackupButtons();
addLogoRefreshFunctionality();

// Modify the loadSampleData function to not call saveEntries automatically:
function loadSampleData() {
    entries = [
        {date: "2025-02-25", time: "19:36", urineVolume: "9", urgency: "2", urineStream: "Strong"},
        {date: "2025-02-25", time: "20:50", drinkType: "Water", drinkAmount: "250"},
        {date: "2025-02-25", time: "22:15", urineVolume: "9", urgency: "2", urineStream: "Intermittent"},
        {date: "2025-02-26", time: "07:05", urineVolume: "17", urgency: "2", urineStream: "Intermittent"},
        {date: "2025-02-26", time: "07:52", drinkType: "Water", drinkAmount: "250"},
        {date: "2025-02-26", time: "08:32", drinkType: "Tea", drinkAmount: "500"},
        {date: "2025-02-26", time: "09:24", drinkType: "Water", drinkAmount: "750"},
        {date: "2025-02-26", time: "09:56", urineVolume: "22", urgency: "1", urineStream: "Strong"},
        {date: "2025-02-26", time: "12:41", urineVolume: "25", urgency: "1", urineStream: "Intermittent"},
        {date: "2025-02-26", time: "12:51", drinkType: "Other", drinkAmount: "250"},
        {date: "2025-02-26", time: "13:41", drinkType: "Water", drinkAmount: "750"}
    ];
    
    // Mark these as sample data (optional)
    entries.forEach(entry => entry.isSampleData = true);
    
    // Now save to storage
    saveEntries();
    
    // Render entries to display
    renderEntries();
}

// Calculate average time between urinations per day
function calculateAverageTimeBetweenUrinations() {
    // Group urination entries by date
    const urinationsByDate = {};
    
    entries.forEach(entry => {
        if (entry.urineVolume) {  // Check if it's a urination entry
            // Only consider entries between 8am and 11pm
            const hour = parseInt(entry.time.split(':')[0]);
            if (hour >= 8 && hour <= 23) {
                if (!urinationsByDate[entry.date]) {
                    urinationsByDate[entry.date] = [];
                }
                // Store the time of urination
                urinationsByDate[entry.date].push(entry.time);
            }
        }
    });
    
    // Calculate average time between urinations for each date
    const avgTimeByDate = {};
    
    Object.entries(urinationsByDate).forEach(([date, times]) => {
        if (times.length <= 1) {
            // Need at least 2 urinations to calculate gap
            return;
        }
        
        // Sort times chronologically
        times.sort();
        
        // Calculate time differences in minutes
        let totalMinutes = 0;
        let gapCount = 0;
        
        for (let i = 1; i < times.length; i++) {
            const prevTime = times[i-1];
            const currTime = times[i];
            
            // Convert times to minutes since midnight
            const prevMinutes = (parseInt(prevTime.split(':')[0]) * 60) + parseInt(prevTime.split(':')[1]);
            const currMinutes = (parseInt(currTime.split(':')[0]) * 60) + parseInt(currTime.split(':')[1]);
            
            // Calculate difference
            const diffMinutes = currMinutes - prevMinutes;
            
            // Only count reasonable gaps (we already filtered for 8am-11pm entries)
            if (diffMinutes > 0) {
                totalMinutes += diffMinutes;
                gapCount++;
            }
        }
        
        // Calculate average if we have valid gaps
        if (gapCount > 0) {
            avgTimeByDate[date] = Math.round(totalMinutes / gapCount);
        }
    });
    
    return avgTimeByDate;
}

// Mobile-optimized Time Gap Chart function
function renderTimeGapChart() {
    try {
        const canvas = document.getElementById('timeGapCanvas');
        if (!canvas) return;
        
        setCanvasDimensions(canvas);
        clearCanvas(canvas);
        
        // Get average time between urinations by date
        const avgTimeByDate = calculateAverageTimeBetweenUrinations();
        
        // If we don't have data, show empty state
        if (Object.keys(avgTimeByDate).length === 0) {
            drawEmptyState(canvas, 'Not enough urination data to calculate time gaps');
            return;
        }
        
        // Convert to array and sort by date
        const timeData = Object.entries(avgTimeByDate)
            .sort(([dateA], [dateB]) => dateA.localeCompare(dateB))
            .slice(-7);  // Show last 7 days with data
        
        const ctx = canvas.getContext('2d');
        const width = canvas.width;
        const height = canvas.height;
        
        // Detect if we're on a small screen (like mobile)
        const isMobile = width < 400;
        
        // Adjust padding based on screen size
        const padding = {
            top: 30,
            right: isMobile ? 10 : 20, 
            // Increase bottom padding to prevent text overlap
            bottom: isMobile ? 70 : 40,
            left: isMobile ? 40 : 50
        };
        
        const chartWidth = width - padding.left - padding.right;
        const chartHeight = height - padding.top - padding.bottom;
        
        // Draw background
        ctx.fillStyle = '#f8f9fa';
        ctx.fillRect(0, 0, width, height);
        
        // Find the maximum average time for scaling
        let maxAvgTime = Math.max(...timeData.map(([, time]) => time));
        
        // Ensure max time is at least 3 hours for scale visibility
        maxAvgTime = Math.max(maxAvgTime, 180); // 3 hours = 180 minutes
        
        // Draw horizontal grid lines and y-axis
        ctx.strokeStyle = '#e2e8f0';
        ctx.lineWidth = 1;
        
        // Mobile-optimized grid lines - draw fewer on small screens
        const gridLines = isMobile ? 4 : 6;
        
        for (let i = 0; i <= gridLines; i++) {
            const y = padding.top + chartHeight - (i / gridLines) * chartHeight;
            ctx.beginPath();
            ctx.moveTo(padding.left, y);
            ctx.lineTo(width - padding.right, y);
            ctx.stroke();
            
            // Draw y-axis labels (convert minutes to hours and minutes)
            const minutes = Math.round((i / gridLines) * maxAvgTime);
            const hours = Math.floor(minutes / 60);
            const mins = minutes % 60;
            // Mobile-optimized labels
            const timeLabel = hours > 0 ? 
                (isMobile ? `${hours}h ${mins > 0 ? mins + 'm' : ''}` : `${hours}h ${mins}m`) :
                `${mins}m`;
            
            ctx.fillStyle = '#718096';
            // Smaller font on mobile
            ctx.font = isMobile ? '9px sans-serif' : '10px sans-serif';
            ctx.textAlign = 'right';
            ctx.textBaseline = 'middle';
            ctx.fillText(timeLabel, padding.left - 5, y);
        }
        
        // Create gradient for area under the line
        const gradient = ctx.createLinearGradient(0, padding.top, 0, height - padding.bottom);
        gradient.addColorStop(0, 'rgba(166, 81, 230, 0.2)'); // Similar to app's purple color
        gradient.addColorStop(1, 'rgba(166, 81, 230, 0.0)');
        
        // Calculate point width for data plotting
        const pointWidth = chartWidth / (timeData.length > 1 ? timeData.length - 1 : 1);
        
        // Draw area under the line
        ctx.beginPath();
        timeData.forEach(([date, avgTime], index) => {
            const x = padding.left + index * pointWidth;
            const y = padding.top + chartHeight - (avgTime / maxAvgTime) * chartHeight;
            
            if (index === 0) {
                ctx.moveTo(x, y);
            } else {
                ctx.lineTo(x, y);
            }
        });
        
        // Complete the area path
        ctx.lineTo(padding.left + (timeData.length - 1) * pointWidth, height - padding.bottom);
        ctx.lineTo(padding.left, height - padding.bottom);
        ctx.closePath();
        ctx.fillStyle = gradient;
        ctx.fill();
        
        // Draw the line
        ctx.beginPath();
        ctx.strokeStyle = '#a651e6'; // Using the app's purple color
        ctx.lineWidth = 2.5;
        
        timeData.forEach(([date, avgTime], index) => {
            const x = padding.left + index * pointWidth;
            const y = padding.top + chartHeight - (avgTime / maxAvgTime) * chartHeight;
            
            if (index === 0) {
                ctx.moveTo(x, y);
            } else {
                ctx.lineTo(x, y);
            }
            
            // Draw x-axis labels with mobile optimization
            ctx.fillStyle = '#718096';
            // Smaller font on mobile
            ctx.font = isMobile ? '9px sans-serif' : '10px sans-serif';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'top';
            
            // Format dates differently for mobile
            let displayDate;
            if (isMobile) {
                // Show minimal date format on mobile ("25" instead of "Feb 25")
                const dateParts = date.split('-');
                const day = parseInt(dateParts[2]);
                displayDate = `${day}`;
            } else {
                displayDate = formatDate(date);
            }
            
            ctx.save();
            // Position labels farther from axis on mobile
            const labelY = height - padding.bottom + (isMobile ? 8 : 5);
            ctx.translate(x, labelY);
            // More rotation on mobile to prevent overlap
            ctx.rotate(isMobile ? -Math.PI / 3 : -Math.PI / 4);
            ctx.fillText(displayDate, 0, 0);
            ctx.restore();
        });
        
        ctx.stroke();
        
        // Add month labels for mobile displays
        if (isMobile && timeData.length > 0) {
            // Add month labels above the day numbers
            timeData.forEach(([date], index) => {
                const dateParts = date.split('-');
                const monthIndex = parseInt(dateParts[1]) - 1; // 0-based month
                const months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];
                
                // Only show month for first day of month or first data point
                if (index === 0 || dateParts[2] === '01') {
                    const x = padding.left + index * pointWidth;
                    ctx.fillStyle = '#a0aec0'; // Lighter color for month
                    ctx.font = '8px sans-serif'; // Smaller than day
                    ctx.textAlign = 'center';
                    ctx.fillText(months[monthIndex], x, height - padding.bottom + 20);
                }
            });
        }
        
        // Draw data points and values
        timeData.forEach(([date, avgTime], index) => {
            const x = padding.left + index * pointWidth;
            const y = padding.top + chartHeight - (avgTime / maxAvgTime) * chartHeight;
            
            // Draw point with gradient circle
            const pointGradient = ctx.createRadialGradient(x, y, 0, x, y, 6);
            pointGradient.addColorStop(0, '#a651e6');
            pointGradient.addColorStop(1, '#4f9cf9');
            
            ctx.beginPath();
            // Smaller points on mobile
            const pointRadius = isMobile ? 5 : 6;
            ctx.arc(x, y, pointRadius, 0, Math.PI * 2);
            ctx.fillStyle = pointGradient;
            ctx.fill();
            ctx.strokeStyle = 'white';
            ctx.lineWidth = 2;
            ctx.stroke();
            
            // Draw time value with nicer formatting
            const hours = Math.floor(avgTime / 60);
            const mins = Math.round(avgTime % 60);
            
            // Mobile-optimized time label
            const timeLabel = isMobile ? 
                `${hours}h ${mins > 0 ? mins + 'm' : ''}` :
                `${hours}h ${mins}m`;
            
            // Draw with small shadow for better readability
            ctx.fillStyle = '#4a5568';
            ctx.font = isMobile ? 'bold 9px sans-serif' : 'bold 10px sans-serif';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'bottom';
            ctx.fillText(timeLabel, x, y - (isMobile ? 8 : 10));
        });
        
        // Highlight the "golden window" of 3-4 hours (180-240 minutes)
        const goldenMinLower = 180; // 3 hours in minutes
        const goldenMinUpper = 240; // 4 hours in minutes
        
        // Only show golden window if it's within our data range
        if (maxAvgTime > goldenMinLower) {
            // Calculate y positions for the golden window
            const goldenLowerY = padding.top + chartHeight - Math.min(goldenMinLower / maxAvgTime, 1) * chartHeight;
            const goldenUpperY = padding.top + chartHeight - Math.min(goldenMinUpper / maxAvgTime, 1) * chartHeight;
            
            // Draw the golden window zone with more transparency on mobile
            ctx.fillStyle = isMobile ? 'rgba(249, 199, 79, 0.10)' : 'rgba(249, 199, 79, 0.15)';
            ctx.fillRect(padding.left, goldenUpperY, chartWidth, goldenLowerY - goldenUpperY);
            
            // Add a subtle border
            ctx.strokeStyle = 'rgba(249, 199, 79, 0.5)';
            ctx.setLineDash([3, 3]);
            ctx.lineWidth = 1;
            
            // Upper line
            ctx.beginPath();
            ctx.moveTo(padding.left, goldenUpperY);
            ctx.lineTo(padding.left + chartWidth, goldenUpperY);
            ctx.stroke();
            
            // Lower line
            ctx.beginPath();
            ctx.moveTo(padding.left, goldenLowerY);
            ctx.lineTo(padding.left + chartWidth, goldenLowerY);
            ctx.stroke();
            
            // Reset line dash
            ctx.setLineDash([]);
            
            // Label for golden window - position in upper part for mobile
            ctx.fillStyle = 'rgba(249, 151, 79, 0.8)';
            ctx.font = isMobile ? 'bold 9px sans-serif' : 'bold 10px sans-serif';
            ctx.textAlign = 'left';
            ctx.textBaseline = 'middle';
            
            // Position label higher in the window on mobile
            const labelY = isMobile ? 
                (goldenUpperY + (goldenLowerY - goldenUpperY) * 0.3) : 
                ((goldenUpperY + goldenLowerY) / 2);
                
            ctx.fillText(
                isMobile ? 'Golden Window (3-4h)' : 'Golden Window (3-4h)',
                padding.left + 5, 
                labelY
            );
        }
        
        // Calculate and draw trend line
        if (timeData.length >= 2) {
            // Simple linear regression
            let sumX = 0, sumY = 0, sumXY = 0, sumXX = 0;
            const n = timeData.length;
            
            timeData.forEach(([, avgTime], index) => {
                sumX += index;
                sumY += avgTime;
                sumXY += index * avgTime;
                sumXX += index * index;
            });
            
            const slope = (n * sumXY - sumX * sumY) / (n * sumXX - sumX * sumX);
            const intercept = (sumY - slope * sumX) / n;
            
            // Calculate start and end points for trend line
            const startX = padding.left;
            const startY = padding.top + chartHeight - (intercept / maxAvgTime) * chartHeight;
            
            const endX = padding.left + (timeData.length - 1) * pointWidth;
            const endY = padding.top + chartHeight - ((intercept + slope * (timeData.length - 1)) / maxAvgTime) * chartHeight;
            
            // Draw trend line
            ctx.beginPath();
            ctx.moveTo(startX, startY);
            ctx.lineTo(endX, endY);
            ctx.strokeStyle = slope > 0 ? '#22c55e' : '#e53e3e'; // Green if increasing, red if decreasing
            ctx.lineWidth = 2;
            ctx.setLineDash([5, 3]);
            ctx.stroke();
            ctx.setLineDash([]);
            
            // Determine trend direction relative to golden window
            let trendMessage = '';
            let trendColor = '';
            let trendIcon = '';
            
            // Get the latest average time
            const latestAvgTime = timeData[timeData.length - 1][1];
            
            if (slope > 0) {
                // Time between urinations is increasing
                if (latestAvgTime < goldenMinLower) {
                    trendMessage = isMobile ? 'Trending toward golden window' : 'Trending toward golden window';
                    trendColor = '#22c55e'; // Green (good)
                    trendIcon = '👍';
                } else if (latestAvgTime > goldenMinUpper) {
                    trendMessage = isMobile ? 'Trending away from golden window' : 'Trending away from golden window';
                    trendColor = '#e53e3e'; // Red (bad)
                    trendIcon = '👎';
                } else {
                    trendMessage = isMobile ? 'Trending toward longer intervals' : 'Trending toward longer intervals';
                    trendColor = '#eab308'; // Yellow (neutral)
                    trendIcon = '➡️';
                }
            } else {
                // Time between urinations is decreasing
                if (latestAvgTime > goldenMinUpper) {
                    trendMessage = isMobile ? 'Trending toward golden window' : 'Trending toward golden window';
                    trendColor = '#22c55e'; // Green (good)
                    trendIcon = '👍';
                } else if (latestAvgTime < goldenMinLower) {
                    trendMessage = isMobile ? 'Trending away from golden window' : 'Trending away from golden window';
                    trendColor = '#e53e3e'; // Red (bad)
                    trendIcon = '👎';
                } else {
                    trendMessage = isMobile ? 'Trending toward shorter intervals' : 'Trending toward shorter intervals';
                    trendColor = '#eab308'; // Yellow (neutral)
                    trendIcon = '➡️';
                }
            }
            
            // Draw trend message - Position HIGHER for mobile
            ctx.fillStyle = trendColor;
            // Smaller font on mobile
            ctx.font = isMobile ? 'bold 11px sans-serif' : 'bold 12px sans-serif';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'top';
            
            // Draw message well ABOVE the x-axis labels on mobile
            const messageY = height - padding.bottom + (isMobile ? 32 : 22);
            
            ctx.fillText(
                `${trendIcon} ${trendMessage}`,
                width / 2,
                messageY
            );
        }
        
        // Draw an improved note about the data with clearer explanation
ctx.fillStyle = '#718096';
// Smaller font on mobile
ctx.font = isMobile ? 'italic 8px sans-serif' : 'italic 10px sans-serif';
ctx.textAlign = 'center';
ctx.textBaseline = 'top';

// Position well below the trend message on mobile
const noteY = height - padding.bottom + (isMobile ? 48 : 42);

ctx.fillText(
    '* Only includes urinations between 8am and 11pm',
    width / 2,
    noteY
);
        
    } catch (error) {
        console.error('Error rendering time gap chart', error);
        const canvas = document.getElementById('timeGapCanvas');
        if (canvas) {
            drawEmptyState(canvas, 'Could not generate chart');
        }
    }
}

// Additional helper function for chart height optimization
function optimizeChartContainers() {
    // Make sure all chart containers have proper height on mobile
    const isMobile = window.innerWidth < 480;
    const charts = document.querySelectorAll('.chart-container');
    
    charts.forEach(chart => {
        // Find the specific chart
        if (chart.querySelector('#timeGapChart')) {
            // Set appropriate height for the time gap chart
            const timeGapChart = chart.querySelector('#timeGapChart');
            timeGapChart.style.height = isMobile ? '300px' : '220px';
        }
        
        // Optimize frequency chart height
        if (chart.querySelector('#frequencyChart')) {
            const frequencyChart = chart.querySelector('#frequencyChart');
            frequencyChart.style.height = isMobile ? '280px' : '220px';
        }
        
        // Optimize urgency chart height
        if (chart.querySelector('#urgencyChart')) {
            const urgencyChart = chart.querySelector('#urgencyChart');
            urgencyChart.style.height = isMobile ? '280px' : '220px';
        }
        
        // Optimize correlation chart height
        if (chart.querySelector('#correlationChart')) {
            const correlationChart = chart.querySelector('#correlationChart');
            correlationChart.style.height = isMobile ? '280px' : '220px';
        }
        
        // Optimize stream chart height
        if (chart.querySelector('#streamChart')) {
            const streamChart = chart.querySelector('#streamChart');
            streamChart.style.height = isMobile ? '320px' : '350px';
        }
    });
}

// Add optimizeChartContainers function to dynamically set chart heights
function optimizeChartContainers() {
    // Make sure all chart containers have proper height on mobile
    const isMobile = window.innerWidth < 480;
    const charts = document.querySelectorAll('.chart-container');
    
    charts.forEach(chart => {
        // Find the specific chart
        if (chart.querySelector('#timeGapChart')) {
            // Set appropriate height for the time gap chart
            const timeGapChart = chart.querySelector('#timeGapChart');
            timeGapChart.style.height = isMobile ? '300px' : '220px';
        }
        
        // Optimize frequency chart height
        if (chart.querySelector('#frequencyChart')) {
            const frequencyChart = chart.querySelector('#frequencyChart');
            frequencyChart.style.height = isMobile ? '280px' : '220px';
        }
        
        // Optimize urgency chart height
        if (chart.querySelector('#urgencyChart')) {
            const urgencyChart = chart.querySelector('#urgencyChart');
            urgencyChart.style.height = isMobile ? '280px' : '220px';
        }
        
        // Optimize correlation chart height
        if (chart.querySelector('#correlationChart')) {
            const correlationChart = chart.querySelector('#correlationChart');
            correlationChart.style.height = isMobile ? '280px' : '220px';
        }
        
        // Optimize stream chart height
        if (chart.querySelector('#streamChart')) {
            const streamChart = chart.querySelector('#streamChart');
            streamChart.style.height = isMobile ? '320px' : '350px';
        }
    });
}

// Call this function on page load and window resize
window.addEventListener('load', optimizeChartContainers);
window.addEventListener('resize', optimizeChartContainers);
    </script>
</body>
</html>
