<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black">
    <meta name="apple-mobile-web-app-title" content="Bladder Diary">
    <title>Bladder Diary</title>
    <style>
        /* Basic reset */
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
        }
        
        body {
            background-color: #f7f7f7;
            color: #333;
            line-height: 1.6;
            padding: 16px;
            max-width: 500px;
            margin: 0 auto;
            overflow-x: hidden; /* Prevent horizontal scrolling */
        }
        
        /* Header styles */
        header {
            text-align: center;
            margin-bottom: 16px;
        }
        
        .app-logo {
            width: 64px;
            height: 64px;
            border-radius: 50%;
            background: linear-gradient(135deg, #4f9cf9, #a651e6, #f9c74f);
            margin: 0 auto 12px;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .app-logo-inner {
            width: 56px;
            height: 56px;
            border-radius: 50%;
            background: white;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .app-logo-core {
            width: 48px;
            height: 48px;
            border-radius: 50%;
            background: linear-gradient(135deg, #4f9cf9, #a651e6, #f9c74f);
            opacity: 0.8;
        }
        
        h1 {
            font-size: 24px;
            color: #333;
            margin-bottom: 4px;
        }
        
        .subtitle {
            font-size: 14px;
            color: #666;
        }
        
        /* Privacy notice */
        .privacy-notice {
            text-align: center;
            font-size: 12px;
            color: #718096;
            background-color: rgba(237, 242, 247, 0.7);
            border-radius: 8px;
            padding: 8px 12px;
            margin-bottom: 16px;
            line-height: 1.4;
        }
        
        .privacy-notice svg {
            width: 14px;
            height: 14px;
            vertical-align: middle;
            margin-right: 4px;
        }
        
        /* Button styles */
        .btn {
            display: block;
            width: 100%;
            padding: 12px;
            border-radius: 8px;
            border: none;
            font-weight: 500;
            cursor: pointer;
            text-align: center;
            margin-bottom: 16px;
            font-size: 16px;
        }
        
        .btn-primary {
            background-color: #5a67d8;
            color: white;
        }
        
        .btn-primary:hover {
            background-color: #4c51bf;
        }
        
        .btn-success {
            background-color: #48bb78;
            color: white;
        }
        
        .btn-success:hover {
            background-color: #38a169;
        }
        
        .btn-danger {
            background-color: #e53e3e;
            color: white;
            padding: 8px 12px;
            border-radius: 4px;
            font-size: 14px;
            display: inline-block;
            width: auto;
            margin-bottom: 0;
        }
        
        .btn-secondary {
            background-color: #4299e1;
            color: white;
            padding: 8px 16px;
            font-size: 14px;
            margin: 8px 0;
            display: inline-block;
        }
        
        /* Timer button styles */
        .timer-btn {
            background-color: #4299e1;
            color: white;
            padding: 8px 12px;
            border-radius: 4px;
            border: none;
            font-size: 14px;
            cursor: pointer;
            display: inline-flex;
            align-items: center;
            margin-left: 8px;
        }
        
        .timer-btn.active {
            background-color: #e53e3e;
        }
        
        .timer-btn svg {
            margin-right: 4px;
            width: 14px;
            height: 14px;
        }
        
        /* Timer indicator */
        .timer-indicator {
            display: inline-block;
            margin-left: 8px;
            font-size: 14px;
            font-weight: 500;
            color: #e53e3e;
        }
        
        /* Timer field container */
        .timer-field-container {
            display: flex;
            align-items: center;
        }
        
        /* Form styles */
        .form {
            background-color: white;
            padding: 16px;
            border-radius: 8px;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
            margin-bottom: 24px;
        }
        
        .form.hidden {
            display: none;
        }
        
        .form-group {
            margin-bottom: 16px;
        }
        
        .form-group.grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 12px;
        }
        
        .form-label {
            display: block;
            font-size: 14px;
            font-weight: 500;
            margin-bottom: 4px;
            color: #4a5568;
        }
        
        .form-control {
            display: block;
            width: 100%;
            padding: 8px;
            border: 1px solid #e2e8f0;
            border-radius: 4px;
            font-size: 16px;
        }
        
        .form-control:focus {
            border-color: #a0aec0;
            outline: none;
        }
        
        .form-check {
            display: flex;
            align-items: center;
        }
        
        .form-check-input {
            margin-right: 8px;
        }
        
        .section-header {
            font-size: 16px;
            font-weight: 500;
            color: #4a5568;
            margin-bottom: 8px;
            padding-top: 8px;
            border-top: 1px solid #e2e8f0;
        }
        
        /* Entries list */
        .card {
            background-color: white;
            border-radius: 8px;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
            overflow: hidden;
            margin-bottom: 16px;
        }
        
        .card-header {
            background-color: #f8fafc;
            padding: 12px 16px;
            border-bottom: 1px solid #e2e8f0;
        }
        
        .card-title {
            font-size: 18px;
            font-weight: 500;
            color: #4a5568;
        }
        
        .card-body {
            padding: 16px;
        }
        
        .entry-item {
            padding: 16px;
            border-bottom: 1px solid #e2e8f0;
        }
        
        .entry-header {
            display: flex;
            justify-content: space-between;
            margin-bottom: 8px;
            align-items: center;
        }
        
        .entry-date {
            font-weight: 500;
            color: #2d3748;
        }
        
        .entry-details {
            display: grid;
            grid-template-columns: auto 1fr;
            gap: 4px 8px;
            font-size: 14px;
            color: #4a5568;
        }
        
        .entry-label {
            font-weight: 500;
        }
        
        .no-entries {
            text-align: center;
            color: #a0aec0;
            padding: 24px;
        }
        
        /* Message styles */
        .message {
            padding: 12px;
            border-radius: 4px;
            margin-bottom: 16px;
        }
        
        .message-danger {
            background-color: #fed7d7;
            border: 1px solid #feb2b2;
            color: #c53030;
        }
        
        .message-success {
            background-color: #c6f6d5;
            border: 1px solid #9ae6b4;
            color: #2f855a;
        }
        
        .hidden {
            display: none;
        }
        
        /* Export section */
        .export-section {
            margin-top: 24px;
            margin-bottom: 32px;
        }
        
        .export-textarea {
            width: 100%;
            height: 200px;
            padding: 8px;
            border: 1px solid #e2e8f0;
            border-radius: 4px;
            font-family: monospace;
            margin-bottom: 8px;
            display: none;
        }
        
        .helper-text {
            font-size: 12px;
            color: #718096;
            margin-top: 8px;
        }
        
        /* Storage warning */
        .storage-warning {
            background-color: #feebc8;
            border: 1px solid #f6ad55;
            color: #c05621;
            border-radius: 4px;
            padding: 8px 12px;
            margin-bottom: 16px;
            font-size: 14px;
            display: none;
        }
        
        /* Pull to refresh styles */
        .pull-to-refresh {
            height: 0;
            overflow: hidden;
            text-align: center;
            transition: height 0.3s;
            position: relative;
            margin-bottom: 8px;
        }
        
        .pull-to-refresh-icon {
            display: inline-block;
            margin-top: 10px;
            transition: transform 0.3s;
        }
        
        .pull-to-refresh.visible {
            height: 60px;
        }
        
        .pull-to-refresh.refreshing .pull-to-refresh-icon {
            animation: spin 1s linear infinite;
        }
        
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        
        /* Pulse animation for active timer */
        @keyframes pulse {
            0% { opacity: 1; }
            50% { opacity: 0.5; }
            100% { opacity: 1; }
        }
        
        .pulse {
            animation: pulse 1s infinite;
        }
        
        /* Dashboard section */
        .dashboard-section {
            margin-top: 24px;
            margin-bottom: 24px;
        }
        
        .dashboard {
            margin-top: 16px;
        }
        
        .dashboard.hidden {
            display: none;
        }
        
        /* Chart containers */
        .chart-container {
            margin-bottom: 32px;
            background-color: #fcfcfc;
            border-radius: 6px;
            padding: 12px;
            border: 1px solid #f0f0f0;
        }
        
        .chart-title {
            font-size: 16px;
            font-weight: 500;
            color: #4a5568;
            margin-bottom: 12px;
            text-align: center;
        }
        
        .chart {
            height: 220px;
            width: 100%;
            position: relative;
        }
        
        /* IMPROVED: Bar chart styling */
        .bar-chart {
            display: flex;
            align-items: flex-end;
            height: 150px;
            padding-bottom: 24px;
            position: relative;
        }
        
        .bar-container {
            flex: 1;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 0 4px;
            position: relative;
        }
        
        .bar {
            width: 80%;
            max-width: 32px;
            background: linear-gradient(to top, #4f9cf9, #a651e6);
            border-radius: 4px 4px 0 0;
            transition: height 0.3s;
            min-height: 2px;
        }
        
        .bar-label {
            font-size: 10px;
            color: #718096;
            margin-top: 6px;
            text-align: center;
            position: absolute;
            bottom: -24px;
            white-space: nowrap;
            transform: rotate(-45deg);
            transform-origin: top left;
            left: 50%;
        }
        
        .bar-value {
            font-size: 10px;
            color: #4a5568;
            position: absolute;
            top: -16px;
            left: 50%;
            transform: translateX(-50%);
            white-space: nowrap;
        }
        
        /* IMPROVED: Pie chart styling */
        .pie-chart {
            display: flex;
            align-items: center;
            justify-content: center;
            height: 150px;
            padding: 10px;
        }
        
        .pie-container {
            position: relative;
            width: 120px;
            height: 120px;
        }
        
        .pie-slice {
            position: absolute;
            width: 100%;
            height: 100%;
            border-radius: 50%;
            clip-path: polygon(50% 50%, 100% 0, 100% 100%);
            transform-origin: center;
        }
        
        .pie-legend {
            margin-left: 24px;
            display: flex;
            flex-direction: column;
        }
        
        .legend-item {
            display: flex;
            align-items: center;
            margin-bottom: 8px;
        }
        
        .legend-color {
            width: 12px;
            height: 12px;
            margin-right: 8px;
            border-radius: 2px;
        }
        
        .legend-label {
            font-size: 12px;
            color: #4a5568;
        }
        
        /* IMPROVED: Comparison chart styling */
        .comparison-chart {
            display: flex;
            height: 150px;
            align-items: flex-end;
            position: relative;
            padding-bottom: 32px;
        }
        
        .comparison-bar-group {
            flex: 1;
            display: flex;
            justify-content: center;
            gap: 4px;
            position: relative;
        }
        
        .comparison-bar {
            width: 20px;
            border-radius: 4px 4px 0 0;
            transition: height 0.3s;
            min-height: 2px;
        }
        
        .comparison-bar.primary {
            background-color: #4f9cf9;
        }
        
        .comparison-bar.secondary {
            background-color: #a651e6;
        }
        
        .comparison-label {
            position: absolute;
            bottom: -24px;
            font-size: 10px;
            color: #718096;
            transform: rotate(-45deg);
            transform-origin: top left;
            white-space: nowrap;
            left: 50%;
        }
        
        .comparison-bar-value {
            position: absolute;
            top: -16px;
            font-size: 10px;
            color: #4a5568;
            text-align: center;
            white-space: nowrap;
            left: 50%;
            transform: translateX(-50%);
        }
        
        .comparison-legend {
            display: flex;
            justify-content: center;
            margin-top: 16px;
        }
        
        .comparison-legend-item {
            display: flex;
            align-items: center;
            margin: 0 8px;
        }
        
        .comparison-legend-color {
            width: 12px;
            height: 12px;
            margin-right: 6px;
            border-radius: 2px;
        }
        
        /* Stats cards */
        .stats-container {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 12px;
            margin-bottom: 24px;
        }
        
        .stat-card {
            background-color: white;
            border-radius: 6px;
            padding: 12px;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.05);
            text-align: center;
        }
        
        .stat-value {
            font-size: 24px;
            font-weight: 600;
            color: #4f9cf9;
        }
        
        .stat-label {
            font-size: 12px;
            color: #718096;
            margin-top: 4px;
        }
        
        /* Empty state styling */
        .empty-chart {
            height: 150px;
            display: flex;
            align-items: center;
            justify-content: center;
            flex-direction: column;
            color: #a0aec0;
        }
        
        .empty-chart svg {
            width: 24px;
            height: 24px;
            margin-bottom: 8px;
            stroke: #cbd5e0;
        }
        
        .empty-chart-text {
            font-size: 14px;
        }

        /* IMPROVED: Canvas-based charts */
        .canvas-container {
            height: 180px;
            width: 100%;
            position: relative;
        }
    </style>
</head>
<body>
    <div class="pull-to-refresh" id="pullToRefresh">
        <div class="pull-to-refresh-icon">
            <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                <path d="M23 4v6h-6"></path>
                <path d="M20.49 15a9 9 0 1 1-2.12-9.36L23 10"></path>
            </svg>
        </div>
    </div>
    
    <div class="container">
        <header>
            <div class="app-logo">
                <div class="app-logo-inner">
                    <div class="app-logo-core"></div>
                </div>
            </div>
            <h1>Bladder Diary</h1>
            <p class="subtitle">Track your bladder health</p>
        </header>
        
        <div class="privacy-notice">
            <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                <rect x="3" y="11" width="18" height="11" rx="2" ry="2"></rect>
                <path d="M7 11V7a5 5 0 0 1 10 0v4"></path>
            </svg>
            Your data is stored privately and securely on your device only
        </div>
        
        <div id="storageWarning" class="storage-warning">
            Storage is not working properly. Your entries won't be saved between sessions.
        </div>
        
        <button id="toggleFormBtn" class="btn btn-primary">
            Add New Entry
        </button>
        
        <div id="messageArea" class="message hidden"></div>
        
        <form id="entryForm" class="form hidden">
            <div class="form-group grid">
                <div>
                    <label class="form-label" for="date">Date</label>
                    <input class="form-control" type="date" id="date" name="date" required>
                </div>
                <div>
                    <label class="form-label" for="time">Time</label>
                    <input class="form-control" type="time" id="time" name="time" required>
                </div>
            </div>
            
            <h3 class="section-header">Drink</h3>
            <div class="form-group grid">
                <div>
                    <label class="form-label" for="drinkType">Type</label>
                    <select class="form-control" id="drinkType" name="drinkType">
                        <option value="">Select type</option>
                        <option value="Water">Water</option>
                        <option value="Coffee">Coffee</option>
                        <option value="Tea">Tea</option>
                        <option value="Juice">Juice</option>
                        <option value="Soda">Soda</option>
                        <option value="Alcohol">Alcohol</option>
                        <option value="Other">Other</option>
                    </select>
                </div>
                <div>
                    <label class="form-label" for="drinkAmount">Amount (ml)</label>
                    <input class="form-control" type="number" id="drinkAmount" name="drinkAmount" placeholder="ml">
                </div>
            </div>
            
            <h3 class="section-header">Urine</h3>
            <div class="form-group grid">
                <div>
                    <label class="form-label" for="urineVolume">Duration (seconds)</label>
                    <div class="timer-field-container">
                        <input class="form-control" type="number" id="urineVolume" name="urineVolume" placeholder="seconds">
                        <button type="button" id="timerBtn" class="timer-btn">
                            <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                <circle cx="12" cy="12" r="10"></circle>
                                <polyline points="12 6 12 12 16 14"></polyline>
                            </svg>
                            Start
                        </button>
                    </div>
                    <div id="timerIndicator" class="timer-indicator hidden">0s</div>
                </div>
                <div>
                    <label class="form-label" for="urgency">Urgency (0-3)</label>
                    <select class="form-control" id="urgency" name="urgency">
                        <option value="">Select level</option>
                        <option value="0">0 (None)</option>
                        <option value="1">1 (Mild)</option>
                        <option value="2">2 (Moderate)</option>
                        <option value="3">3 (Severe)</option>
                    </select>
                </div>
            </div>
            
            <h3 class="section-header">Urine Flow</h3>
            <div class="form-group">
                <label class="form-label" for="urineStream">Urine Stream</label>
                <select class="form-control" id="urineStream" name="urineStream">
                    <option value="">Select type</option>
                    <option value="Strong">Strong</option>
                    <option value="Intermittent">Intermittent</option>
                    <option value="Weak">Weak</option>
                </select>
            </div>
            
            <button type="submit" class="btn btn-success">Save Entry</button>
        </form>
        
        <div class="card">
            <div class="card-header">
                <h2 class="card-title">Recent Entries</h2>
            </div>
            <div id="entriesList" class="card-body">
                <p id="noEntriesMsg" class="no-entries">No entries yet. Add your first one!</p>
            </div>
        </div>

        <!-- Dashboard section -->
        <div class="dashboard-section">
            <button id="toggleDashboardBtn" class="btn btn-secondary">Show Dashboard</button>
            
            <div id="dashboard" class="dashboard hidden">
                <div class="card">
                    <div class="card-header">
                        <h2 class="card-title">Your Progress Dashboard</h2>
                    </div>
                    <div class="card-body">
                        <div id="noDataMsg" class="no-entries">No data available yet. Add entries to see your dashboard.</div>
                        
                        <div id="dashboardCharts" class="hidden">
                            <!-- Frequency chart -->
                            <div class="chart-container">
                                <h3 class="chart-title">Daily Urination Frequency</h3>
                                <div class="chart" id="frequencyChart">
                                    <canvas id="frequencyCanvas" class="canvas-container"></canvas>
                                </div>
                            </div>
                            
                            <!-- Urgency levels chart -->
                            <div class="chart-container">
                                <h3 class="chart-title">Urgency Levels</h3>
                                <div class="chart" id="urgencyChart">
                                    <canvas id="urgencyCanvas" class="canvas-container"></canvas>
                                </div>
                            </div>
                            
                            <!-- Fluid intake vs urination -->
                            <div class="chart-container">
                                <h3 class="chart-title">Fluid Intake vs Urination</h3>
                                <div class="chart" id="correlationChart">
                                    <canvas id="correlationCanvas" class="canvas-container"></canvas>
                                </div>
                            </div>
                            
                            <!-- Stream strength distribution -->
                            <div class="chart-container">
                                <h3 class="chart-title">Urine Stream Strength</h3>
                                <div class="chart" id="streamChart">
                                    <canvas id="streamCanvas" class="canvas-container"></canvas>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <div class="export-section">
            <button id="toggleExportBtn" class="btn btn-secondary">Show Export Data</button>
            <textarea id="exportArea" class="export-textarea"></textarea>
            <p class="helper-text">Text is automatically selected for copying</p>
        </div>
    </div>

    <script>
        // DOM elements
        const toggleFormBtn = document.getElementById('toggleFormBtn');
        const entryForm = document.getElementById('entryForm');
        const entriesList = document.getElementById('entriesList');
        const noEntriesMsg = document.getElementById('noEntriesMsg');
        const toggleExportBtn = document.getElementById('toggleExportBtn');
        const exportArea = document.getElementById('exportArea');
        const messageArea = document.getElementById('messageArea');
        const storageWarning = document.getElementById('storageWarning');
        const pullToRefresh = document.getElementById('pullToRefresh');
        const timerBtn = document.getElementById('timerBtn');
        const timerIndicator = document.getElementById('timerIndicator');
        const urineVolumeInput = document.getElementById('urineVolume');
        const toggleDashboardBtn = document.getElementById('toggleDashboardBtn');
        const dashboard = document.getElementById('dashboard');
        const noDataMsg = document.getElementById('noDataMsg');
        const dashboardCharts = document.getElementById('dashboardCharts');
        
        // Timer variables
        let timerActive = false;
        let timerStart = 0;
        let timerInterval = null;
        
        // Pull-to-refresh variables
        let touchStartY = 0;
        let touchEndY = 0;
        let isRefreshing = false;
        
        // Check if localStorage is available
        let localStorageAvailable = false;
        try {
            localStorage.setItem("test", "test");
            localStorage.removeItem("test");
            localStorageAvailable = true;
            storageWarning.style.display = 'none';
        } catch (e) {
            console.error("localStorage not available:", e);
            storageWarning.style.display = 'block';
            localStorageAvailable = false;
        }
        
        // In-memory storage (backup if localStorage fails)
        let entries = [];
        
        // Timer functionality
        timerBtn.addEventListener('click', function() {
            if (!timerActive) {
                // Start timer
                timerActive = true;
                timerStart = Date.now();
                timerBtn.textContent = 'Stop';
                timerBtn.classList.add('active');
                timerIndicator.classList.remove('hidden');
                timerIndicator.classList.add('pulse');
                
                // Update timer display
                timerInterval = setInterval(function() {
                    const elapsedSeconds = Math.floor((Date.now() - timerStart) / 1000);
                    timerIndicator.textContent = elapsedSeconds + 's';
                }, 1000);
            } else {
                // Stop timer
                timerActive = false;
                clearInterval(timerInterval);
                const elapsedSeconds = Math.floor((Date.now() - timerStart) / 1000);
                
                // Set value to input field
                urineVolumeInput.value = elapsedSeconds;
                
                // Reset timer UI
                timerBtn.textContent = 'Start';
                timerBtn.classList.remove('active');
                timerIndicator.classList.add('hidden');
                timerIndicator.classList.remove('pulse');
            }
        });
        
        // Load entries from storage
        function loadEntries() {
            try {
                if (localStorageAvailable) {
                    const stored = localStorage.getItem('bladderDiaryEntries');
                    if (stored) {
                        entries = JSON.parse(stored);
                    }
                }
                renderEntries();
            } catch (e) {
                console.error("Error loading entries:", e);
                showMessage("Error loading saved entries", "danger");
            }
        }
        
        // Save entries to storage
        function saveEntries() {
            try {
                if (localStorageAvailable) {
                    localStorage.setItem('bladderDiaryEntries', JSON.stringify(entries));
                }
            } catch (e) {
                console.error("Error saving entries:", e);
                showMessage("Error saving entries", "danger");
            }
        }
        
        // Helper function to show a message
        function showMessage(message, type = 'danger') {
            messageArea.textContent = message;
            messageArea.className = `message message-${type}`;
            messageArea.style.display = 'block';
            setTimeout(function() {
                messageArea.style.display = 'none';
            }, 3000);
        }
        
        // Set current date and time
        function setCurrentDateTime() {
            try {
                const now = new Date();
                const dateInput = document.getElementById('date');
                const timeInput = document.getElementById('time');
                
                // Format date as YYYY-MM-DD
                const year = now.getFullYear();
                const month = String(now.getMonth() + 1).padStart(2, '0');
                const day = String(now.getDate()).padStart(2, '0');
                dateInput.value = `${year}-${month}-${day}`;
                
                // Format time as HH:MM
                const hours = String(now.getHours()).padStart(2, '0');
                const minutes = String(now.getMinutes()).padStart(2, '0');
                timeInput.value = `${hours}:${minutes}`;
            } catch (error) {
                console.error('Error setting date/time', error);
            }
        }
        
        // Toggle form visibility
        toggleFormBtn.addEventListener('click', function() {
            try {
                if (entryForm.style.display === 'none' || entryForm.style.display === '') {
                    entryForm.style.display = 'block';
                    toggleFormBtn.textContent = 'Cancel';
                    setCurrentDateTime();
                } else {
                    // Make sure timer is stopped if form is closed
                    if (timerActive) {
                        timerActive = false;
                        clearInterval(timerInterval);
                        timerBtn.textContent = 'Start';
                        timerBtn.classList.remove('active');
                        timerIndicator.classList.add('hidden');
                        timerIndicator.classList.remove('pulse');
                    }
                    
                    entryForm.style.display = 'none';
                    toggleFormBtn.textContent = 'Add New Entry';
                    entryForm.reset();
                }
            } catch (error) {
                console.error('Error toggling form', error);
                showMessage('Error showing form');
            }
        });
        
        // Format date for display - FIXED to handle timezone issues
        function formatDate(dateString) {
            try {
                // Parse the date parts directly from the string to avoid timezone issues
                const [year, month, day] = dateString.split('-').map(num => parseInt(num, 10));
                
                // Month names for display
                const months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];
                
                // JavaScript months are 0-based, so subtract 1 from the month
                return `${months[month-1]} ${day}`;
            } catch (error) {
                console.error('Error formatting date', error);
                return dateString;
            }
        }
        
        // Delete entry function
        function deleteEntryAtIndex(index) {
            try {
                if (confirm('Are you sure you want to delete this entry?')) {
                    entries.splice(index, 1);
                    saveEntries();
                    renderEntries();
                    showMessage('Entry deleted', 'success');
                }
            } catch (error) {
                console.error('Error deleting entry', error);
                showMessage('Error deleting entry');
            }
        }
        
        // Make the delete function globally available
        window.deleteEntryAtIndex = deleteEntryAtIndex;
        
        // Render entries list
        function renderEntries() {
            try {
                // Clear all children except noEntriesMsg
                while (entriesList.firstChild) {
                    entriesList.removeChild(entriesList.firstChild);
                }
                
                // Add the "no entries" message back
                entriesList.appendChild(noEntriesMsg);
                
                if (entries.length === 0) {
                    noEntriesMsg.style.display = 'block';
                    return;
                }
                
                noEntriesMsg.style.display = 'none';
                
                // Sort entries by date and time (newest first)
                entries.sort(function(a, b) {
                    // Compare dates directly as strings (YYYY-MM-DD format sorts correctly)
                    if (a.date !== b.date) {
                        return a.date < b.date ? 1 : -1;
                    }
                    // If dates are the same, compare times
                    return a.time < b.time ? 1 : -1;
                });
                
                // Add each entry to the list
                for (let i = 0; i < entries.length; i++) {
                    const entry = entries[i];
                    const entryEl = document.createElement('div');
                    entryEl.className = 'entry-item';
                    
                    let entryHtml = `
                        <div class="entry-header">
                            <div class="entry-date">
                                ${formatDate(entry.date)} at ${entry.time}
                            </div>
                            <button class="btn-danger" type="button" onclick="deleteEntryAtIndex(${i})">
                                Delete
                            </button>
                        </div>
                        <div class="entry-details">
                    `;
                    
                    if (entry.drinkType) {
                        entryHtml += `
                            <div class="entry-label">Drink:</div>
                            <div>${entry.drinkType} (${entry.drinkAmount || 0} ml)</div>
                        `;
                    }
                    
                    if (entry.urineVolume) {
                        entryHtml += `
                            <div class="entry-label">Urine:</div>
                            <div>${entry.urineVolume} seconds (Urgency: ${entry.urgency || 'N/A'})</div>
                        `;
                    }
                    
                    if (entry.urineStream) {
                        entryHtml += `
                            <div class="entry-label">Urine Flow:</div>
                            <div>Stream: ${entry.urineStream}</div>
                        `;
                    }
                    
                    entryHtml += `</div>`;
                    entryEl.innerHTML = entryHtml;
                    entriesList.appendChild(entryEl);
                }
                
                // If dashboard is visible, update it too
                if (!dashboard.classList.contains('hidden')) {
                    renderDashboard();
                }
            } catch (error) {
                console.error('Error rendering entries', error);
                showMessage('Error displaying entries');
            }
        }
        
        // Handle form submission
        entryForm.addEventListener('submit', function(e) {
            e.preventDefault();
            
            try {
                // If timer is still running, stop it
                if (timerActive) {
                    timerActive = false;
                    clearInterval(timerInterval);
                    const elapsedSeconds = Math.floor((Date.now() - timerStart) / 1000);
                    urineVolumeInput.value = elapsedSeconds;
                    timerBtn.textContent = 'Start';
                    timerBtn.classList.remove('active');
                    timerIndicator.classList.add('hidden');
                    timerIndicator.classList.remove('pulse');
                }
                
                // Get form values
                const newEntry = {
                    date: document.getElementById('date').value,
                    time: document.getElementById('time').value,
                    drinkType: document.getElementById('drinkType').value,
                    drinkAmount: document.getElementById('drinkAmount').value,
                    urineVolume: document.getElementById('urineVolume').value,
                    urgency: document.getElementById('urgency').value,
                    urineStream: document.getElementById('urineStream').value
                };
                
                // Add new entry
                entries.push(newEntry);
                
                // Save to storage
                saveEntries();
                
                // Render entries
                renderEntries();
                
                // Reset form and hide
                entryForm.reset();
                entryForm.style.display = 'none';
                toggleFormBtn.textContent = 'Add New Entry';
                
                // Show success message
                showMessage('Entry saved successfully!', 'success');
                
            } catch (error) {
                console.error('Error saving entry', error);
                showMessage('Error saving entry');
            }
        });
        
        // Toggle export data
        toggleExportBtn.addEventListener('click', function() {
            try {
                if (entries.length === 0) {
                    showMessage('No entries to export');
                    return;
                }
                
                if (exportArea.style.display === 'none' || exportArea.style.display === '') {
                    // Create a clean text representation
                    let textData = "BLADDER DIARY ENTRIES\n\n";
                    
                    // Sort by date and time (oldest first for export)
                    const sortedEntries = entries.slice().sort(function(a, b) {
                        // Compare dates directly as strings (YYYY-MM-DD format sorts correctly)
                        if (a.date !== b.date) {
                            return a.date > b.date ? 1 : -1;
                        }
                        // If dates are the same, compare times
                        return a.time > b.time ? 1 : -1;
                    });
                    
                    sortedEntries.forEach(function(entry) {
                        textData += `Date: ${entry.date} Time: ${entry.time}\n`;
                        
                        if (entry.drinkType) {
                            textData += `Drink: ${entry.drinkType} (${entry.drinkAmount || 0} ml)\n`;
                        }
                        
                        if (entry.urineVolume) {
                            textData += `Urine: ${entry.urineVolume} seconds (Urgency: ${entry.urgency || 'N/A'})\n`;
                        }
                        
                        if (entry.urineStream) {
                            textData += `Urine Flow: Stream: ${entry.urineStream}\n`;
                        }
                        
                        textData += `\n`;
                    });
                    
                    // Show in textarea and auto-select
                    exportArea.value = textData;
                    exportArea.style.display = 'block';
                    
                    // IMPROVED: Use setTimeout to ensure selection happens after display
                    setTimeout(() => {
                        exportArea.focus();
                        exportArea.select();
                    }, 100);
                    
                    toggleExportBtn.textContent = 'Hide Export Data';
                    showMessage('Text is selected and ready to copy', 'success');
                } else {
                    exportArea.style.display = 'none';
                    toggleExportBtn.textContent = 'Show Export Data';
                }
                
            } catch (error) {
                console.error('Error exporting data', error);
                showMessage('Error creating export');
            }
        });
        
        // Dashboard toggle functionality
        toggleDashboardBtn.addEventListener('click', function() {
            try {
                if (dashboard.classList.contains('hidden')) {
                    dashboard.classList.remove('hidden');
                    toggleDashboardBtn.textContent = 'Hide Dashboard';
                    renderDashboard();
                } else {
                    dashboard.classList.add('hidden');
                    toggleDashboardBtn.textContent = 'Show Dashboard';
                }
            } catch (error) {
                console.error('Error toggling dashboard', error);
                showMessage('Error showing dashboard');
            }
        });
        
        // IMPROVED: Canvas utility functions
        function clearCanvas(canvas) {
            const ctx = canvas.getContext('2d');
            ctx.clearRect(0, 0, canvas.width, canvas.height);
        }
        
        function setCanvasDimensions(canvas) {
            // Get the display dimensions
            const displayWidth = canvas.clientWidth;
            const displayHeight = canvas.clientHeight;
            
            // Check if the canvas is not the same size
            if (canvas.width !== displayWidth || canvas.height !== displayHeight) {
                // Set the canvas size to match the display size
                canvas.width = displayWidth;
                canvas.height = displayHeight;
            }
        }
        
        function drawEmptyState(canvas, message) {
            const ctx = canvas.getContext('2d');
            const width = canvas.width;
            const height = canvas.height;
            
            ctx.fillStyle = '#f8f9fa';
            ctx.fillRect(0, 0, width, height);
            
            ctx.font = '14px sans-serif';
            ctx.fillStyle = '#a0aec0';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(message, width / 2, height / 2);
        }
        
        // Dashboard-related functions
        function renderDashboard() {
            try {
                // Check if we have any data
                if (entries.length === 0) {
                    noDataMsg.style.display = 'block';
                    dashboardCharts.classList.add('hidden');
                    return;
                }

                // We have data, show the charts
                noDataMsg.style.display = 'none';
                dashboardCharts.classList.remove('hidden');

                // Render each chart
                renderFrequencyChart();
                renderUrgencyChart();
                renderCorrelationChart();
                renderStreamChart();
            } catch (error) {
                console.error('Error rendering dashboard', error);
                showMessage('Error displaying dashboard');
            }
        }

        // IMPROVED: Canvas-based charts
        function renderFrequencyChart() {
            try {
                const canvas = document.getElementById('frequencyCanvas');
                if (!canvas) return;
                
                setCanvasDimensions(canvas);
                clearCanvas(canvas);
                
                // Group entries by date
                const entriesByDate = {};
                let hasUrineData = false;

                entries.forEach(entry => {
                    if (entry.urineVolume) {
                        hasUrineData = true;
                        
                        if (!entriesByDate[entry.date]) {
                            entriesByDate[entry.date] = 0;
                        }
                        entriesByDate[entry.date]++;
                    }
                });

                if (!hasUrineData) {
                    drawEmptyState(canvas, 'No urination data recorded yet');
                    return;
                }

                // Convert to array and sort by date
                const dateFrequencies = Object.entries(entriesByDate)
                    .sort((a, b) => a[0].localeCompare(b[0]))
                    .slice(-7); // Only show the last 7 days with data
                
                if (dateFrequencies.length === 0) {
                    drawEmptyState(canvas, 'No urination data recorded yet');
                    return;
                }

                const ctx = canvas.getContext('2d');
                const width = canvas.width;
                const height = canvas.height;
                const padding = { top: 30, right: 20, bottom: 40, left: 30 };
                
                const chartWidth = width - padding.left - padding.right;
                const chartHeight = height - padding.top - padding.bottom;
                
                // Find the maximum frequency for scaling
                const maxFrequency = Math.max(...dateFrequencies.map(df => df[1]));
                
                // Draw background
                ctx.fillStyle = '#f8f9fa';
                ctx.fillRect(0, 0, width, height);
                
                // Draw horizontal grid lines
                ctx.strokeStyle = '#e2e8f0';
                ctx.lineWidth = 1;
                
                for (let i = 0; i <= 5; i++) {
                    const y = padding.top + chartHeight - (i / 5) * chartHeight;
                    ctx.beginPath();
                    ctx.moveTo(padding.left, y);
                    ctx.lineTo(width - padding.right, y);
                    ctx.stroke();
                    
                    // Draw y-axis labels
                    ctx.fillStyle = '#718096';
                    ctx.font = '10px sans-serif';
                    ctx.textAlign = 'right';
                    ctx.textBaseline = 'middle';
                    ctx.fillText(Math.round((i / 5) * maxFrequency), padding.left - 5, y);
                }
                
                // Draw bars
                const barWidth = chartWidth / dateFrequencies.length * 0.7;
                const barSpacing = chartWidth / dateFrequencies.length;
                
                dateFrequencies.forEach((dateFreq, index) => {
                    const [date, count] = dateFreq;
                    const barHeight = (count / maxFrequency) * chartHeight;
                    const x = padding.left + index * barSpacing + (barSpacing - barWidth) / 2;
                    const y = padding.top + chartHeight - barHeight;
                    
                    // Draw bar with gradient
                    const gradient = ctx.createLinearGradient(x, y, x, y + barHeight);
                    gradient.addColorStop(0, '#a651e6');
                    gradient.addColorStop(1, '#4f9cf9');
                    
                    ctx.fillStyle = gradient;
                    ctx.beginPath();
                    ctx.roundRect(x, y, barWidth, barHeight, [4, 4, 0, 0]);
                    ctx.fill();
                    
                    // Draw bar value
                    ctx.fillStyle = '#4a5568';
                    ctx.font = '10px sans-serif';
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'bottom';
                    ctx.fillText(count, x + barWidth / 2, y - 5);
                    
                    // Draw x-axis labels
                    ctx.fillStyle = '#718096';
                    ctx.font = '10px sans-serif';
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'top';
                    ctx.save();
                    ctx.translate(x + barWidth / 2, height - padding.bottom / 2);
                    ctx.rotate(-Math.PI / 4); // Rotate labels 45 degrees
                    ctx.fillText(formatDate(date), 0, 0);
                    ctx.restore();
                });
            } catch (error) {
                console.error('Error rendering frequency chart', error);
                const canvas = document.getElementById('frequencyCanvas');
                if (canvas) {
                    drawEmptyState(canvas, 'Could not generate chart');
                }
            }
        }

        function renderUrgencyChart() {
            try {
                const canvas = document.getElementById('urgencyCanvas');
                if (!canvas) return;
                
                setCanvasDimensions(canvas);
                clearCanvas(canvas);
                
                // Count urgency levels
                const urgencyCounts = { '0': 0, '1': 0, '2': 0, '3': 0 };
                let hasUrgencyData = false;

                entries.forEach(entry => {
                    if (entry.urgency) {
                        hasUrgencyData = true;
                        urgencyCounts[entry.urgency]++;
                    }
                });

                if (!hasUrgencyData) {
                    drawEmptyState(canvas, 'No urgency data recorded yet');
                    return;
                }

                // Calculate total for percentages
                const total = Object.values(urgencyCounts).reduce((sum, count) => sum + count, 0);
                if (total === 0) {
                    drawEmptyState(canvas, 'No urgency data recorded yet');
                    return;
                }
                
                const ctx = canvas.getContext('2d');
                const width = canvas.width;
                const height = canvas.height;
                const centerX = width / 2;
                const centerY = height / 2;
                const radius = Math.min(width, height) / 2 - 30;
                
                // Colors for urgency levels
                const colors = {
                    '0': '#48bb78', // Green for none
                    '1': '#ecc94b', // Yellow for mild
                    '2': '#ed8936', // Orange for moderate
                    '3': '#e53e3e'  // Red for severe
                };
                
                // Display names for urgency levels
                const urgencyLabels = {
                    '0': 'None',
                    '1': 'Mild',
                    '2': 'Moderate',
                    '3': 'Severe'
                };
                
                // Draw pie chart
                let startAngle = 0;
                
                // First, draw the background
                ctx.fillStyle = '#f8f9fa';
                ctx.fillRect(0, 0, width, height);
                
                // Now draw each slice of the pie
                for (const [level, count] of Object.entries(urgencyCounts)) {
                    if (count > 0) {
                        const sliceAngle = (count / total) * 2 * Math.PI;
                        
                        ctx.beginPath();
                        ctx.moveTo(centerX, centerY);
                        ctx.arc(centerX, centerY, radius, startAngle, startAngle + sliceAngle);
                        ctx.closePath();
                        
                        ctx.fillStyle = colors[level];
                        ctx.fill();
                        
                        // Draw slice label
                        const labelAngle = startAngle + sliceAngle / 2;
                        const percent = Math.round((count / total) * 100);
                        
                        if (percent >= 5) { // Only draw label if the slice is big enough
                            // Position the label midway through the slice, at 2/3 of the radius
                            const labelX = centerX + Math.cos(labelAngle) * (radius * 0.65);
                            const labelY = centerY + Math.sin(labelAngle) * (radius * 0.65);
                            
                            ctx.fillStyle = 'white';
                            ctx.font = 'bold 12px sans-serif';
                            ctx.textAlign = 'center';
                            ctx.textBaseline = 'middle';
                            ctx.fillText(`${percent}%`, labelX, labelY);
                        }
                        
                        startAngle += sliceAngle;
                    }
                }
                
                // Draw legend
                let legendY = 20;
                ctx.textAlign = 'left';
                ctx.textBaseline = 'middle';
                
                for (const [level, count] of Object.entries(urgencyCounts)) {
                    if (count > 0) {
                        const legendX = width * 0.7;
                        
                        // Draw legend color box
                        ctx.fillStyle = colors[level];
                        ctx.fillRect(legendX, legendY, 12, 12);
                        
                        // Draw legend text
                        ctx.fillStyle = '#4a5568';
                        ctx.font = '12px sans-serif';
                        ctx.fillText(`${urgencyLabels[level]} (${count})`, legendX + 18, legendY + 6);
                        
                        legendY += 20;
                    }
                }
            } catch (error) {
                console.error('Error rendering urgency chart', error);
                const canvas = document.getElementById('urgencyCanvas');
                if (canvas) {
                    drawEmptyState(canvas, 'Could not generate chart');
                }
            }
        }

        function renderCorrelationChart() {
            try {
                const canvas = document.getElementById('correlationCanvas');
                if (!canvas) return;
                
                setCanvasDimensions(canvas);
                clearCanvas(canvas);
                
                // Group entries by date
                const dailyData = {};
                let hasData = false;

                entries.forEach(entry => {
                    if (!dailyData[entry.date]) {
                        dailyData[entry.date] = {
                            date: entry.date,
                            drinkAmount: 0,
                            urinationCount: 0
                        };
                    }
                    
                    if (entry.drinkAmount) {
                        hasData = true;
                        dailyData[entry.date].drinkAmount += parseInt(entry.drinkAmount) || 0;
                    }
                    
                    if (entry.urineVolume) {
                        hasData = true;
                        dailyData[entry.date].urinationCount++;
                    }
                });

                if (!hasData) {
                    drawEmptyState(canvas, 'Not enough data for correlation');
                    return;
                }

                // Convert to array and sort by date
                const dailyDataArray = Object.values(dailyData)
                    .filter(day => day.drinkAmount > 0 || day.urinationCount > 0)
                    .sort((a, b) => a.date.localeCompare(b.date))
                    .slice(-5); // Last 5 days with data
                    
                if (dailyDataArray.length === 0) {
                    drawEmptyState(canvas, 'Not enough data for correlation');
                    return;
                }
                
                const ctx = canvas.getContext('2d');
                const width = canvas.width;
                const height = canvas.height;
                const padding = { top: 30, right: 20, bottom: 50, left: 50 };
                
                const chartWidth = width - padding.left - padding.right;
                const chartHeight = height - padding.top - padding.bottom;
                
                // Draw background
                ctx.fillStyle = '#f8f9fa';
                ctx.fillRect(0, 0, width, height);
                
                // Find max values for scaling
                const maxDrink = Math.max(...dailyDataArray.map(day => day.drinkAmount));
                const maxCount = Math.max(...dailyDataArray.map(day => day.urinationCount));
                
                // Draw grid lines
                ctx.strokeStyle = '#e2e8f0';
                ctx.lineWidth = 1;
                
                // Draw y-axis line
                ctx.beginPath();
                ctx.moveTo(padding.left, padding.top);
                ctx.lineTo(padding.left, height - padding.bottom);
                ctx.stroke();
                
                // Draw x-axis line
                ctx.beginPath();
                ctx.moveTo(padding.left, height - padding.bottom);
                ctx.lineTo(width - padding.right, height - padding.bottom);
                ctx.stroke();
                
                // Draw horizontal grid lines for drink amount
                for (let i = 0; i <= 5; i++) {
                    const y = padding.top + (1 - i / 5) * chartHeight;
                    ctx.beginPath();
                    ctx.moveTo(padding.left, y);
                    ctx.lineTo(width - padding.right, y);
                    ctx.stroke();
                    
                    // Draw y-axis labels for drink amount
                    const drinkValue = Math.round((i / 5) * maxDrink);
                    ctx.fillStyle = '#4f9cf9';
                    ctx.font = '10px sans-serif';
                    ctx.textAlign = 'right';
                    ctx.textBaseline = 'middle';
                    ctx.fillText(`${drinkValue} ml`, padding.left - 5, y);
                }
                
                // Draw group bar chart
                const barWidth = chartWidth / dailyDataArray.length * 0.3;
                const groupWidth = chartWidth / dailyDataArray.length;
                
                dailyDataArray.forEach((day, index) => {
                    // Draw date label
                    ctx.fillStyle = '#718096';
                    ctx.font = '10px sans-serif';
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'top';
                    ctx.save();
                    ctx.translate(padding.left + index * groupWidth + groupWidth / 2, height - padding.bottom + 5);
                    ctx.rotate(-Math.PI / 4); // Rotate labels 45 degrees
                    ctx.fillText(formatDate(day.date), 0, 0);
                    ctx.restore();
                    
                    // Draw drink amount bar
                    const drinkBarHeight = maxDrink > 0 ? (day.drinkAmount / maxDrink) * chartHeight : 0;
                    const drinkX = padding.left + index * groupWidth + groupWidth * 0.25;
                    const drinkY = height - padding.bottom - drinkBarHeight;
                    
                    ctx.fillStyle = '#4f9cf9';
                    ctx.beginPath();
                    ctx.roundRect(drinkX, drinkY, barWidth, drinkBarHeight, [4, 4, 0, 0]);
                    ctx.fill();
                    
                    // Draw drink value
                    if (day.drinkAmount > 0) {
                        ctx.fillStyle = '#4a5568';
                        ctx.font = '10px sans-serif';
                        ctx.textAlign = 'center';
                        ctx.fillText(day.drinkAmount, drinkX + barWidth / 2, drinkY - 5);
                    }
                    
                    // Draw urination count bar scaled up for visibility
                    const countBarHeight = maxCount > 0 ? (day.urinationCount / maxCount) * chartHeight : 0;
                    const countX = padding.left + index * groupWidth + groupWidth * 0.6;
                    const countY = height - padding.bottom - countBarHeight;
                    
                    ctx.fillStyle = '#a651e6';
                    ctx.beginPath();
                    ctx.roundRect(countX, countY, barWidth, countBarHeight, [4, 4, 0, 0]);
                    ctx.fill();
                    
                    // Draw count value
                    if (day.urinationCount > 0) {
                        ctx.fillStyle = '#4a5568';
                        ctx.font = '10px sans-serif';
                        ctx.textAlign = 'center';
                        ctx.fillText(day.urinationCount, countX + barWidth / 2, countY - 5);
                    }
                });
                
                // Draw legend
                const legendY = height - 15;
                
                // Drink legend
                ctx.fillStyle = '#4f9cf9';
                ctx.fillRect(padding.left, legendY, 12, 12);
                ctx.fillStyle = '#4a5568';
                ctx.font = '10px sans-serif';
                ctx.textAlign = 'left';
                ctx.textBaseline = 'middle';
                ctx.fillText('Fluid intake (ml)', padding.left + 16, legendY + 6);
                
                // Count legend
                ctx.fillStyle = '#a651e6';
                ctx.fillRect(padding.left + 120, legendY, 12, 12);
                ctx.fillStyle = '#4a5568';
                ctx.fillText('Urination frequency', padding.left + 136, legendY + 6);
                
            } catch (error) {
                console.error('Error rendering correlation chart', error);
                const canvas = document.getElementById('correlationCanvas');
                if (canvas) {
                    drawEmptyState(canvas, 'Could not generate chart');
                }
            }
        }

        function renderStreamChart() {
            try {
                const canvas = document.getElementById('streamCanvas');
                if (!canvas) return;
                
                setCanvasDimensions(canvas);
                clearCanvas(canvas);
                
                // Count stream types
                const streamCounts = { 'Strong': 0, 'Intermittent': 0, 'Weak': 0 };
                let hasStreamData = false;
                
                entries.forEach(entry => {
                    if (entry.urineStream && streamCounts.hasOwnProperty(entry.urineStream)) {
                        hasStreamData = true;
                        streamCounts[entry.urineStream]++;
                    }
                });
                
                if (!hasStreamData) {
                    drawEmptyState(canvas, 'No stream data recorded yet');
                    return;
                }
                
                // Calculate total
                const total = Object.values(streamCounts).reduce((sum, count) => sum + count, 0);
                if (total === 0) {
                    drawEmptyState(canvas, 'No stream data recorded yet');
                    return;
                }
                
                const ctx = canvas.getContext('2d');
                const width = canvas.width;
                const height = canvas.height;
                const padding = { top: 20, right: 20, bottom: 40, left: 20 };
                
                const chartWidth = width - padding.left - padding.right;
                const chartHeight = height - padding.top - padding.bottom;
                
                // Draw background
                ctx.fillStyle = '#f8f9fa';
                ctx.fillRect(0, 0, width, height);
                
                // Colors for stream types
                const colors = {
                    'Strong': '#48bb78',
                    'Intermittent': '#ecc94b',
                    'Weak': '#e53e3e'
                };
                
                // Filter out zero counts
                const streamTypes = Object.keys(streamCounts).filter(type => streamCounts[type] > 0);
                
                // Draw bar chart
                const barWidth = chartWidth / streamTypes.length * 0.7;
                const barSpacing = chartWidth / streamTypes.length;
                
                streamTypes.forEach((type, index) => {
                    const count = streamCounts[type];
                    const percent = (count / total) * 100;
                    const barHeight = (percent / 100) * chartHeight;
                    const x = padding.left + index * barSpacing + (barSpacing - barWidth) / 2;
                    const y = padding.top + chartHeight - barHeight;
                    
                    // Draw bar
                    ctx.fillStyle = colors[type];
                    ctx.beginPath();
                    ctx.roundRect(x, y, barWidth, barHeight, [4, 4, 0, 0]);
                    ctx.fill();
                    
                    // Draw percentage
                    ctx.fillStyle = '#4a5568';
                    ctx.font = '10px sans-serif';
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'bottom';
                    ctx.fillText(`${Math.round(percent)}%`, x + barWidth / 2, y - 5);
                    
                    // Draw stream type label
                    ctx.fillStyle = '#4a5568';
                    ctx.font = '12px sans-serif';
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'top';
                    ctx.fillText(type, x + barWidth / 2, height - padding.bottom + 5);
                });
                
                // Try to find trends - only if enough entries
                const recentEntries = entries
                    .filter(e => e.urineStream)
                    .sort((a, b) => a.date + a.time < b.date + b.time ? 1 : -1);
                    
                if (recentEntries.length >= 5) {
                    const lastFive = recentEntries.slice(0, 5);
                    const strongCount = lastFive.filter(e => e.urineStream === 'Strong').length;
                    const weakCount = lastFive.filter(e => e.urineStream === 'Weak').length;
                    
                    // Draw trend indicator
                    ctx.font = '14px sans-serif';
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    
                    let trendText = '';
                    
                    if (strongCount >= 3) {
                        ctx.fillStyle = '#48bb78';
                        trendText = '👍 Improving trend';
                    } else if (weakCount >= 3) {
                        ctx.fillStyle = '#e53e3e';
                        trendText = '👎 Worsening trend';
                    } else {
                        ctx.fillStyle = '#ecc94b';
                        trendText = '➡️ Stable trend';
                    }
                    
                    ctx.fillText(trendText, width / 2, height - 10);
                }
            } catch (error) {
                console.error('Error rendering stream chart', error);
                const canvas = document.getElementById('streamCanvas');
                if (canvas) {
                    drawEmptyState(canvas, 'Could not generate chart');
                }
            }
        }
        
        // Pull-to-refresh functionality
        function startRefreshing() {
            if (isRefreshing) return;
            isRefreshing = true;
            
            pullToRefresh.classList.add('refreshing');
            
            // Simulate a refresh (in this case, just reload entries from storage)
            setTimeout(function() {
                loadEntries();
                pullToRefresh.classList.remove('visible', 'refreshing');
                isRefreshing = false;
                showMessage('Refreshed', 'success');
            }, 800);
        }
        
        // Touch event handlers for pull-to-refresh
        document.addEventListener('touchstart', function(e) {
            // Only trigger if we're at the top of the page
            if (window.scrollY === 0) {
                touchStartY = e.touches[0].clientY;
            }
        }, { passive: true });
        
        document.addEventListener('touchmove', function(e) {
            if (touchStartY > 0 && !isRefreshing) {
                touchEndY = e.touches[0].clientY;
                const distance = touchEndY - touchStartY;
                
                // Only show pull indicator if we're pulling down
                if (distance > 0) {
                    pullToRefresh.classList.add('visible');
                    
                    // Calculate a rotation for the refresh icon based on pull distance
                    const rotationDegrees = Math.min(distance * 2, 180);
                    document.querySelector('.pull-to-refresh-icon').style.transform = `rotate(${rotationDegrees}deg)`;
                }
            }
        }, { passive: true });
        
        document.addEventListener('touchend', function() {
            if (touchStartY > 0 && touchEndY > 0 && !isRefreshing) {
                const distance = touchEndY - touchStartY;
                
                // If pulled far enough, trigger refresh
                if (distance > 60) {
                    startRefreshing();
                } else {
                    // Otherwise, just hide the indicator
                    pullToRefresh.classList.remove('visible');
                }
                
                // Reset values
                touchStartY = 0;
                touchEndY = 0;
            }
        }, { passive: true });
        
        
        
        // IMPROVED: Add focus and select handler for export text
        exportArea.addEventListener('blur', function() {
            setTimeout(() => {
                exportArea.focus();
                exportArea.select();
            }, 100);
        });
        
        // Initialize app
        entryForm.style.display = 'none';
        exportArea.style.display = 'none';
        setCurrentDateTime();
        loadSampleData(); // Load sample data for demo
        loadEntries(); // Load any previously saved entries
    </script>
</body>
</html>
